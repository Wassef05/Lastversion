{"ast":null,"code":"var _asyncToGenerator = require(\"/home/wassef/Bureau/lastversion/frontend/node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\n/**\n * TinyMCE version 6.8.2 (2023-12-11)\n */\n(function () {\n  'use strict';\n\n  var typeOf$1 = function (x) {\n    if (x === null) {\n      return 'null';\n    }\n\n    if (x === undefined) {\n      return 'undefined';\n    }\n\n    var t = typeof x;\n\n    if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n      return 'array';\n    }\n\n    if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n      return 'string';\n    }\n\n    return t;\n  };\n\n  var isEquatableType = function (x) {\n    return ['undefined', 'boolean', 'number', 'string', 'function', 'xml', 'null'].indexOf(x) !== -1;\n  };\n\n  var sort$1 = function (xs, compareFn) {\n    var clone = Array.prototype.slice.call(xs);\n    return clone.sort(compareFn);\n  };\n\n  var contramap = function (eqa, f) {\n    return eq$2(function (x, y) {\n      return eqa.eq(f(x), f(y));\n    });\n  };\n\n  var eq$2 = function (f) {\n    return {\n      eq: f\n    };\n  };\n\n  var tripleEq = eq$2(function (x, y) {\n    return x === y;\n  });\n  var eqString = tripleEq;\n\n  var eqArray = function (eqa) {\n    return eq$2(function (x, y) {\n      if (x.length !== y.length) {\n        return false;\n      }\n\n      var len = x.length;\n\n      for (var i = 0; i < len; i++) {\n        if (!eqa.eq(x[i], y[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  };\n\n  var eqSortedArray = function (eqa, compareFn) {\n    return contramap(eqArray(eqa), function (xs) {\n      return sort$1(xs, compareFn);\n    });\n  };\n\n  var eqRecord = function (eqa) {\n    return eq$2(function (x, y) {\n      var kx = Object.keys(x);\n      var ky = Object.keys(y);\n\n      if (!eqSortedArray(eqString).eq(kx, ky)) {\n        return false;\n      }\n\n      var len = kx.length;\n\n      for (var i = 0; i < len; i++) {\n        var q = kx[i];\n\n        if (!eqa.eq(x[q], y[q])) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  };\n\n  var eqAny = eq$2(function (x, y) {\n    if (x === y) {\n      return true;\n    }\n\n    var tx = typeOf$1(x);\n    var ty = typeOf$1(y);\n\n    if (tx !== ty) {\n      return false;\n    }\n\n    if (isEquatableType(tx)) {\n      return x === y;\n    } else if (tx === 'array') {\n      return eqArray(eqAny).eq(x, y);\n    } else if (tx === 'object') {\n      return eqRecord(eqAny).eq(x, y);\n    }\n\n    return false;\n  });\n  const getPrototypeOf$2 = Object.getPrototypeOf;\n\n  const hasProto = (v, constructor, predicate) => {\n    var _a;\n\n    if (predicate(v, constructor.prototype)) {\n      return true;\n    } else {\n      return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n    }\n  };\n\n  const typeOf = x => {\n    const t = typeof x;\n\n    if (x === null) {\n      return 'null';\n    } else if (t === 'object' && Array.isArray(x)) {\n      return 'array';\n    } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n      return 'string';\n    } else {\n      return t;\n    }\n  };\n\n  const isType$1 = type => value => typeOf(value) === type;\n\n  const isSimpleType = type => value => typeof value === type;\n\n  const eq$1 = t => a => t === a;\n\n  const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n\n  const isString = isType$1('string');\n  const isObject = isType$1('object');\n\n  const isPlainObject = value => is$4(value, Object);\n\n  const isArray$1 = isType$1('array');\n  const isNull = eq$1(null);\n  const isBoolean = isSimpleType('boolean');\n  const isUndefined = eq$1(undefined);\n\n  const isNullable = a => a === null || a === undefined;\n\n  const isNonNullable = a => !isNullable(a);\n\n  const isFunction = isSimpleType('function');\n  const isNumber = isSimpleType('number');\n\n  const isArrayOf = (value, pred) => {\n    if (isArray$1(value)) {\n      for (let i = 0, len = value.length; i < len; ++i) {\n        if (!pred(value[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  const noop = () => {};\n\n  const compose = (fa, fb) => {\n    return (...args) => {\n      return fa(fb.apply(null, args));\n    };\n  };\n\n  const compose1 = (fbc, fab) => a => fbc(fab(a));\n\n  const constant = value => {\n    return () => {\n      return value;\n    };\n  };\n\n  const identity = x => {\n    return x;\n  };\n\n  const tripleEquals = (a, b) => {\n    return a === b;\n  };\n\n  function curry(fn, ...initialArgs) {\n    return (...restArgs) => {\n      const all = initialArgs.concat(restArgs);\n      return fn.apply(null, all);\n    };\n  }\n\n  const not = f => t => !f(t);\n\n  const die = msg => {\n    return () => {\n      throw new Error(msg);\n    };\n  };\n\n  const apply$1 = f => {\n    return f();\n  };\n\n  const call = f => {\n    f();\n  };\n\n  const never = constant(false);\n  const always = constant(true);\n\n  class Optional {\n    constructor(tag, value) {\n      this.tag = tag;\n      this.value = value;\n    }\n\n    static some(value) {\n      return new Optional(true, value);\n    }\n\n    static none() {\n      return Optional.singletonNone;\n    }\n\n    fold(onNone, onSome) {\n      if (this.tag) {\n        return onSome(this.value);\n      } else {\n        return onNone();\n      }\n    }\n\n    isSome() {\n      return this.tag;\n    }\n\n    isNone() {\n      return !this.tag;\n    }\n\n    map(mapper) {\n      if (this.tag) {\n        return Optional.some(mapper(this.value));\n      } else {\n        return Optional.none();\n      }\n    }\n\n    bind(binder) {\n      if (this.tag) {\n        return binder(this.value);\n      } else {\n        return Optional.none();\n      }\n    }\n\n    exists(predicate) {\n      return this.tag && predicate(this.value);\n    }\n\n    forall(predicate) {\n      return !this.tag || predicate(this.value);\n    }\n\n    filter(predicate) {\n      if (!this.tag || predicate(this.value)) {\n        return this;\n      } else {\n        return Optional.none();\n      }\n    }\n\n    getOr(replacement) {\n      return this.tag ? this.value : replacement;\n    }\n\n    or(replacement) {\n      return this.tag ? this : replacement;\n    }\n\n    getOrThunk(thunk) {\n      return this.tag ? this.value : thunk();\n    }\n\n    orThunk(thunk) {\n      return this.tag ? this : thunk();\n    }\n\n    getOrDie(message) {\n      if (!this.tag) {\n        throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n      } else {\n        return this.value;\n      }\n    }\n\n    static from(value) {\n      return isNonNullable(value) ? Optional.some(value) : Optional.none();\n    }\n\n    getOrNull() {\n      return this.tag ? this.value : null;\n    }\n\n    getOrUndefined() {\n      return this.value;\n    }\n\n    each(worker) {\n      if (this.tag) {\n        worker(this.value);\n      }\n    }\n\n    toArray() {\n      return this.tag ? [this.value] : [];\n    }\n\n    toString() {\n      return this.tag ? `some(${this.value})` : 'none()';\n    }\n\n  }\n\n  Optional.singletonNone = new Optional(false);\n  const nativeSlice = Array.prototype.slice;\n  const nativeIndexOf = Array.prototype.indexOf;\n  const nativePush = Array.prototype.push;\n\n  const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n\n  const indexOf$1 = (xs, x) => {\n    const r = rawIndexOf(xs, x);\n    return r === -1 ? Optional.none() : Optional.some(r);\n  };\n\n  const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n\n  const exists = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const map$3 = (xs, f) => {\n    const len = xs.length;\n    const r = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      const x = xs[i];\n      r[i] = f(x, i);\n    }\n\n    return r;\n  };\n\n  const each$e = (xs, f) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n\n  const eachr = (xs, f) => {\n    for (let i = xs.length - 1; i >= 0; i--) {\n      const x = xs[i];\n      f(x, i);\n    }\n  };\n\n  const partition$2 = (xs, pred) => {\n    const pass = [];\n    const fail = [];\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      const arr = pred(x, i) ? pass : fail;\n      arr.push(x);\n    }\n\n    return {\n      pass,\n      fail\n    };\n  };\n\n  const filter$5 = (xs, pred) => {\n    const r = [];\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        r.push(x);\n      }\n    }\n\n    return r;\n  };\n\n  const foldr = (xs, f, acc) => {\n    eachr(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n\n  const foldl = (xs, f, acc) => {\n    each$e(xs, (x, i) => {\n      acc = f(acc, x, i);\n    });\n    return acc;\n  };\n\n  const findUntil$1 = (xs, pred, until) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        return Optional.some(x);\n      } else if (until(x, i)) {\n        break;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const find$2 = (xs, pred) => {\n    return findUntil$1(xs, pred, never);\n  };\n\n  const findIndex$2 = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (pred(x, i)) {\n        return Optional.some(i);\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const flatten = xs => {\n    const r = [];\n\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      if (!isArray$1(xs[i])) {\n        throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n      }\n\n      nativePush.apply(r, xs[i]);\n    }\n\n    return r;\n  };\n\n  const bind$3 = (xs, f) => flatten(map$3(xs, f));\n\n  const forall = (xs, pred) => {\n    for (let i = 0, len = xs.length; i < len; ++i) {\n      const x = xs[i];\n\n      if (pred(x, i) !== true) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  const reverse = xs => {\n    const r = nativeSlice.call(xs, 0);\n    r.reverse();\n    return r;\n  };\n\n  const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n\n  const mapToObject = (xs, f) => {\n    const r = {};\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n      r[String(x)] = f(x, i);\n    }\n\n    return r;\n  };\n\n  const sort = (xs, comparator) => {\n    const copy = nativeSlice.call(xs, 0);\n    copy.sort(comparator);\n    return copy;\n  };\n\n  const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n\n  const head = xs => get$b(xs, 0);\n\n  const last$3 = xs => get$b(xs, xs.length - 1);\n\n  const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n\n  const findMap = (arr, f) => {\n    for (let i = 0; i < arr.length; i++) {\n      const r = f(arr[i], i);\n\n      if (r.isSome()) {\n        return r;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const unique$1 = (xs, comparator) => {\n    const r = [];\n    const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n\n    for (let i = 0, len = xs.length; i < len; i++) {\n      const x = xs[i];\n\n      if (!isDuplicated(x)) {\n        r.push(x);\n      }\n    }\n\n    return r;\n  };\n\n  const keys = Object.keys;\n  const hasOwnProperty$1 = Object.hasOwnProperty;\n\n  const each$d = (obj, f) => {\n    const props = keys(obj);\n\n    for (let k = 0, len = props.length; k < len; k++) {\n      const i = props[k];\n      const x = obj[i];\n      f(x, i);\n    }\n  };\n\n  const map$2 = (obj, f) => {\n    return tupleMap(obj, (x, i) => ({\n      k: i,\n      v: f(x, i)\n    }));\n  };\n\n  const tupleMap = (obj, f) => {\n    const r = {};\n    each$d(obj, (x, i) => {\n      const tuple = f(x, i);\n      r[tuple.k] = tuple.v;\n    });\n    return r;\n  };\n\n  const objAcc = r => (x, i) => {\n    r[i] = x;\n  };\n\n  const internalFilter = (obj, pred, onTrue, onFalse) => {\n    each$d(obj, (x, i) => {\n      (pred(x, i) ? onTrue : onFalse)(x, i);\n    });\n  };\n\n  const bifilter = (obj, pred) => {\n    const t = {};\n    const f = {};\n    internalFilter(obj, pred, objAcc(t), objAcc(f));\n    return {\n      t,\n      f\n    };\n  };\n\n  const filter$4 = (obj, pred) => {\n    const t = {};\n    internalFilter(obj, pred, objAcc(t), noop);\n    return t;\n  };\n\n  const mapToArray = (obj, f) => {\n    const r = [];\n    each$d(obj, (value, name) => {\n      r.push(f(value, name));\n    });\n    return r;\n  };\n\n  const values = obj => {\n    return mapToArray(obj, identity);\n  };\n\n  const get$a = (obj, key) => {\n    return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n  };\n\n  const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n\n  const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n\n  const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n  const stringArray = a => {\n    const all = {};\n    each$e(a, key => {\n      all[key] = {};\n    });\n    return keys(all);\n  };\n\n  const isArrayLike = o => o.length !== undefined;\n\n  const isArray = Array.isArray;\n\n  const toArray$1 = obj => {\n    if (!isArray(obj)) {\n      const array = [];\n\n      for (let i = 0, l = obj.length; i < l; i++) {\n        array[i] = obj[i];\n      }\n\n      return array;\n    } else {\n      return obj;\n    }\n  };\n\n  const each$c = (o, cb, s) => {\n    if (!o) {\n      return false;\n    }\n\n    s = s || o;\n\n    if (isArrayLike(o)) {\n      for (let n = 0, l = o.length; n < l; n++) {\n        if (cb.call(s, o[n], n, o) === false) {\n          return false;\n        }\n      }\n    } else {\n      for (const n in o) {\n        if (has$2(o, n)) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  const map$1 = (array, callback) => {\n    const out = [];\n    each$c(array, (item, index) => {\n      out.push(callback(item, index, array));\n    });\n    return out;\n  };\n\n  const filter$3 = (a, f) => {\n    const o = [];\n    each$c(a, (v, index) => {\n      if (!f || f(v, index, a)) {\n        o.push(v);\n      }\n    });\n    return o;\n  };\n\n  const indexOf = (a, v) => {\n    if (a) {\n      for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] === v) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  const reduce = (collection, iteratee, accumulator, thisArg) => {\n    let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n\n    for (let i = 0; i < collection.length; i++) {\n      acc = iteratee.call(thisArg, acc, collection[i], i);\n    }\n\n    return acc;\n  };\n\n  const findIndex$1 = (array, predicate, thisArg) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n      if (predicate.call(thisArg, array[i], i, array)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  const last$2 = collection => collection[collection.length - 1];\n\n  const cached = f => {\n    let called = false;\n    let r;\n    return (...args) => {\n      if (!called) {\n        called = true;\n        r = f.apply(null, args);\n      }\n\n      return r;\n    };\n  };\n\n  const DeviceType = (os, browser, userAgent, mediaMatch) => {\n    const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n    const isiPhone = os.isiOS() && !isiPad;\n    const isMobile = os.isiOS() || os.isAndroid();\n    const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n    const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n    const isPhone = isiPhone || isMobile && !isTablet;\n    const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n    const isDesktop = !isPhone && !isTablet && !iOSwebview;\n    return {\n      isiPad: constant(isiPad),\n      isiPhone: constant(isiPhone),\n      isTablet: constant(isTablet),\n      isPhone: constant(isPhone),\n      isTouch: constant(isTouch),\n      isAndroid: os.isAndroid,\n      isiOS: os.isiOS,\n      isWebView: constant(iOSwebview),\n      isDesktop: constant(isDesktop)\n    };\n  };\n\n  const firstMatch = (regexes, s) => {\n    for (let i = 0; i < regexes.length; i++) {\n      const x = regexes[i];\n\n      if (x.test(s)) {\n        return x;\n      }\n    }\n\n    return undefined;\n  };\n\n  const find$1 = (regexes, agent) => {\n    const r = firstMatch(regexes, agent);\n\n    if (!r) {\n      return {\n        major: 0,\n        minor: 0\n      };\n    }\n\n    const group = i => {\n      return Number(agent.replace(r, '$' + i));\n    };\n\n    return nu$3(group(1), group(2));\n  };\n\n  const detect$5 = (versionRegexes, agent) => {\n    const cleanedAgent = String(agent).toLowerCase();\n\n    if (versionRegexes.length === 0) {\n      return unknown$2();\n    }\n\n    return find$1(versionRegexes, cleanedAgent);\n  };\n\n  const unknown$2 = () => {\n    return nu$3(0, 0);\n  };\n\n  const nu$3 = (major, minor) => {\n    return {\n      major,\n      minor\n    };\n  };\n\n  const Version = {\n    nu: nu$3,\n    detect: detect$5,\n    unknown: unknown$2\n  };\n\n  const detectBrowser$1 = (browsers, userAgentData) => {\n    return findMap(userAgentData.brands, uaBrand => {\n      const lcBrand = uaBrand.brand.toLowerCase();\n      return find$2(browsers, browser => {\n        var _a;\n\n        return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n      }).map(info => ({\n        current: info.name,\n        version: Version.nu(parseInt(uaBrand.version, 10), 0)\n      }));\n    });\n  };\n\n  const detect$4 = (candidates, userAgent) => {\n    const agent = String(userAgent).toLowerCase();\n    return find$2(candidates, candidate => {\n      return candidate.search(agent);\n    });\n  };\n\n  const detectBrowser = (browsers, userAgent) => {\n    return detect$4(browsers, userAgent).map(browser => {\n      const version = Version.detect(browser.versionRegexes, userAgent);\n      return {\n        current: browser.name,\n        version\n      };\n    });\n  };\n\n  const detectOs = (oses, userAgent) => {\n    return detect$4(oses, userAgent).map(os => {\n      const version = Version.detect(os.versionRegexes, userAgent);\n      return {\n        current: os.name,\n        version\n      };\n    });\n  };\n\n  const removeFromStart = (str, numChars) => {\n    return str.substring(numChars);\n  };\n\n  const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n\n  const removeLeading = (str, prefix) => {\n    return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n  };\n\n  const contains$1 = (str, substr, start = 0, end) => {\n    const idx = str.indexOf(substr, start);\n\n    if (idx !== -1) {\n      return isUndefined(end) ? true : idx + substr.length <= end;\n    } else {\n      return false;\n    }\n  };\n\n  const startsWith = (str, prefix) => {\n    return checkRange(str, prefix, 0);\n  };\n\n  const endsWith = (str, suffix) => {\n    return checkRange(str, suffix, str.length - suffix.length);\n  };\n\n  const blank = r => s => s.replace(r, '');\n\n  const trim$4 = blank(/^\\s+|\\s+$/g);\n  const lTrim = blank(/^\\s+/g);\n  const rTrim = blank(/\\s+$/g);\n\n  const isNotEmpty = s => s.length > 0;\n\n  const isEmpty$3 = s => !isNotEmpty(s);\n\n  const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n\n  const toInt = (value, radix = 10) => {\n    const num = parseInt(value, radix);\n    return isNaN(num) ? Optional.none() : Optional.some(num);\n  };\n\n  const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n\n  const checkContains = target => {\n    return uastring => {\n      return contains$1(uastring, target);\n    };\n  };\n\n  const browsers = [{\n    name: 'Edge',\n    versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n    search: uastring => {\n      return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n    }\n  }, {\n    name: 'Chromium',\n    brand: 'Chromium',\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/, normalVersionRegex],\n    search: uastring => {\n      return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n    }\n  }, {\n    name: 'IE',\n    versionRegexes: [/.*?msie\\ ?([0-9]+)\\.([0-9]+).*/, /.*?rv:([0-9]+)\\.([0-9]+).*/],\n    search: uastring => {\n      return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n    }\n  }, {\n    name: 'Opera',\n    versionRegexes: [normalVersionRegex, /.*?opera\\/([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('opera')\n  }, {\n    name: 'Firefox',\n    versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n    search: checkContains('firefox')\n  }, {\n    name: 'Safari',\n    versionRegexes: [normalVersionRegex, /.*?cpu os ([0-9]+)_([0-9]+).*/],\n    search: uastring => {\n      return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n    }\n  }];\n  const oses = [{\n    name: 'Windows',\n    search: checkContains('win'),\n    versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'iOS',\n    search: uastring => {\n      return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n    },\n    versionRegexes: [/.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Android',\n    search: checkContains('android'),\n    versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n  }, {\n    name: 'macOS',\n    search: checkContains('mac os x'),\n    versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n  }, {\n    name: 'Linux',\n    search: checkContains('linux'),\n    versionRegexes: []\n  }, {\n    name: 'Solaris',\n    search: checkContains('sunos'),\n    versionRegexes: []\n  }, {\n    name: 'FreeBSD',\n    search: checkContains('freebsd'),\n    versionRegexes: []\n  }, {\n    name: 'ChromeOS',\n    search: checkContains('cros'),\n    versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n  }];\n  const PlatformInfo = {\n    browsers: constant(browsers),\n    oses: constant(oses)\n  };\n  const edge = 'Edge';\n  const chromium = 'Chromium';\n  const ie = 'IE';\n  const opera = 'Opera';\n  const firefox = 'Firefox';\n  const safari = 'Safari';\n\n  const unknown$1 = () => {\n    return nu$2({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n\n  const nu$2 = info => {\n    const current = info.current;\n    const version = info.version;\n\n    const isBrowser = name => () => current === name;\n\n    return {\n      current,\n      version,\n      isEdge: isBrowser(edge),\n      isChromium: isBrowser(chromium),\n      isIE: isBrowser(ie),\n      isOpera: isBrowser(opera),\n      isFirefox: isBrowser(firefox),\n      isSafari: isBrowser(safari)\n    };\n  };\n\n  const Browser = {\n    unknown: unknown$1,\n    nu: nu$2,\n    edge: constant(edge),\n    chromium: constant(chromium),\n    ie: constant(ie),\n    opera: constant(opera),\n    firefox: constant(firefox),\n    safari: constant(safari)\n  };\n  const windows = 'Windows';\n  const ios = 'iOS';\n  const android = 'Android';\n  const linux = 'Linux';\n  const macos = 'macOS';\n  const solaris = 'Solaris';\n  const freebsd = 'FreeBSD';\n  const chromeos = 'ChromeOS';\n\n  const unknown = () => {\n    return nu$1({\n      current: undefined,\n      version: Version.unknown()\n    });\n  };\n\n  const nu$1 = info => {\n    const current = info.current;\n    const version = info.version;\n\n    const isOS = name => () => current === name;\n\n    return {\n      current,\n      version,\n      isWindows: isOS(windows),\n      isiOS: isOS(ios),\n      isAndroid: isOS(android),\n      isMacOS: isOS(macos),\n      isLinux: isOS(linux),\n      isSolaris: isOS(solaris),\n      isFreeBSD: isOS(freebsd),\n      isChromeOS: isOS(chromeos)\n    };\n  };\n\n  const OperatingSystem = {\n    unknown,\n    nu: nu$1,\n    windows: constant(windows),\n    ios: constant(ios),\n    android: constant(android),\n    linux: constant(linux),\n    macos: constant(macos),\n    solaris: constant(solaris),\n    freebsd: constant(freebsd),\n    chromeos: constant(chromeos)\n  };\n\n  const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n    const browsers = PlatformInfo.browsers();\n    const oses = PlatformInfo.oses();\n    const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n    const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n    const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n    return {\n      browser,\n      os,\n      deviceType\n    };\n  };\n\n  const PlatformDetection = {\n    detect: detect$3\n  };\n\n  const mediaMatch = query => window.matchMedia(query).matches;\n\n  let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n\n  const detect$2 = () => platform$4();\n\n  const userAgent = navigator.userAgent;\n  const platform$3 = detect$2();\n  const browser$3 = platform$3.browser;\n  const os$1 = platform$3.os;\n  const deviceType = platform$3.deviceType;\n  const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n  const Env = {\n    transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n    documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n    cacheSuffix: null,\n    container: null,\n    canHaveCSP: !browser$3.isIE(),\n    windowsPhone,\n    browser: {\n      current: browser$3.current,\n      version: browser$3.version,\n      isChromium: browser$3.isChromium,\n      isEdge: browser$3.isEdge,\n      isFirefox: browser$3.isFirefox,\n      isIE: browser$3.isIE,\n      isOpera: browser$3.isOpera,\n      isSafari: browser$3.isSafari\n    },\n    os: {\n      current: os$1.current,\n      version: os$1.version,\n      isAndroid: os$1.isAndroid,\n      isChromeOS: os$1.isChromeOS,\n      isFreeBSD: os$1.isFreeBSD,\n      isiOS: os$1.isiOS,\n      isLinux: os$1.isLinux,\n      isMacOS: os$1.isMacOS,\n      isSolaris: os$1.isSolaris,\n      isWindows: os$1.isWindows\n    },\n    deviceType: {\n      isDesktop: deviceType.isDesktop,\n      isiPad: deviceType.isiPad,\n      isiPhone: deviceType.isiPhone,\n      isPhone: deviceType.isPhone,\n      isTablet: deviceType.isTablet,\n      isTouch: deviceType.isTouch,\n      isWebView: deviceType.isWebView\n    }\n  };\n  const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n\n  const trim$3 = str => {\n    return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n  };\n\n  const is$3 = (obj, type) => {\n    if (!type) {\n      return obj !== undefined;\n    }\n\n    if (type === 'array' && isArray(obj)) {\n      return true;\n    }\n\n    return typeof obj === type;\n  };\n\n  const makeMap$4 = (items, delim, map = {}) => {\n    const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n    let i = resolvedItems.length;\n\n    while (i--) {\n      map[resolvedItems[i]] = {};\n    }\n\n    return map;\n  };\n\n  const hasOwnProperty = has$2;\n\n  const extend$3 = (obj, ...exts) => {\n    for (let i = 0; i < exts.length; i++) {\n      const ext = exts[i];\n\n      for (const name in ext) {\n        if (has$2(ext, name)) {\n          const value = ext[name];\n\n          if (value !== undefined) {\n            obj[name] = value;\n          }\n        }\n      }\n    }\n\n    return obj;\n  };\n\n  const walk$4 = function (o, f, n, s) {\n    s = s || this;\n\n    if (o) {\n      if (n) {\n        o = o[n];\n      }\n\n      each$c(o, (o, i) => {\n        if (f.call(s, o, i, n) === false) {\n          return false;\n        } else {\n          walk$4(o, f, n, s);\n          return true;\n        }\n      });\n    }\n  };\n\n  const resolve$3 = (n, o = window) => {\n    const path = n.split('.');\n\n    for (let i = 0, l = path.length; i < l; i++) {\n      o = o[path[i]];\n\n      if (!o) {\n        break;\n      }\n    }\n\n    return o;\n  };\n\n  const explode$3 = (s, d) => {\n    if (isArray$1(s)) {\n      return s;\n    } else if (s === '') {\n      return [];\n    } else {\n      return map$1(s.split(d || ','), trim$3);\n    }\n  };\n\n  const _addCacheSuffix = url => {\n    const cacheSuffix = Env.cacheSuffix;\n\n    if (cacheSuffix) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n    }\n\n    return url;\n  };\n\n  const Tools = {\n    trim: trim$3,\n    isArray: isArray,\n    is: is$3,\n    toArray: toArray$1,\n    makeMap: makeMap$4,\n    each: each$c,\n    map: map$1,\n    grep: filter$3,\n    inArray: indexOf,\n    hasOwn: hasOwnProperty,\n    extend: extend$3,\n    walk: walk$4,\n    resolve: resolve$3,\n    explode: explode$3,\n    _addCacheSuffix\n  };\n\n  const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n\n  const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n\n  const cat = arr => {\n    const r = [];\n\n    const push = x => {\n      r.push(x);\n    };\n\n    for (let i = 0; i < arr.length; i++) {\n      arr[i].each(push);\n    }\n\n    return r;\n  };\n\n  const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n\n  const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n\n  const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n  const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n  const path = (parts, scope) => {\n    let o = scope !== undefined && scope !== null ? scope : Global;\n\n    for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n      o = o[parts[i]];\n    }\n\n    return o;\n  };\n\n  const resolve$2 = (p, scope) => {\n    const parts = p.split('.');\n    return path(parts, scope);\n  };\n\n  const unsafe = (name, scope) => {\n    return resolve$2(name, scope);\n  };\n\n  const getOrDie = (name, scope) => {\n    const actual = unsafe(name, scope);\n\n    if (actual === undefined || actual === null) {\n      throw new Error(name + ' not available on this browser');\n    }\n\n    return actual;\n  };\n\n  const getPrototypeOf$1 = Object.getPrototypeOf;\n\n  const sandHTMLElement = scope => {\n    return getOrDie('HTMLElement', scope);\n  };\n\n  const isPrototypeOf = x => {\n    const scope = resolve$2('ownerDocument.defaultView', x);\n    return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n  };\n\n  const COMMENT = 8;\n  const DOCUMENT = 9;\n  const DOCUMENT_FRAGMENT = 11;\n  const ELEMENT = 1;\n  const TEXT = 3;\n\n  const name = element => {\n    const r = element.dom.nodeName;\n    return r.toLowerCase();\n  };\n\n  const type$1 = element => element.dom.nodeType;\n\n  const isType = t => element => type$1(element) === t;\n\n  const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n\n  const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n\n  const isElement$7 = isType(ELEMENT);\n  const isText$b = isType(TEXT);\n  const isDocument$2 = isType(DOCUMENT);\n  const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n\n  const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n  const rawSet = (dom, key, value) => {\n    if (isString(value) || isBoolean(value) || isNumber(value)) {\n      dom.setAttribute(key, value + '');\n    } else {\n      console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n      throw new Error('Attribute value was not simple');\n    }\n  };\n\n  const set$3 = (element, key, value) => {\n    rawSet(element.dom, key, value);\n  };\n\n  const setAll$1 = (element, attrs) => {\n    const dom = element.dom;\n    each$d(attrs, (v, k) => {\n      rawSet(dom, k, v);\n    });\n  };\n\n  const get$9 = (element, key) => {\n    const v = element.dom.getAttribute(key);\n    return v === null ? undefined : v;\n  };\n\n  const getOpt = (element, key) => Optional.from(get$9(element, key));\n\n  const has$1 = (element, key) => {\n    const dom = element.dom;\n    return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n  };\n\n  const remove$a = (element, key) => {\n    element.dom.removeAttribute(key);\n  };\n\n  const hasNone = element => {\n    const attrs = element.dom.attributes;\n    return attrs === undefined || attrs === null || attrs.length === 0;\n  };\n\n  const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n\n  const read$4 = (element, attr) => {\n    const value = get$9(element, attr);\n    return value === undefined || value === '' ? [] : value.split(' ');\n  };\n\n  const add$4 = (element, attr, id) => {\n    const old = read$4(element, attr);\n    const nu = old.concat([id]);\n    set$3(element, attr, nu.join(' '));\n    return true;\n  };\n\n  const remove$9 = (element, attr, id) => {\n    const nu = filter$5(read$4(element, attr), v => v !== id);\n\n    if (nu.length > 0) {\n      set$3(element, attr, nu.join(' '));\n    } else {\n      remove$a(element, attr);\n    }\n\n    return false;\n  };\n\n  const supports = element => element.dom.classList !== undefined;\n\n  const get$8 = element => read$4(element, 'class');\n\n  const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n\n  const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n\n  const toggle$2 = (element, clazz) => {\n    if (contains$2(get$8(element), clazz)) {\n      return remove$8(element, clazz);\n    } else {\n      return add$3(element, clazz);\n    }\n  };\n\n  const add$2 = (element, clazz) => {\n    if (supports(element)) {\n      element.dom.classList.add(clazz);\n    } else {\n      add$3(element, clazz);\n    }\n  };\n\n  const cleanClass = element => {\n    const classList = supports(element) ? element.dom.classList : get$8(element);\n\n    if (classList.length === 0) {\n      remove$a(element, 'class');\n    }\n  };\n\n  const remove$7 = (element, clazz) => {\n    if (supports(element)) {\n      const classList = element.dom.classList;\n      classList.remove(clazz);\n    } else {\n      remove$8(element, clazz);\n    }\n\n    cleanClass(element);\n  };\n\n  const toggle$1 = (element, clazz) => {\n    const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n    cleanClass(element);\n    return result;\n  };\n\n  const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n  const fromHtml$1 = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n\n    if (!div.hasChildNodes() || div.childNodes.length > 1) {\n      const message = 'HTML does not have a single root node';\n      console.error(message, html);\n      throw new Error(message);\n    }\n\n    return fromDom$2(div.childNodes[0]);\n  };\n\n  const fromTag = (tag, scope) => {\n    const doc = scope || document;\n    const node = doc.createElement(tag);\n    return fromDom$2(node);\n  };\n\n  const fromText = (text, scope) => {\n    const doc = scope || document;\n    const node = doc.createTextNode(text);\n    return fromDom$2(node);\n  };\n\n  const fromDom$2 = node => {\n    if (node === null || node === undefined) {\n      throw new Error('Node cannot be null or undefined');\n    }\n\n    return {\n      dom: node\n    };\n  };\n\n  const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n\n  const SugarElement = {\n    fromHtml: fromHtml$1,\n    fromTag,\n    fromText,\n    fromDom: fromDom$2,\n    fromPoint: fromPoint$2\n  };\n\n  const toArray = (target, f) => {\n    const r = [];\n\n    const recurse = e => {\n      r.push(e);\n      return f(e);\n    };\n\n    let cur = f(target);\n\n    do {\n      cur = cur.bind(recurse);\n    } while (cur.isSome());\n\n    return r;\n  };\n\n  const is$1 = (element, selector) => {\n    const dom = element.dom;\n\n    if (dom.nodeType !== ELEMENT) {\n      return false;\n    } else {\n      const elem = dom;\n\n      if (elem.matches !== undefined) {\n        return elem.matches(selector);\n      } else if (elem.msMatchesSelector !== undefined) {\n        return elem.msMatchesSelector(selector);\n      } else if (elem.webkitMatchesSelector !== undefined) {\n        return elem.webkitMatchesSelector(selector);\n      } else if (elem.mozMatchesSelector !== undefined) {\n        return elem.mozMatchesSelector(selector);\n      } else {\n        throw new Error('Browser lacks native selectors');\n      }\n    }\n  };\n\n  const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n\n  const all = (selector, scope) => {\n    const base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n  };\n\n  const one = (selector, scope) => {\n    const base = scope === undefined ? document : scope.dom;\n    return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n  };\n\n  const eq = (e1, e2) => e1.dom === e2.dom;\n\n  const contains = (e1, e2) => {\n    const d1 = e1.dom;\n    const d2 = e2.dom;\n    return d1 === d2 ? false : d1.contains(d2);\n  };\n\n  const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n\n  const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n\n  const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n\n  const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n\n  const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n\n  const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n\n  const parents$1 = (element, isRoot) => {\n    const stop = isFunction(isRoot) ? isRoot : never;\n    let dom = element.dom;\n    const ret = [];\n\n    while (dom.parentNode !== null && dom.parentNode !== undefined) {\n      const rawParent = dom.parentNode;\n      const p = SugarElement.fromDom(rawParent);\n      ret.push(p);\n\n      if (stop(p) === true) {\n        break;\n      } else {\n        dom = rawParent;\n      }\n    }\n\n    return ret;\n  };\n\n  const siblings = element => {\n    const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n\n    return parent(element).map(children$1).map(filterSelf).getOr([]);\n  };\n\n  const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n\n  const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n\n  const prevSiblings = element => reverse(toArray(element, prevSibling));\n\n  const nextSiblings = element => toArray(element, nextSibling);\n\n  const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n\n  const child$1 = (element, index) => {\n    const cs = element.dom.childNodes;\n    return Optional.from(cs[index]).map(SugarElement.fromDom);\n  };\n\n  const firstChild = element => child$1(element, 0);\n\n  const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n\n  const childNodesCount = element => element.dom.childNodes.length;\n\n  const hasChildNodes = element => element.dom.hasChildNodes();\n\n  const getHead = doc => {\n    const b = doc.dom.head;\n\n    if (b === null || b === undefined) {\n      throw new Error('Head is not available yet');\n    }\n\n    return SugarElement.fromDom(b);\n  };\n\n  const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n\n  const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n  const isSupported$1 = constant(supported);\n  const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n\n  const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n\n  const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n\n  const getShadowRoot = e => {\n    const r = getRootNode(e);\n    return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n  };\n\n  const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n\n  const getOriginalEventTarget = event => {\n    if (isSupported$1() && isNonNullable(event.target)) {\n      const el = SugarElement.fromDom(event.target);\n\n      if (isElement$7(el) && isOpenShadowHost(el)) {\n        if (event.composed && event.composedPath) {\n          const composedPath = event.composedPath();\n\n          if (composedPath) {\n            return head(composedPath);\n          }\n        }\n      }\n    }\n\n    return Optional.from(event.target);\n  };\n\n  const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n  const inBody = element => {\n    const dom = isText$b(element) ? element.dom.parentNode : element.dom;\n\n    if (dom === undefined || dom === null || dom.ownerDocument === null) {\n      return false;\n    }\n\n    const doc = dom.ownerDocument;\n    return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n  };\n\n  var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n    if (is(scope, a)) {\n      return Optional.some(scope);\n    } else if (isFunction(isRoot) && isRoot(scope)) {\n      return Optional.none();\n    } else {\n      return ancestor(scope, a, isRoot);\n    }\n  };\n\n  const ancestor$4 = (scope, predicate, isRoot) => {\n    let element = scope.dom;\n    const stop = isFunction(isRoot) ? isRoot : never;\n\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n\n      if (predicate(el)) {\n        return Optional.some(el);\n      } else if (stop(el)) {\n        break;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const closest$4 = (scope, predicate, isRoot) => {\n    const is = (s, test) => test(s);\n\n    return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n  };\n\n  const sibling$1 = (scope, predicate) => {\n    const element = scope.dom;\n\n    if (!element.parentNode) {\n      return Optional.none();\n    }\n\n    return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n  };\n\n  const child = (scope, predicate) => {\n    const pred = node => predicate(SugarElement.fromDom(node));\n\n    const result = find$2(scope.dom.childNodes, pred);\n    return result.map(SugarElement.fromDom);\n  };\n\n  const descendant$2 = (scope, predicate) => {\n    const descend = node => {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        const child = SugarElement.fromDom(node.childNodes[i]);\n\n        if (predicate(child)) {\n          return Optional.some(child);\n        }\n\n        const res = descend(node.childNodes[i]);\n\n        if (res.isSome()) {\n          return res;\n        }\n      }\n\n      return Optional.none();\n    };\n\n    return descend(scope.dom);\n  };\n\n  const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n\n  const descendant$1 = (scope, selector) => one(selector, scope);\n\n  const closest$3 = (scope, selector, isRoot) => {\n    const is = (element, selector) => is$1(element, selector);\n\n    return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n  };\n\n  const closest$2 = target => closest$3(target, '[contenteditable]');\n\n  const isEditable$2 = (element, assumeEditable = false) => {\n    if (inBody(element)) {\n      return element.dom.isContentEditable;\n    } else {\n      return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n    }\n  };\n\n  const getRaw$1 = element => element.dom.contentEditable;\n\n  const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n  const internalSet = (dom, property, value) => {\n    if (!isString(value)) {\n      console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n      throw new Error('CSS value must be a string: ' + value);\n    }\n\n    if (isSupported(dom)) {\n      dom.style.setProperty(property, value);\n    }\n  };\n\n  const internalRemove = (dom, property) => {\n    if (isSupported(dom)) {\n      dom.style.removeProperty(property);\n    }\n  };\n\n  const set$2 = (element, property, value) => {\n    const dom = element.dom;\n    internalSet(dom, property, value);\n  };\n\n  const setAll = (element, css) => {\n    const dom = element.dom;\n    each$d(css, (v, k) => {\n      internalSet(dom, k, v);\n    });\n  };\n\n  const get$7 = (element, property) => {\n    const dom = element.dom;\n    const styles = window.getComputedStyle(dom);\n    const r = styles.getPropertyValue(property);\n    return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n  };\n\n  const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n\n  const getRaw = (element, property) => {\n    const dom = element.dom;\n    const raw = getUnsafeProperty(dom, property);\n    return Optional.from(raw).filter(r => r.length > 0);\n  };\n\n  const getAllRaw = element => {\n    const css = {};\n    const dom = element.dom;\n\n    if (isSupported(dom)) {\n      for (let i = 0; i < dom.style.length; i++) {\n        const ruleName = dom.style.item(i);\n        css[ruleName] = dom.style[ruleName];\n      }\n    }\n\n    return css;\n  };\n\n  const remove$6 = (element, property) => {\n    const dom = element.dom;\n    internalRemove(dom, property);\n\n    if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n      remove$a(element, 'style');\n    }\n  };\n\n  const reflow = e => e.dom.offsetWidth;\n\n  const before$3 = (marker, element) => {\n    const parent$1 = parent(marker);\n    parent$1.each(v => {\n      v.dom.insertBefore(element.dom, marker.dom);\n    });\n  };\n\n  const after$4 = (marker, element) => {\n    const sibling = nextSibling(marker);\n    sibling.fold(() => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        append$1(v, element);\n      });\n    }, v => {\n      before$3(v, element);\n    });\n  };\n\n  const prepend = (parent, element) => {\n    const firstChild$1 = firstChild(parent);\n    firstChild$1.fold(() => {\n      append$1(parent, element);\n    }, v => {\n      parent.dom.insertBefore(element.dom, v.dom);\n    });\n  };\n\n  const append$1 = (parent, element) => {\n    parent.dom.appendChild(element.dom);\n  };\n\n  const wrap$2 = (element, wrapper) => {\n    before$3(element, wrapper);\n    append$1(wrapper, element);\n  };\n\n  const after$3 = (marker, elements) => {\n    each$e(elements, (x, i) => {\n      const e = i === 0 ? marker : elements[i - 1];\n      after$4(e, x);\n    });\n  };\n\n  const append = (parent, elements) => {\n    each$e(elements, x => {\n      append$1(parent, x);\n    });\n  };\n\n  const empty = element => {\n    element.dom.textContent = '';\n    each$e(children$1(element), rogue => {\n      remove$5(rogue);\n    });\n  };\n\n  const remove$5 = element => {\n    const dom = element.dom;\n\n    if (dom.parentNode !== null) {\n      dom.parentNode.removeChild(dom);\n    }\n  };\n\n  const unwrap = wrapper => {\n    const children = children$1(wrapper);\n\n    if (children.length > 0) {\n      after$3(wrapper, children);\n    }\n\n    remove$5(wrapper);\n  };\n\n  const fromHtml = (html, scope) => {\n    const doc = scope || document;\n    const div = doc.createElement('div');\n    div.innerHTML = html;\n    return children$1(SugarElement.fromDom(div));\n  };\n\n  const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n  const get$6 = element => element.dom.innerHTML;\n\n  const set$1 = (element, content) => {\n    const owner = owner$1(element);\n    const docDom = owner.dom;\n    const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n    const contentElements = fromHtml(content, docDom);\n    append(fragment, contentElements);\n    empty(element);\n    append$1(element, fragment);\n  };\n\n  const getOuter = element => {\n    const container = SugarElement.fromTag('div');\n    const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n    append$1(container, clone);\n    return get$6(container);\n  };\n\n  const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n    target,\n    x,\n    y,\n    stop,\n    prevent,\n    kill,\n    raw\n  });\n\n  const fromRawEvent = rawEvent => {\n    const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n\n    const stop = () => rawEvent.stopPropagation();\n\n    const prevent = () => rawEvent.preventDefault();\n\n    const kill = compose(prevent, stop);\n    return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n  };\n\n  const handle$1 = (filter, handler) => rawEvent => {\n    if (filter(rawEvent)) {\n      handler(fromRawEvent(rawEvent));\n    }\n  };\n\n  const binder = (element, event, filter, handler, useCapture) => {\n    const wrapped = handle$1(filter, handler);\n    element.dom.addEventListener(event, wrapped, useCapture);\n    return {\n      unbind: curry(unbind, element, event, wrapped, useCapture)\n    };\n  };\n\n  const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n\n  const unbind = (element, event, handler, useCapture) => {\n    element.dom.removeEventListener(event, handler, useCapture);\n  };\n\n  const r = (left, top) => {\n    const translate = (x, y) => r(left + x, top + y);\n\n    return {\n      left,\n      top,\n      translate\n    };\n  };\n\n  const SugarPosition = r;\n\n  const boxPosition = dom => {\n    const box = dom.getBoundingClientRect();\n    return SugarPosition(box.left, box.top);\n  };\n\n  const firstDefinedOrZero = (a, b) => {\n    if (a !== undefined) {\n      return a;\n    } else {\n      return b !== undefined ? b : 0;\n    }\n  };\n\n  const absolute = element => {\n    const doc = element.dom.ownerDocument;\n    const body = doc.body;\n    const win = doc.defaultView;\n    const html = doc.documentElement;\n\n    if (body === element.dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n\n    const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n    const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n    const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n    const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n    return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n  };\n\n  const viewport = element => {\n    const dom = element.dom;\n    const doc = dom.ownerDocument;\n    const body = doc.body;\n\n    if (body === dom) {\n      return SugarPosition(body.offsetLeft, body.offsetTop);\n    }\n\n    if (!inBody(element)) {\n      return SugarPosition(0, 0);\n    }\n\n    return boxPosition(dom);\n  };\n\n  const get$5 = _DOC => {\n    const doc = _DOC !== undefined ? _DOC.dom : document;\n    const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n    const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n    return SugarPosition(x, y);\n  };\n\n  const to = (x, y, _DOC) => {\n    const doc = _DOC !== undefined ? _DOC.dom : document;\n    const win = doc.defaultView;\n\n    if (win) {\n      win.scrollTo(x, y);\n    }\n  };\n\n  const intoView = (element, alignToTop) => {\n    const isSafari = detect$2().browser.isSafari();\n\n    if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n      element.dom.scrollIntoViewIfNeeded(false);\n    } else {\n      element.dom.scrollIntoView(alignToTop);\n    }\n  };\n\n  const get$4 = _win => {\n    const win = _win === undefined ? window : _win;\n\n    if (detect$2().browser.isFirefox()) {\n      return Optional.none();\n    } else {\n      return Optional.from(win.visualViewport);\n    }\n  };\n\n  const bounds = (x, y, width, height) => ({\n    x,\n    y,\n    width,\n    height,\n    right: x + width,\n    bottom: y + height\n  });\n\n  const getBounds = _win => {\n    const win = _win === undefined ? window : _win;\n    const doc = win.document;\n    const scroll = get$5(SugarElement.fromDom(doc));\n    return get$4(win).fold(() => {\n      const html = win.document.documentElement;\n      const width = html.clientWidth;\n      const height = html.clientHeight;\n      return bounds(scroll.left, scroll.top, width, height);\n    }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n  };\n\n  const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n\n  const descendants$1 = (scope, predicate) => {\n    let result = [];\n    each$e(children$1(scope), x => {\n      if (predicate(x)) {\n        result = result.concat([x]);\n      }\n\n      result = result.concat(descendants$1(x, predicate));\n    });\n    return result;\n  };\n\n  const descendants = (scope, selector) => all(selector, scope);\n\n  const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n\n  class DomTreeWalker {\n    constructor(startNode, rootNode) {\n      this.node = startNode;\n      this.rootNode = rootNode;\n      this.current = this.current.bind(this);\n      this.next = this.next.bind(this);\n      this.prev = this.prev.bind(this);\n      this.prev2 = this.prev2.bind(this);\n    }\n\n    current() {\n      return this.node;\n    }\n\n    next(shallow) {\n      this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n      return this.node;\n    }\n\n    prev(shallow) {\n      this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n      return this.node;\n    }\n\n    prev2(shallow) {\n      this.node = this.findPreviousNode(this.node, shallow);\n      return this.node;\n    }\n\n    findSibling(node, startName, siblingName, shallow) {\n      if (node) {\n        if (!shallow && node[startName]) {\n          return node[startName];\n        }\n\n        if (node !== this.rootNode) {\n          let sibling = node[siblingName];\n\n          if (sibling) {\n            return sibling;\n          }\n\n          for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n            sibling = parent[siblingName];\n\n            if (sibling) {\n              return sibling;\n            }\n          }\n        }\n      }\n\n      return undefined;\n    }\n\n    findPreviousNode(node, shallow) {\n      if (node) {\n        const sibling = node.previousSibling;\n\n        if (this.rootNode && sibling === this.rootNode) {\n          return;\n        }\n\n        if (sibling) {\n          if (!shallow) {\n            for (let child = sibling.lastChild; child; child = child.lastChild) {\n              if (!child.lastChild) {\n                return child;\n              }\n            }\n          }\n\n          return sibling;\n        }\n\n        const parent = node.parentNode;\n\n        if (parent && parent !== this.rootNode) {\n          return parent;\n        }\n      }\n\n      return undefined;\n    }\n\n  }\n\n  const isNodeType = type => {\n    return node => {\n      return !!node && node.nodeType === type;\n    };\n  };\n\n  const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n\n  const isElement$6 = isNodeType(1);\n\n  const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n\n  const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n\n  const matchNodeName = name => {\n    const lowerCasedName = name.toLowerCase();\n    return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n  };\n\n  const matchNodeNames = names => {\n    const lowerCasedNames = names.map(s => s.toLowerCase());\n    return node => {\n      if (node && node.nodeName) {\n        const nodeName = node.nodeName.toLowerCase();\n        return contains$2(lowerCasedNames, nodeName);\n      }\n\n      return false;\n    };\n  };\n\n  const matchStyleValues = (name, values) => {\n    const items = values.toLowerCase().split(' ');\n    return node => {\n      if (isElement$6(node)) {\n        const win = node.ownerDocument.defaultView;\n\n        if (win) {\n          for (let i = 0; i < items.length; i++) {\n            const computed = win.getComputedStyle(node, null);\n            const cssValue = computed ? computed.getPropertyValue(name) : null;\n\n            if (cssValue === items[i]) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    };\n  };\n\n  const hasAttribute = attrName => {\n    return node => {\n      return isElement$6(node) && node.hasAttribute(attrName);\n    };\n  };\n\n  const hasAttributeValue = (attrName, attrValue) => {\n    return node => {\n      return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n    };\n  };\n\n  const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n\n  const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n\n  const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n\n  const hasContentEditableState = value => {\n    return node => {\n      if (isHTMLElement(node)) {\n        if (node.contentEditable === value) {\n          return true;\n        }\n\n        if (node.getAttribute('data-mce-contenteditable') === value) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  };\n\n  const isTextareaOrInput = matchNodeNames(['textarea', 'input']);\n  const isText$a = isNodeType(3);\n  const isCData = isNodeType(4);\n  const isPi = isNodeType(7);\n  const isComment = isNodeType(8);\n  const isDocument$1 = isNodeType(9);\n  const isDocumentFragment = isNodeType(11);\n  const isBr$6 = matchNodeName('br');\n  const isImg = matchNodeName('img');\n  const isContentEditableTrue$3 = hasContentEditableState('true');\n  const isContentEditableFalse$b = hasContentEditableState('false');\n  const isTableCell$3 = matchNodeNames(['td', 'th']);\n  const isTableCellOrCaption = matchNodeNames(['td', 'th', 'caption']);\n  const isMedia$2 = matchNodeNames(['video', 'audio', 'object', 'embed']);\n  const isListItem$2 = matchNodeName('li');\n  const isDetails = matchNodeName('details');\n  const isSummary$1 = matchNodeName('summary');\n  const zeroWidth = '\\uFEFF';\n  const nbsp = '\\xA0';\n\n  const isZwsp$2 = char => char === zeroWidth;\n\n  const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n  const NodeValue = (is, name) => {\n    const get = element => {\n      if (!is(element)) {\n        throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n      }\n\n      return getOption(element).getOr('');\n    };\n\n    const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n\n    const set = (element, value) => {\n      if (!is(element)) {\n        throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n      }\n\n      element.dom.nodeValue = value;\n    };\n\n    return {\n      get,\n      getOption,\n      set\n    };\n  };\n\n  const api$1 = NodeValue(isText$b, 'text');\n\n  const get$3 = element => api$1.get(element);\n\n  const getOption = element => api$1.getOption(element);\n\n  const set = (element, value) => api$1.set(element, value);\n\n  const tableCells = ['td', 'th'];\n  const tableSections = ['thead', 'tbody', 'tfoot'];\n  const textBlocks = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'p', 'div', 'address', 'pre', 'form', 'blockquote', 'center', 'dir', 'fieldset', 'header', 'footer', 'article', 'section', 'hgroup', 'aside', 'nav', 'figure'];\n  const listItems$1 = ['li', 'dd', 'dt'];\n  const lists = ['ul', 'ol', 'dl'];\n  const wsElements = ['pre', 'script', 'textarea', 'style'];\n\n  const lazyLookup = items => {\n    let lookup;\n    return node => {\n      lookup = lookup ? lookup : mapToObject(items, always);\n      return has$2(lookup, name(node));\n    };\n  };\n\n  const isTable$1 = node => name(node) === 'table';\n\n  const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n\n  const isTextBlock$2 = lazyLookup(textBlocks);\n  const isList = lazyLookup(lists);\n  const isListItem$1 = lazyLookup(listItems$1);\n  const isTableSection = lazyLookup(tableSections);\n  const isTableCell$2 = lazyLookup(tableCells);\n  const isWsPreserveElement = lazyLookup(wsElements);\n\n  const getLastChildren$1 = elm => {\n    const children = [];\n    let rawNode = elm.dom;\n\n    while (rawNode) {\n      children.push(SugarElement.fromDom(rawNode));\n      rawNode = rawNode.lastChild;\n    }\n\n    return children;\n  };\n\n  const removeTrailingBr = elm => {\n    const allBrs = descendants(elm, 'br');\n    const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n\n    if (allBrs.length === brs.length) {\n      each$e(brs, remove$5);\n    }\n  };\n\n  const createPaddingBr = () => {\n    const br = SugarElement.fromTag('br');\n    set$3(br, 'data-mce-bogus', '1');\n    return br;\n  };\n\n  const fillWithPaddingBr = elm => {\n    empty(elm);\n    append$1(elm, createPaddingBr());\n  };\n\n  const trimBlockTrailingBr = (elm, schema) => {\n    lastChild(elm).each(lastChild => {\n      prevSibling(lastChild).each(lastChildPrevSibling => {\n        if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n          remove$5(lastChild);\n        }\n      });\n    });\n  };\n\n  const ZWSP$1 = zeroWidth;\n  const isZwsp$1 = isZwsp$2;\n  const trim$2 = removeZwsp;\n\n  const insert$5 = editor => editor.insertContent(ZWSP$1, {\n    preserve_zwsp: true\n  });\n\n  const isElement$5 = isElement$6;\n  const isText$9 = isText$a;\n\n  const isCaretContainerBlock$1 = node => {\n    if (isText$9(node)) {\n      node = node.parentNode;\n    }\n\n    return isElement$5(node) && node.hasAttribute('data-mce-caret');\n  };\n\n  const isCaretContainerInline = node => isText$9(node) && isZwsp$1(node.data);\n\n  const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n\n  const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n\n  const insertInline$1 = (node, before) => {\n    var _a;\n\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const textNode = doc.createTextNode(ZWSP$1);\n    const parentNode = node.parentNode;\n\n    if (!before) {\n      const sibling = node.nextSibling;\n\n      if (isText$9(sibling)) {\n        if (isCaretContainer$2(sibling)) {\n          return sibling;\n        }\n\n        if (startsWithCaretContainer$1(sibling)) {\n          sibling.splitText(1);\n          return sibling;\n        }\n      }\n\n      if (node.nextSibling) {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n      }\n    } else {\n      const sibling = node.previousSibling;\n\n      if (isText$9(sibling)) {\n        if (isCaretContainer$2(sibling)) {\n          return sibling;\n        }\n\n        if (endsWithCaretContainer$1(sibling)) {\n          return sibling.splitText(sibling.data.length - 1);\n        }\n      }\n\n      parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n    }\n\n    return textNode;\n  };\n\n  const isBeforeInline = pos => {\n    const container = pos.container();\n\n    if (!isText$a(container)) {\n      return false;\n    }\n\n    return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n  };\n\n  const isAfterInline = pos => {\n    const container = pos.container();\n\n    if (!isText$a(container)) {\n      return false;\n    }\n\n    return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n  };\n\n  const insertBlock = (blockName, node, before) => {\n    var _a;\n\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const blockNode = doc.createElement(blockName);\n    blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n    blockNode.setAttribute('data-mce-bogus', 'all');\n    blockNode.appendChild(createPaddingBr().dom);\n    const parentNode = node.parentNode;\n\n    if (!before) {\n      if (node.nextSibling) {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n      }\n    } else {\n      parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n    }\n\n    return blockNode;\n  };\n\n  const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n\n  const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n\n  const trimBogusBr = elm => {\n    var _a;\n\n    const brs = elm.getElementsByTagName('br');\n    const lastBr = brs[brs.length - 1];\n\n    if (isBogus$2(lastBr)) {\n      (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n    }\n  };\n\n  const showCaretContainerBlock = caretContainer => {\n    if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n      trimBogusBr(caretContainer);\n      caretContainer.removeAttribute('data-mce-caret');\n      caretContainer.removeAttribute('data-mce-bogus');\n      caretContainer.removeAttribute('style');\n      caretContainer.removeAttribute('data-mce-style');\n      caretContainer.removeAttribute('_moz_abspos');\n      return caretContainer;\n    }\n\n    return null;\n  };\n\n  const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n  const isContentEditableTrue$2 = isContentEditableTrue$3;\n  const isContentEditableFalse$a = isContentEditableFalse$b;\n  const isBr$4 = isBr$6;\n  const isText$8 = isText$a;\n  const isInvalidTextElement = matchNodeNames(['script', 'style', 'textarea']);\n  const isAtomicInline = matchNodeNames(['img', 'input', 'textarea', 'hr', 'iframe', 'video', 'audio', 'object', 'embed']);\n  const isTable = matchNodeNames(['table']);\n  const isCaretContainer$1 = isCaretContainer$2;\n\n  const isCaretCandidate$3 = node => {\n    if (isCaretContainer$1(node)) {\n      return false;\n    }\n\n    if (isText$8(node)) {\n      return !isInvalidTextElement(node.parentNode);\n    }\n\n    return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n  };\n\n  const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n\n  const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n\n  const isInEditable = (node, root) => {\n    for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n      if (isNonUiContentEditableFalse(tempNode)) {\n        return false;\n      }\n\n      if (isContentEditableTrue$2(tempNode)) {\n        return true;\n      }\n    }\n\n    return true;\n  };\n\n  const isAtomicContentEditableFalse = node => {\n    if (!isNonUiContentEditableFalse(node)) {\n      return false;\n    }\n\n    return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n      return result || isContentEditableTrue$2(elm);\n    }, false);\n  };\n\n  const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n\n  const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n  const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n\n  const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n\n  const isZwsp = text => {\n    for (const c of text) {\n      if (!isZwsp$2(c)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n\n  const isNewLineChar = c => c === '\\n' || c === '\\r';\n\n  const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n\n  const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n    const tabSpace = repeat(' ', tabSpaces);\n    const normalizedText = text.replace(/\\t/g, tabSpace);\n    const result = foldl(normalizedText, (acc, c) => {\n      if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n        if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n          return {\n            pcIsSpace: false,\n            str: acc.str + nbsp\n          };\n        } else {\n          return {\n            pcIsSpace: true,\n            str: acc.str + ' '\n          };\n        }\n      } else {\n        return {\n          pcIsSpace: isNewLineChar(c),\n          str: acc.str + c\n        };\n      }\n    }, {\n      pcIsSpace: false,\n      str: ''\n    });\n    return result.str;\n  };\n\n  const hasWhitespacePreserveParent = (node, rootNode) => {\n    const rootElement = SugarElement.fromDom(rootNode);\n    const startNode = SugarElement.fromDom(node);\n    return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));\n  };\n\n  const isWhitespace$1 = (node, rootNode) => {\n    return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);\n  };\n\n  const isNamedAnchor = node => {\n    return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n  };\n\n  const isContent$1 = (node, rootNode) => {\n    return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);\n  };\n\n  const isBookmark = hasAttribute('data-mce-bookmark');\n  const isBogus$1 = hasAttribute('data-mce-bogus');\n  const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n\n  const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n\n  const isEmptyNode = (targetNode, skipBogus) => {\n    let brCount = 0;\n\n    if (isContent$1(targetNode, targetNode)) {\n      return false;\n    } else {\n      let node = targetNode.firstChild;\n\n      if (!node) {\n        return true;\n      }\n\n      const walker = new DomTreeWalker(node, targetNode);\n\n      do {\n        if (skipBogus) {\n          if (isBogusAll(node)) {\n            node = walker.next(true);\n            continue;\n          }\n\n          if (isBogus$1(node)) {\n            node = walker.next();\n            continue;\n          }\n        }\n\n        if (isContentEditableTrue$3(node) && hasNonEditableParent(node)) {\n          return false;\n        }\n\n        if (isBr$6(node)) {\n          brCount++;\n          node = walker.next();\n          continue;\n        }\n\n        if (isContent$1(node, targetNode)) {\n          return false;\n        }\n\n        node = walker.next();\n      } while (node);\n\n      return brCount <= 1;\n    }\n  };\n\n  const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\n\n  const isNonHtmlElementRootName = name => name.toLowerCase() === 'svg';\n\n  const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n\n  const toScopeType = node => (node === null || node === void 0 ? void 0 : node.nodeName) === 'svg' ? 'svg' : 'html';\n\n  const namespaceElements = ['svg'];\n\n  const createNamespaceTracker = () => {\n    let scopes = [];\n\n    const peek = () => scopes[scopes.length - 1];\n\n    const track = node => {\n      if (isNonHtmlElementRoot(node)) {\n        scopes.push(node);\n      }\n\n      let currentScope = peek();\n\n      if (currentScope && !currentScope.contains(node)) {\n        scopes.pop();\n        currentScope = peek();\n      }\n\n      return toScopeType(currentScope);\n    };\n\n    const current = () => toScopeType(peek());\n\n    const reset = () => {\n      scopes = [];\n    };\n\n    return {\n      track,\n      current,\n      reset\n    };\n  };\n\n  const transparentBlockAttr = 'data-mce-block';\n\n  const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n\n  const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n    return `${name}:` + map$3(namespaceElements, ns => `not(${ns} ${name})`).join(':');\n  }).join(',');\n\n  const updateTransparent = (blocksSelector, transparent) => {\n    if (isNonNullable(transparent.querySelector(blocksSelector))) {\n      transparent.setAttribute(transparentBlockAttr, 'true');\n\n      if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n        transparent.removeAttribute('data-mce-selected');\n      }\n\n      return true;\n    } else {\n      transparent.removeAttribute(transparentBlockAttr);\n      return false;\n    }\n  };\n\n  const updateBlockStateOnChildren = (schema, scope) => {\n    const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n    const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n    return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n  };\n\n  const trimEdge = (el, leftSide) => {\n    var _a;\n\n    const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n\n    for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n      if (isEmpty$2(SugarElement.fromDom(child))) {\n        (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n        return;\n      }\n    }\n  };\n\n  const split$2 = (parentElm, splitElm) => {\n    const range = document.createRange();\n    const parentNode = parentElm.parentNode;\n\n    if (parentNode) {\n      range.setStartBefore(parentElm);\n      range.setEndBefore(splitElm);\n      const beforeFragment = range.extractContents();\n      trimEdge(beforeFragment, true);\n      range.setStartAfter(splitElm);\n      range.setEndAfter(parentElm);\n      const afterFragment = range.extractContents();\n      trimEdge(afterFragment, false);\n\n      if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {\n        parentNode.insertBefore(beforeFragment, parentElm);\n      }\n\n      if (!isEmpty$2(SugarElement.fromDom(splitElm))) {\n        parentNode.insertBefore(splitElm, parentElm);\n      }\n\n      if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {\n        parentNode.insertBefore(afterFragment, parentElm);\n      }\n\n      parentNode.removeChild(parentElm);\n    }\n  };\n\n  const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n    const blocksElements = schema.getBlockElements();\n    const rootNode = SugarElement.fromDom(scope);\n\n    const isBlock = el => name(el) in blocksElements;\n\n    const isRoot = el => eq(el, rootNode);\n\n    each$e(fromDom$1(transparentBlocks), transparentBlock => {\n      ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n        const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n\n        if (invalidChildren.length > 0) {\n          const stateScope = parentElement(parentBlock);\n          each$e(invalidChildren, child => {\n            ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n              split$2(parentBlock.dom, child.dom);\n            });\n          });\n          stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n        }\n      });\n    });\n  };\n\n  const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n    each$e([...transparentBlocks, ...(isTransparentBlock(schema, scope) ? [scope] : [])], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n      if (isTransparentInline(schema, elm.dom)) {\n        unwrap(elm);\n      }\n    }));\n  };\n\n  const updateChildren = (schema, scope) => {\n    const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n    splitInvalidChildren(schema, scope, transparentBlocks);\n    unwrapInvalidChildren(schema, scope, transparentBlocks);\n  };\n\n  const updateElement = (schema, target) => {\n    if (isTransparentElement(schema, target)) {\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      updateTransparent(blocksSelector, target);\n    }\n  };\n\n  const updateCaret = (schema, root, caretParent) => {\n    const isRoot = el => eq(el, SugarElement.fromDom(root));\n\n    const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n    get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n  };\n\n  const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n\n  const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n\n  const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n\n  const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n\n  const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n\n  const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n\n  const browser$2 = detect$2().browser;\n\n  const firstElement = nodes => find$2(nodes, isElement$7);\n\n  const getTableCaptionDeltaY = elm => {\n    if (browser$2.isFirefox() && name(elm) === 'table') {\n      return firstElement(children$1(elm)).filter(elm => {\n        return name(elm) === 'caption';\n      }).bind(caption => {\n        return firstElement(nextSiblings(caption)).map(body => {\n          const bodyTop = body.dom.offsetTop;\n          const captionTop = caption.dom.offsetTop;\n          const captionHeight = caption.dom.offsetHeight;\n          return bodyTop <= captionTop ? -captionHeight : 0;\n        });\n      }).getOr(0);\n    } else {\n      return 0;\n    }\n  };\n\n  const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n\n  const getPos = (body, elm, rootElm) => {\n    let x = 0,\n        y = 0;\n    const doc = body.ownerDocument;\n    rootElm = rootElm ? rootElm : body;\n\n    if (elm) {\n      if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n        const pos = elm.getBoundingClientRect();\n        x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n        y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n        return {\n          x,\n          y\n        };\n      }\n\n      let offsetParent = elm;\n\n      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n        const castOffsetParent = offsetParent;\n        x += castOffsetParent.offsetLeft || 0;\n        y += castOffsetParent.offsetTop || 0;\n        offsetParent = castOffsetParent.offsetParent;\n      }\n\n      offsetParent = elm.parentNode;\n\n      while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n        x -= offsetParent.scrollLeft || 0;\n        y -= offsetParent.scrollTop || 0;\n        offsetParent = offsetParent.parentNode;\n      }\n\n      y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n    }\n\n    return {\n      x,\n      y\n    };\n  };\n\n  const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n    let idCount = 0;\n    const loadedStates = {};\n    const edos = SugarElement.fromDom(documentOrShadowRoot);\n    const doc = documentOrOwner(edos);\n\n    const _setReferrerPolicy = referrerPolicy => {\n      settings.referrerPolicy = referrerPolicy;\n    };\n\n    const _setContentCssCors = contentCssCors => {\n      settings.contentCssCors = contentCssCors;\n    };\n\n    const addStyle = element => {\n      append$1(getStyleContainer(edos), element);\n    };\n\n    const removeStyle = id => {\n      const styleContainer = getStyleContainer(edos);\n      descendant$1(styleContainer, '#' + id).each(remove$5);\n    };\n\n    const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n      id: 'mce-u' + idCount++,\n      passed: [],\n      failed: [],\n      count: 0\n    }));\n\n    const load = url => new Promise((success, failure) => {\n      let link;\n\n      const urlWithSuffix = Tools._addCacheSuffix(url);\n\n      const state = getOrCreateState(urlWithSuffix);\n      loadedStates[urlWithSuffix] = state;\n      state.count++;\n\n      const resolve = (callbacks, status) => {\n        each$e(callbacks, call);\n        state.status = status;\n        state.passed = [];\n        state.failed = [];\n\n        if (link) {\n          link.onload = null;\n          link.onerror = null;\n          link = null;\n        }\n      };\n\n      const passed = () => resolve(state.passed, 2);\n\n      const failed = () => resolve(state.failed, 3);\n\n      if (success) {\n        state.passed.push(success);\n      }\n\n      if (failure) {\n        state.failed.push(failure);\n      }\n\n      if (state.status === 1) {\n        return;\n      }\n\n      if (state.status === 2) {\n        passed();\n        return;\n      }\n\n      if (state.status === 3) {\n        failed();\n        return;\n      }\n\n      state.status = 1;\n      const linkElem = SugarElement.fromTag('link', doc.dom);\n      setAll$1(linkElem, {\n        rel: 'stylesheet',\n        type: 'text/css',\n        id: state.id\n      });\n\n      if (settings.contentCssCors) {\n        set$3(linkElem, 'crossOrigin', 'anonymous');\n      }\n\n      if (settings.referrerPolicy) {\n        set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n      }\n\n      link = linkElem.dom;\n      link.onload = passed;\n      link.onerror = failed;\n      addStyle(linkElem);\n      set$3(linkElem, 'href', urlWithSuffix);\n    });\n\n    const loadRawCss = (key, css) => {\n      const state = getOrCreateState(key);\n      loadedStates[key] = state;\n      state.count++;\n      const styleElem = SugarElement.fromTag('style', doc.dom);\n      setAll$1(styleElem, {\n        rel: 'stylesheet',\n        type: 'text/css',\n        id: state.id\n      });\n      styleElem.dom.innerHTML = css;\n      addStyle(styleElem);\n    };\n\n    const loadAll = urls => {\n      const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n      return loadedUrls.then(results => {\n        const parts = partition$2(results, r => r.status === 'fulfilled');\n\n        if (parts.fail.length > 0) {\n          return Promise.reject(map$3(parts.fail, result => result.reason));\n        } else {\n          return map$3(parts.pass, result => result.value);\n        }\n      });\n    };\n\n    const unload = url => {\n      const urlWithSuffix = Tools._addCacheSuffix(url);\n\n      get$a(loadedStates, urlWithSuffix).each(state => {\n        const count = --state.count;\n\n        if (count === 0) {\n          delete loadedStates[urlWithSuffix];\n          removeStyle(state.id);\n        }\n      });\n    };\n\n    const unloadRawCss = key => {\n      get$a(loadedStates, key).each(state => {\n        const count = --state.count;\n\n        if (count === 0) {\n          delete loadedStates[key];\n          removeStyle(state.id);\n        }\n      });\n    };\n\n    const unloadAll = urls => {\n      each$e(urls, url => {\n        unload(url);\n      });\n    };\n\n    return {\n      load,\n      loadRawCss,\n      loadAll,\n      unload,\n      unloadRawCss,\n      unloadAll,\n      _setReferrerPolicy,\n      _setContentCssCors\n    };\n  };\n\n  const create$d = () => {\n    const map = new WeakMap();\n\n    const forElement = (referenceElement, settings) => {\n      const root = getRootNode(referenceElement);\n      const rootDom = root.dom;\n      return Optional.from(map.get(rootDom)).getOrThunk(() => {\n        const sl = StyleSheetLoader(rootDom, settings);\n        map.set(rootDom, sl);\n        return sl;\n      });\n    };\n\n    return {\n      forElement\n    };\n  };\n\n  const instance = create$d();\n\n  const isSpan = node => node.nodeName.toLowerCase() === 'span';\n\n  const isInlineContent = (node, root, schema) => isNonNullable(node) && (isContent$1(node, root) || schema.isInline(node.nodeName.toLowerCase()));\n\n  const surroundedByInlineContent = (node, root, schema) => {\n    const prev = new DomTreeWalker(node, root).prev(false);\n    const next = new DomTreeWalker(node, root).next(false);\n    const prevIsInline = isUndefined(prev) || isInlineContent(prev, root, schema);\n    const nextIsInline = isUndefined(next) || isInlineContent(next, root, schema);\n    return prevIsInline && nextIsInline;\n  };\n\n  const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n\n  const isKeepTextNode = (node, root, schema) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n\n  const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n\n  const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n\n  const trimNode = (dom, node, schema, root) => {\n    var _a;\n\n    const rootNode = root || node;\n\n    if (isElement$6(node) && isBookmarkNode$2(node)) {\n      return node;\n    }\n\n    const children = node.childNodes;\n\n    for (let i = children.length - 1; i >= 0; i--) {\n      trimNode(dom, children[i], schema, rootNode);\n    }\n\n    if (isElement$6(node)) {\n      const currentChildren = node.childNodes;\n\n      if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n      }\n    }\n\n    if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n      dom.remove(node);\n    }\n\n    return node;\n  };\n\n  const makeMap$3 = Tools.makeMap;\n  const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  const rawCharsRegExp = /[<>&\\\"\\']/g;\n  const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n  const asciiMap = {\n    128: '\\u20AC',\n    130: '\\u201A',\n    131: '\\u0192',\n    132: '\\u201E',\n    133: '\\u2026',\n    134: '\\u2020',\n    135: '\\u2021',\n    136: '\\u02c6',\n    137: '\\u2030',\n    138: '\\u0160',\n    139: '\\u2039',\n    140: '\\u0152',\n    142: '\\u017d',\n    145: '\\u2018',\n    146: '\\u2019',\n    147: '\\u201C',\n    148: '\\u201D',\n    149: '\\u2022',\n    150: '\\u2013',\n    151: '\\u2014',\n    152: '\\u02DC',\n    153: '\\u2122',\n    154: '\\u0161',\n    155: '\\u203A',\n    156: '\\u0153',\n    158: '\\u017e',\n    159: '\\u0178'\n  };\n  const baseEntities = {\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '&': '&amp;',\n    '`': '&#96;'\n  };\n  const reverseEntities = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&amp;': '&',\n    '&quot;': '\"',\n    '&apos;': `'`\n  };\n\n  const nativeDecode = text => {\n    const elm = SugarElement.fromTag('div').dom;\n    elm.innerHTML = text;\n    return elm.textContent || elm.innerText || text;\n  };\n\n  const buildEntitiesLookup = (items, radix) => {\n    const lookup = {};\n\n    if (items) {\n      const itemList = items.split(',');\n      radix = radix || 10;\n\n      for (let i = 0; i < itemList.length; i += 2) {\n        const chr = String.fromCharCode(parseInt(itemList[i], radix));\n\n        if (!baseEntities[chr]) {\n          const entity = '&' + itemList[i + 1] + ';';\n          lookup[chr] = entity;\n          lookup[entity] = chr;\n        }\n      }\n\n      return lookup;\n    } else {\n      return undefined;\n    }\n  };\n\n  const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n\n  const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n    return baseEntities[chr] || chr;\n  });\n\n  const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n    return baseEntities[chr] || chr;\n  });\n\n  const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n    if (chr.length > 1) {\n      return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n    }\n\n    return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n  });\n\n  const encodeNamed = (text, attr, entities) => {\n    const resolveEntities = entities || namedEntities;\n    return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || resolveEntities[chr] || chr;\n    });\n  };\n\n  const getEncodeFunc = (name, entities) => {\n    const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n\n    const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (baseEntities[chr] !== undefined) {\n        return baseEntities[chr];\n      }\n\n      if (entitiesMap[chr] !== undefined) {\n        return entitiesMap[chr];\n      }\n\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n\n      return '&#' + chr.charCodeAt(0) + ';';\n    });\n\n    const encodeCustomNamed = (text, attr) => {\n      return encodeNamed(text, attr, entitiesMap);\n    };\n\n    const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n\n    if (nameMap.named && nameMap.numeric) {\n      return encodeNamedAndNumeric;\n    }\n\n    if (nameMap.named) {\n      if (entities) {\n        return encodeCustomNamed;\n      }\n\n      return encodeNamed;\n    }\n\n    if (nameMap.numeric) {\n      return encodeNumeric;\n    }\n\n    return encodeRaw;\n  };\n\n  const decode = text => text.replace(entityRegExp, (all, numeric) => {\n    if (numeric) {\n      if (numeric.charAt(0).toLowerCase() === 'x') {\n        numeric = parseInt(numeric.substr(1), 16);\n      } else {\n        numeric = parseInt(numeric, 10);\n      }\n\n      if (numeric > 65535) {\n        numeric -= 65536;\n        return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n      }\n\n      return asciiMap[numeric] || String.fromCharCode(numeric);\n    }\n\n    return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n  });\n\n  const Entities = {\n    encodeRaw,\n    encodeAllRaw,\n    encodeNumeric,\n    encodeNamed,\n    getEncodeFunc,\n    decode\n  };\n\n  const split$1 = (items, delim) => {\n    items = Tools.trim(items);\n    return items ? items.split(delim || ' ') : [];\n  };\n\n  const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n\n  const parseCustomElementsRules = value => {\n    const customElementRegExp = /^(~)?(.+)$/;\n    return bind$3(split$1(value, ','), rule => {\n      const matches = customElementRegExp.exec(rule);\n\n      if (matches) {\n        const inline = matches[1] === '~';\n        const cloneName = inline ? 'span' : 'div';\n        const name = matches[2];\n        return [{\n          inline,\n          cloneName,\n          name\n        }];\n      } else {\n        return [];\n      }\n    });\n  };\n\n  const getElementSetsAsStrings = type => {\n    let globalAttributes, blockContent;\n    let phrasingContent;\n    globalAttributes = 'id accesskey class dir lang style tabindex title role';\n    blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n    phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n\n    if (type !== 'html4') {\n      const transparentContent = 'a ins del canvas map';\n      globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n      blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n      phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n    }\n\n    if (type !== 'html5-strict') {\n      globalAttributes += ' xml:lang';\n      const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n      phrasingContent = [phrasingContent, html4PhrasingContent].join(' ');\n      const html4BlockContent = 'center dir isindex noframes';\n      blockContent = [blockContent, html4BlockContent].join(' ');\n    }\n\n    const flowContent = [blockContent, phrasingContent].join(' ');\n    return {\n      globalAttributes,\n      blockContent,\n      phrasingContent,\n      flowContent\n    };\n  };\n\n  const makeSchema = type => {\n    const {\n      globalAttributes,\n      phrasingContent,\n      flowContent\n    } = getElementSetsAsStrings(type);\n    const schema = {};\n\n    const addElement = (name, attributes, children) => {\n      schema[name] = {\n        attributes: mapToObject(attributes, constant({})),\n        attributesOrder: attributes,\n        children: mapToObject(children, constant({}))\n      };\n    };\n\n    const add = (name, attributes = '', children = '') => {\n      const childNames = split$1(children);\n      const names = split$1(name);\n      let ni = names.length;\n      const allAttributes = split$1([globalAttributes, attributes].join(' '));\n\n      while (ni--) {\n        addElement(names[ni], allAttributes.slice(), childNames);\n      }\n    };\n\n    const addAttrs = (name, attributes) => {\n      const names = split$1(name);\n      const attrs = split$1(attributes);\n      let ni = names.length;\n\n      while (ni--) {\n        const schemaItem = schema[names[ni]];\n\n        for (let i = 0, l = attrs.length; i < l; i++) {\n          schemaItem.attributes[attrs[i]] = {};\n          schemaItem.attributesOrder.push(attrs[i]);\n        }\n      }\n    };\n\n    if (type !== 'html5-strict') {\n      const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n      each$e(split$1(html4PhrasingContent), name => {\n        add(name, '', phrasingContent);\n      });\n      const html4BlockContent = 'center dir isindex noframes';\n      each$e(split$1(html4BlockContent), name => {\n        add(name, '', flowContent);\n      });\n    }\n\n    add('html', 'manifest', 'head body');\n    add('head', '', 'base command link meta noscript script style title');\n    add('title hr noscript br');\n    add('base', 'href target');\n    add('link', 'href rel media hreflang type sizes hreflang');\n    add('meta', 'name http-equiv content charset');\n    add('style', 'media type scoped');\n    add('script', 'src async defer type charset');\n    add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n    add('dd div', '', flowContent);\n    add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n    add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n    add('blockquote', 'cite', flowContent);\n    add('ol', 'reversed start type', 'li');\n    add('ul', '', 'li');\n    add('li', 'value', flowContent);\n    add('dl', '', 'dt dd');\n    add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n    add('q', 'cite', phrasingContent);\n    add('ins del', 'cite datetime', flowContent);\n    add('img', 'src sizes srcset alt usemap ismap width height');\n    add('iframe', 'src name width height', flowContent);\n    add('embed', 'src type width height');\n    add('object', 'data type typemustmatch name usemap form width height', [flowContent, 'param'].join(' '));\n    add('param', 'name value');\n    add('map', 'name', [flowContent, 'area'].join(' '));\n    add('area', 'alt coords shape href target rel media hreflang type');\n    add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n    add('colgroup', 'span', 'col');\n    add('col', 'span');\n    add('tbody thead tfoot', '', 'tr');\n    add('tr', '', 'td th');\n    add('td', 'colspan rowspan headers', flowContent);\n    add('th', 'colspan rowspan headers scope abbr', flowContent);\n    add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n    add('fieldset', 'disabled form name', [flowContent, 'legend'].join(' '));\n    add('label', 'form for', phrasingContent);\n    add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n    add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n    add('select', 'disabled form multiple name required size', 'option optgroup');\n    add('optgroup', 'disabled label', 'option');\n    add('option', 'disabled label selected value');\n    add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n    add('menu', 'type label', [flowContent, 'li'].join(' '));\n    add('noscript', '', flowContent);\n\n    if (type !== 'html4') {\n      add('wbr');\n      add('ruby', '', [phrasingContent, 'rt rp'].join(' '));\n      add('figcaption', '', flowContent);\n      add('mark rt rp bdi', '', phrasingContent);\n      add('summary', '', [phrasingContent, 'h1 h2 h3 h4 h5 h6'].join(' '));\n      add('canvas', 'width height', flowContent);\n      add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [flowContent, 'track source'].join(' '));\n      add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [flowContent, 'track source'].join(' '));\n      add('picture', '', 'img source');\n      add('source', 'src srcset type media sizes');\n      add('track', 'kind src srclang label default');\n      add('datalist', '', [phrasingContent, 'option'].join(' '));\n      add('article section nav aside main header footer', '', flowContent);\n      add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n      add('figure', '', [flowContent, 'figcaption'].join(' '));\n      add('time', 'datetime', phrasingContent);\n      add('dialog', 'open', flowContent);\n      add('command', 'type label icon disabled checked radiogroup command');\n      add('output', 'for form name', phrasingContent);\n      add('progress', 'value max', phrasingContent);\n      add('meter', 'value min max low high optimum', phrasingContent);\n      add('details', 'open', [flowContent, 'summary'].join(' '));\n      add('keygen', 'autofocus challenge disabled form keytype name');\n      addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n    }\n\n    if (type !== 'html5-strict') {\n      addAttrs('script', 'language xml:space');\n      addAttrs('style', 'xml:space');\n      addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n      addAttrs('embed', 'align name hspace vspace');\n      addAttrs('param', 'valuetype type');\n      addAttrs('a', 'charset name rev shape coords');\n      addAttrs('br', 'clear');\n      addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n      addAttrs('img', 'name longdesc align border hspace vspace');\n      addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n      addAttrs('font basefont', 'size color face');\n      addAttrs('input', 'usemap align');\n      addAttrs('select');\n      addAttrs('textarea');\n      addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n      addAttrs('ul', 'type compact');\n      addAttrs('li', 'type');\n      addAttrs('ol dl menu dir', 'compact');\n      addAttrs('pre', 'width xml:space');\n      addAttrs('hr', 'align noshade size width');\n      addAttrs('isindex', 'prompt');\n      addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n      addAttrs('col', 'width align char charoff valign');\n      addAttrs('colgroup', 'width align char charoff valign');\n      addAttrs('thead', 'align char charoff valign');\n      addAttrs('tr', 'align char charoff valign bgcolor');\n      addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n      addAttrs('form', 'accept');\n      addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n      addAttrs('tfoot', 'align char charoff valign');\n      addAttrs('tbody', 'align char charoff valign');\n      addAttrs('area', 'nohref');\n      addAttrs('body', 'background bgcolor text link vlink alink');\n    }\n\n    if (type !== 'html4') {\n      addAttrs('input button select textarea', 'autofocus');\n      addAttrs('input textarea', 'placeholder');\n      addAttrs('a', 'download');\n      addAttrs('link script img', 'crossorigin');\n      addAttrs('img', 'loading');\n      addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');\n    }\n\n    if (type !== 'html4') {\n      each$e([schema.video, schema.audio], item => {\n        delete item.children.audio;\n        delete item.children.video;\n      });\n    }\n\n    each$e(split$1('a form meter progress dfn'), name => {\n      if (schema[name]) {\n        delete schema[name].children[name];\n      }\n    });\n    delete schema.caption.children.table;\n    delete schema.script;\n    return schema;\n  };\n\n  const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n\n  const parseValidChildrenRules = value => {\n    const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n    return bind$3(split$1(value, ','), rule => {\n      const matches = childRuleRegExp.exec(rule);\n\n      if (matches) {\n        const prefix = matches[1];\n        const operation = prefix ? prefixToOperation(prefix) : 'replace';\n        const name = matches[2];\n        const validChildren = split$1(matches[3], '|');\n        return [{\n          operation,\n          name,\n          validChildren\n        }];\n      } else {\n        return [];\n      }\n    });\n  };\n\n  const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n    const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n    const hasPatternsRegExp = /[*?+]/;\n    const {\n      attributes,\n      attributesOrder\n    } = targetElement;\n    return each$e(split$1(attrData, '|'), rule => {\n      const matches = attrRuleRegExp.exec(rule);\n\n      if (matches) {\n        const attr = {};\n        const attrType = matches[1];\n        const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n        const attrPrefix = matches[3];\n        const value = matches[4];\n\n        if (attrType === '!') {\n          targetElement.attributesRequired = targetElement.attributesRequired || [];\n          targetElement.attributesRequired.push(attrName);\n          attr.required = true;\n        }\n\n        if (attrType === '-') {\n          delete attributes[attrName];\n          attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n          return;\n        }\n\n        if (attrPrefix) {\n          if (attrPrefix === '=') {\n            targetElement.attributesDefault = targetElement.attributesDefault || [];\n            targetElement.attributesDefault.push({\n              name: attrName,\n              value\n            });\n            attr.defaultValue = value;\n          } else if (attrPrefix === '~') {\n            targetElement.attributesForced = targetElement.attributesForced || [];\n            targetElement.attributesForced.push({\n              name: attrName,\n              value\n            });\n            attr.forcedValue = value;\n          } else if (attrPrefix === '<') {\n            attr.validValues = Tools.makeMap(value, '?');\n          }\n        }\n\n        if (hasPatternsRegExp.test(attrName)) {\n          const attrPattern = attr;\n          targetElement.attributePatterns = targetElement.attributePatterns || [];\n          attrPattern.pattern = patternToRegExp(attrName);\n          targetElement.attributePatterns.push(attrPattern);\n        } else {\n          if (!attributes[attrName]) {\n            attributesOrder.push(attrName);\n          }\n\n          attributes[attrName] = attr;\n        }\n      }\n    });\n  };\n\n  const cloneAttributesInto = (from, to) => {\n    each$d(from.attributes, (value, key) => {\n      to.attributes[key] = value;\n    });\n    to.attributesOrder.push(...from.attributesOrder);\n  };\n\n  const parseValidElementsRules = (globalElement, validElements) => {\n    const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n    return bind$3(split$1(validElements, ','), rule => {\n      const matches = elementRuleRegExp.exec(rule);\n\n      if (matches) {\n        const prefix = matches[1];\n        const elementName = matches[2];\n        const outputName = matches[3];\n        const attrsPrefix = matches[4];\n        const attrData = matches[5];\n        const element = {\n          attributes: {},\n          attributesOrder: []\n        };\n        globalElement.each(el => cloneAttributesInto(el, element));\n\n        if (prefix === '#') {\n          element.paddEmpty = true;\n        } else if (prefix === '-') {\n          element.removeEmpty = true;\n        }\n\n        if (attrsPrefix === '!') {\n          element.removeEmptyAttrs = true;\n        }\n\n        if (attrData) {\n          parseValidElementsAttrDataIntoElement(attrData, element);\n        }\n\n        if (outputName) {\n          element.outputName = elementName;\n        }\n\n        if (elementName === '@') {\n          if (globalElement.isNone()) {\n            globalElement = Optional.some(element);\n          } else {\n            return [];\n          }\n        }\n\n        return [outputName ? {\n          name: elementName,\n          element,\n          aliasName: outputName\n        } : {\n          name: elementName,\n          element\n        }];\n      } else {\n        return [];\n      }\n    });\n  };\n\n  const mapCache = {};\n  const makeMap$2 = Tools.makeMap,\n        each$b = Tools.each,\n        extend$2 = Tools.extend,\n        explode$2 = Tools.explode;\n\n  const createMap = (defaultValue, extendWith = {}) => {\n    const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n    return extend$2(value, extendWith);\n  };\n\n  const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n\n  const compileElementMap = (value, mode) => {\n    if (value) {\n      const styles = {};\n\n      if (isString(value)) {\n        value = {\n          '*': value\n        };\n      }\n\n      each$b(value, (value, key) => {\n        styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n      });\n      return styles;\n    } else {\n      return undefined;\n    }\n  };\n\n  const Schema = (settings = {}) => {\n    var _a;\n\n    const elements = {};\n    const children = {};\n    let patternElements = [];\n    const customElementsMap = {};\n    const specialElements = {};\n\n    const createLookupTable = (option, defaultValue, extendWith) => {\n      const value = settings[option];\n\n      if (!value) {\n        let newValue = mapCache[option];\n\n        if (!newValue) {\n          newValue = createMap(defaultValue, extendWith);\n          mapCache[option] = newValue;\n        }\n\n        return newValue;\n      } else {\n        return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n      }\n    };\n\n    const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n    const schemaItems = makeSchema(schemaType);\n\n    if (settings.verify_html === false) {\n      settings.valid_elements = '*[*]';\n    }\n\n    const validStyles = compileElementMap(settings.valid_styles);\n    const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n    const validClasses = compileElementMap(settings.valid_classes, 'map');\n    const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n    const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n    const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n    const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n    const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n    const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg', voidElementsMap);\n    const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n    const headings = 'h1 h2 h3 h4 h5 h6';\n    const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n    const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n    const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n    const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n    const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n    each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n      specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n    });\n\n    const addValidElements = validElements => {\n      const globalElement = Optional.from(elements['@']);\n      const hasPatternsRegExp = /[*?+]/;\n      each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({\n        name,\n        element,\n        aliasName\n      }) => {\n        if (aliasName) {\n          elements[aliasName] = element;\n        }\n\n        if (hasPatternsRegExp.test(name)) {\n          const patternElement = element;\n          patternElement.pattern = patternToRegExp(name);\n          patternElements.push(patternElement);\n        } else {\n          elements[name] = element;\n        }\n      });\n    };\n\n    const setValidElements = validElements => {\n      patternElements = [];\n      each$e(keys(elements), name => {\n        delete elements[name];\n      });\n      addValidElements(validElements);\n    };\n\n    const addCustomElements = customElements => {\n      delete mapCache.text_block_elements;\n      delete mapCache.block_elements;\n      each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({\n        inline,\n        name,\n        cloneName\n      }) => {\n        children[name] = children[cloneName];\n        customElementsMap[name] = cloneName;\n        nonEmptyElementsMap[name.toUpperCase()] = {};\n        nonEmptyElementsMap[name] = {};\n\n        if (!inline) {\n          blockElementsMap[name.toUpperCase()] = {};\n          blockElementsMap[name] = {};\n        }\n\n        if (!elements[name]) {\n          let customRule = elements[cloneName];\n          customRule = extend$2({}, customRule);\n          delete customRule.removeEmptyAttrs;\n          delete customRule.removeEmpty;\n          elements[name] = customRule;\n        }\n\n        each$d(children, (element, elmName) => {\n          if (element[cloneName]) {\n            children[elmName] = element = extend$2({}, children[elmName]);\n            element[name] = element[cloneName];\n          }\n        });\n      });\n    };\n\n    const addValidChildren = validChildren => {\n      each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({\n        operation,\n        name,\n        validChildren\n      }) => {\n        const parent = operation === 'replace' ? {\n          '#comment': {}\n        } : children[name];\n        each$e(validChildren, child => {\n          if (operation === 'remove') {\n            delete parent[child];\n          } else {\n            parent[child] = {};\n          }\n        });\n        children[name] = parent;\n      });\n    };\n\n    const getElementRule = name => {\n      const element = elements[name];\n\n      if (element) {\n        return element;\n      }\n\n      let i = patternElements.length;\n\n      while (i--) {\n        const patternElement = patternElements[i];\n\n        if (patternElement.pattern.test(name)) {\n          return patternElement;\n        }\n      }\n\n      return undefined;\n    };\n\n    if (!settings.valid_elements) {\n      each$b(schemaItems, (element, name) => {\n        elements[name] = {\n          attributes: element.attributes,\n          attributesOrder: element.attributesOrder\n        };\n        children[name] = element.children;\n      });\n      each$b(split$1('strong/b em/i'), item => {\n        const items = split$1(item, '/');\n        elements[items[1]].outputName = items[0];\n      });\n      each$b(textInlineElementsMap, (_val, name) => {\n        if (elements[name]) {\n          if (settings.padd_empty_block_inline_children) {\n            elements[name].paddInEmptyBlock = true;\n          }\n\n          elements[name].removeEmpty = true;\n        }\n      });\n      each$b(split$1('ol ul blockquote a table tbody'), name => {\n        if (elements[name]) {\n          elements[name].removeEmpty = true;\n        }\n      });\n      each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n        if (elements[name]) {\n          elements[name].paddEmpty = true;\n        }\n      });\n      each$b(split$1('span'), name => {\n        elements[name].removeEmptyAttrs = true;\n      });\n    } else {\n      setValidElements(settings.valid_elements);\n      each$b(schemaItems, (element, name) => {\n        children[name] = element.children;\n      });\n    }\n\n    delete elements.svg;\n    addCustomElements(settings.custom_elements);\n    addValidChildren(settings.valid_children);\n    addValidElements(settings.extended_valid_elements);\n    addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n    each$b({\n      dd: 'dl',\n      dt: 'dl',\n      li: 'ul ol',\n      td: 'tr',\n      th: 'tr',\n      tr: 'tbody thead tfoot',\n      tbody: 'table',\n      thead: 'table',\n      tfoot: 'table',\n      legend: 'fieldset',\n      area: 'map',\n      param: 'video audio object'\n    }, (parents, item) => {\n      if (elements[item]) {\n        elements[item].parentsRequired = split$1(parents);\n      }\n    });\n\n    if (settings.invalid_elements) {\n      each$b(explode$2(settings.invalid_elements), item => {\n        if (elements[item]) {\n          delete elements[item];\n        }\n      });\n    }\n\n    if (!getElementRule('span')) {\n      addValidElements('span[!data-mce-type|*]');\n    }\n\n    const getValidStyles = constant(validStyles);\n    const getInvalidStyles = constant(invalidStyles);\n    const getValidClasses = constant(validClasses);\n    const getBoolAttrs = constant(boolAttrMap);\n    const getBlockElements = constant(blockElementsMap);\n    const getTextBlockElements = constant(textBlockElementsMap);\n    const getTextInlineElements = constant(textInlineElementsMap);\n    const getVoidElements = constant(Object.seal(voidElementsMap));\n    const getSelfClosingElements = constant(selfClosingElementsMap);\n    const getNonEmptyElements = constant(nonEmptyElementsMap);\n    const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n    const getWhitespaceElements = constant(whitespaceElementsMap);\n    const getTransparentElements = constant(transparentElementsMap);\n    const getWrapBlockElements = constant(wrapBlockElementsMap);\n    const getSpecialElements = constant(Object.seal(specialElements));\n\n    const isValidChild = (name, child) => {\n      const parent = children[name.toLowerCase()];\n      return !!(parent && parent[child.toLowerCase()]);\n    };\n\n    const isValid = (name, attr) => {\n      const rule = getElementRule(name);\n\n      if (rule) {\n        if (attr) {\n          if (rule.attributes[attr]) {\n            return true;\n          }\n\n          const attrPatterns = rule.attributePatterns;\n\n          if (attrPatterns) {\n            let i = attrPatterns.length;\n\n            while (i--) {\n              if (attrPatterns[i].pattern.test(attr)) {\n                return true;\n              }\n            }\n          }\n        } else {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const isBlock = name => has$2(getBlockElements(), name);\n\n    const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n\n    const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n\n    const getCustomElements = constant(customElementsMap);\n    return {\n      type: schemaType,\n      children,\n      elements,\n      getValidStyles,\n      getValidClasses,\n      getBlockElements,\n      getInvalidStyles,\n      getVoidElements,\n      getTextBlockElements,\n      getTextInlineElements,\n      getBoolAttrs,\n      getElementRule,\n      getSelfClosingElements,\n      getNonEmptyElements,\n      getMoveCaretBeforeOnEnterElements,\n      getWhitespaceElements,\n      getTransparentElements,\n      getSpecialElements,\n      isValidChild,\n      isValid,\n      isBlock,\n      isInline,\n      isWrapper,\n      getCustomElements,\n      addValidElements,\n      setValidElements,\n      addCustomElements,\n      addValidChildren\n    };\n  };\n\n  const hexColour = value => ({\n    value: normalizeHex(value)\n  });\n\n  const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n\n  const toHex = component => {\n    const hex = component.toString(16);\n    return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n  };\n\n  const fromRgba = rgbaColour => {\n    const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n    return hexColour(value);\n  };\n\n  const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n  const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n\n  const rgbaColour = (red, green, blue, alpha) => ({\n    red,\n    green,\n    blue,\n    alpha\n  });\n\n  const fromStringValues = (red, green, blue, alpha) => {\n    const r = parseInt(red, 10);\n    const g = parseInt(green, 10);\n    const b = parseInt(blue, 10);\n    const a = parseFloat(alpha);\n    return rgbaColour(r, g, b, a);\n  };\n\n  const fromString = rgbaString => {\n    if (rgbaString === 'transparent') {\n      return Optional.some(rgbaColour(0, 0, 0, 0));\n    }\n\n    const rgbMatch = rgbRegex.exec(rgbaString);\n\n    if (rgbMatch !== null) {\n      return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n    }\n\n    const rgbaMatch = rgbaRegex.exec(rgbaString);\n\n    if (rgbaMatch !== null) {\n      return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n    }\n\n    return Optional.none();\n  };\n\n  const toString = rgba => `rgba(${rgba.red},${rgba.green},${rgba.blue},${rgba.alpha})`;\n\n  const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n  const Styles = (settings = {}, schema) => {\n    const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n    const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n    const trimRightRegExp = /\\s+$/;\n    const encodingLookup = {};\n    let validStyles;\n    let invalidStyles;\n    const invisibleChar = zeroWidth;\n\n    if (schema) {\n      validStyles = schema.getValidStyles();\n      invalidStyles = schema.getInvalidStyles();\n    }\n\n    const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n\n    for (let i = 0; i < encodingItems.length; i++) {\n      encodingLookup[encodingItems[i]] = invisibleChar + i;\n      encodingLookup[invisibleChar + i] = encodingItems[i];\n    }\n\n    const self = {\n      parse: css => {\n        const styles = {};\n        let isEncoded = false;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope || self;\n\n        const compress = (prefix, suffix, noJoin) => {\n          const top = styles[prefix + '-top' + suffix];\n\n          if (!top) {\n            return;\n          }\n\n          const right = styles[prefix + '-right' + suffix];\n\n          if (!right) {\n            return;\n          }\n\n          const bottom = styles[prefix + '-bottom' + suffix];\n\n          if (!bottom) {\n            return;\n          }\n\n          const left = styles[prefix + '-left' + suffix];\n\n          if (!left) {\n            return;\n          }\n\n          const box = [top, right, bottom, left];\n          let i = box.length - 1;\n\n          while (i--) {\n            if (box[i] !== box[i + 1]) {\n              break;\n            }\n          }\n\n          if (i > -1 && noJoin) {\n            return;\n          }\n\n          styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n          delete styles[prefix + '-top' + suffix];\n          delete styles[prefix + '-right' + suffix];\n          delete styles[prefix + '-bottom' + suffix];\n          delete styles[prefix + '-left' + suffix];\n        };\n\n        const canCompress = key => {\n          const value = styles[key];\n\n          if (!value) {\n            return;\n          }\n\n          const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n          let i = values.length;\n\n          while (i--) {\n            if (values[i] !== values[0]) {\n              return false;\n            }\n          }\n\n          styles[key] = values[0];\n          return true;\n        };\n\n        const compress2 = (target, a, b, c) => {\n          if (!canCompress(a)) {\n            return;\n          }\n\n          if (!canCompress(b)) {\n            return;\n          }\n\n          if (!canCompress(c)) {\n            return;\n          }\n\n          styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n          delete styles[a];\n          delete styles[b];\n          delete styles[c];\n        };\n\n        const encode = str => {\n          isEncoded = true;\n          return encodingLookup[str];\n        };\n\n        const decode = (str, keepSlashes) => {\n          if (isEncoded) {\n            str = str.replace(/\\uFEFF[0-9]/g, str => {\n              return encodingLookup[str];\n            });\n          }\n\n          if (!keepSlashes) {\n            str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n          }\n\n          return str;\n        };\n\n        const decodeSingleHexSequence = escSeq => {\n          return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n        };\n\n        const decodeHexSequences = value => {\n          return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n        };\n\n        const processUrl = (match, url, url2, url3, str, str2) => {\n          str = str || str2;\n\n          if (str) {\n            str = decode(str);\n            return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n          }\n\n          url = decode(url || url2 || url3 || '');\n\n          if (!settings.allow_script_urls) {\n            const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n\n            if (/(java|vb)script:/i.test(scriptUrl)) {\n              return '';\n            }\n\n            if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n              return '';\n            }\n          }\n\n          if (urlConverter) {\n            url = urlConverter.call(urlConverterScope, url, 'style');\n          }\n\n          return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n        };\n\n        if (css) {\n          css = css.replace(/[\\u0000-\\u001F]/g, '');\n          css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n            return str.replace(/[;:]/g, encode);\n          });\n          let matches;\n\n          while (matches = styleRegExp.exec(css)) {\n            styleRegExp.lastIndex = matches.index + matches[0].length;\n            let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n            let value = matches[2].replace(trimRightRegExp, '');\n\n            if (name && value) {\n              name = decodeHexSequences(name);\n              value = decodeHexSequences(value);\n\n              if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                continue;\n              }\n\n              if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                continue;\n              }\n\n              if (name === 'font-weight' && value === '700') {\n                value = 'bold';\n              } else if (name === 'color' || name === 'background-color') {\n                value = value.toLowerCase();\n              }\n\n              if (isString(settings.force_hex_color) && settings.force_hex_color !== 'off') {\n                fromString(value).each(rgba => {\n                  if (settings.force_hex_color === 'always' || rgba.alpha === 1) {\n                    value = rgbaToHexString(toString(rgba));\n                  }\n                });\n              }\n\n              value = value.replace(urlOrStrRegExp, processUrl);\n              styles[name] = isEncoded ? decode(value, true) : value;\n            }\n          }\n\n          compress('border', '', true);\n          compress('border', '-width');\n          compress('border', '-color');\n          compress('border', '-style');\n          compress('padding', '');\n          compress('margin', '');\n          compress2('border', 'border-width', 'border-style', 'border-color');\n\n          if (styles.border === 'medium none') {\n            delete styles.border;\n          }\n\n          if (styles['border-image'] === 'none') {\n            delete styles['border-image'];\n          }\n        }\n\n        return styles;\n      },\n      serialize: (styles, elementName) => {\n        let css = '';\n\n        const serializeStyles = (elemName, validStyleList) => {\n          const styleList = validStyleList[elemName];\n\n          if (styleList) {\n            for (let i = 0, l = styleList.length; i < l; i++) {\n              const name = styleList[i];\n              const value = styles[name];\n\n              if (value) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            }\n          }\n        };\n\n        const isValid = (name, elemName) => {\n          if (!invalidStyles || !elemName) {\n            return true;\n          }\n\n          let styleMap = invalidStyles['*'];\n\n          if (styleMap && styleMap[name]) {\n            return false;\n          }\n\n          styleMap = invalidStyles[elemName];\n          return !(styleMap && styleMap[name]);\n        };\n\n        if (elementName && validStyles) {\n          serializeStyles('*', validStyles);\n          serializeStyles(elementName, validStyles);\n        } else {\n          each$d(styles, (value, name) => {\n            if (value && isValid(name, elementName)) {\n              css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n            }\n          });\n        }\n\n        return css;\n      }\n    };\n    return self;\n  };\n\n  const deprecated = {\n    keyLocation: true,\n    layerX: true,\n    layerY: true,\n    returnValue: true,\n    webkitMovementX: true,\n    webkitMovementY: true,\n    keyIdentifier: true,\n    mozPressure: true\n  };\n\n  const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n\n  const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n\n  const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n\n  const clone$3 = (originalEvent, data) => {\n    const event = data !== null && data !== void 0 ? data : {};\n\n    for (const name in originalEvent) {\n      if (!has$2(deprecated, name)) {\n        event[name] = originalEvent[name];\n      }\n    }\n\n    if (isNonNullable(originalEvent.composedPath)) {\n      event.composedPath = () => originalEvent.composedPath();\n    }\n\n    if (isNonNullable(originalEvent.getModifierState)) {\n      event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n    }\n\n    if (isNonNullable(originalEvent.getTargetRanges)) {\n      event.getTargetRanges = () => originalEvent.getTargetRanges();\n    }\n\n    return event;\n  };\n\n  const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n    var _a;\n\n    const event = clone$3(originalEvent, data);\n    event.type = type;\n\n    if (isNullable(event.target)) {\n      event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n    }\n\n    if (needsNormalizing(originalEvent)) {\n      event.preventDefault = () => {\n        event.defaultPrevented = true;\n        event.isDefaultPrevented = always;\n\n        if (isFunction(originalEvent.preventDefault)) {\n          originalEvent.preventDefault();\n        }\n      };\n\n      event.stopPropagation = () => {\n        event.cancelBubble = true;\n        event.isPropagationStopped = always;\n\n        if (isFunction(originalEvent.stopPropagation)) {\n          originalEvent.stopPropagation();\n        }\n      };\n\n      event.stopImmediatePropagation = () => {\n        event.isImmediatePropagationStopped = always;\n        event.stopPropagation();\n      };\n\n      if (!hasIsDefaultPrevented(event)) {\n        event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n        event.isPropagationStopped = event.cancelBubble === true ? always : never;\n        event.isImmediatePropagationStopped = never;\n      }\n    }\n\n    return event;\n  };\n\n  const eventExpandoPrefix = 'mce-data-';\n  const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n\n  const addEvent = (target, name, callback, capture) => {\n    target.addEventListener(name, callback, capture || false);\n  };\n\n  const removeEvent = (target, name, callback, capture) => {\n    target.removeEventListener(name, callback, capture || false);\n  };\n\n  const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n\n  const fix = (originalEvent, data) => {\n    const event = normalize$3(originalEvent.type, originalEvent, document, data);\n\n    if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n      const eventDoc = event.target.ownerDocument || document;\n      const doc = eventDoc.documentElement;\n      const body = eventDoc.body;\n      const mouseEvent = event;\n      mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n      mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n    }\n\n    return event;\n  };\n\n  const bindOnReady = (win, callback, eventUtils) => {\n    const doc = win.document,\n          event = {\n      type: 'ready'\n    };\n\n    if (eventUtils.domLoaded) {\n      callback(event);\n      return;\n    }\n\n    const isDocReady = () => {\n      return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n    };\n\n    const readyHandler = () => {\n      removeEvent(win, 'DOMContentLoaded', readyHandler);\n      removeEvent(win, 'load', readyHandler);\n\n      if (!eventUtils.domLoaded) {\n        eventUtils.domLoaded = true;\n        callback(event);\n      }\n\n      win = null;\n    };\n\n    if (isDocReady()) {\n      readyHandler();\n    } else {\n      addEvent(win, 'DOMContentLoaded', readyHandler);\n    }\n\n    if (!eventUtils.domLoaded) {\n      addEvent(win, 'load', readyHandler);\n    }\n  };\n\n  class EventUtils {\n    constructor() {\n      this.domLoaded = false;\n      this.events = {};\n      this.count = 1;\n      this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n      this.hasFocusIn = 'onfocusin' in document.documentElement;\n      this.count = 1;\n    }\n\n    bind(target, names, callback, scope) {\n      const self = this;\n      let callbackList;\n      const win = window;\n\n      const defaultNativeHandler = evt => {\n        self.executeHandlers(fix(evt || win.event), id);\n      };\n\n      if (!target || isText$a(target) || isComment(target)) {\n        return callback;\n      }\n\n      let id;\n\n      if (!target[self.expando]) {\n        id = self.count++;\n        target[self.expando] = id;\n        self.events[id] = {};\n      } else {\n        id = target[self.expando];\n      }\n\n      scope = scope || target;\n      const namesList = names.split(' ');\n      let i = namesList.length;\n\n      while (i--) {\n        let name = namesList[i];\n        let nativeHandler = defaultNativeHandler;\n        let capture = false;\n        let fakeName = false;\n\n        if (name === 'DOMContentLoaded') {\n          name = 'ready';\n        }\n\n        if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n          callback.call(scope, fix({\n            type: name\n          }));\n          continue;\n        }\n\n        if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n          capture = true;\n          fakeName = name === 'focusin' ? 'focus' : 'blur';\n\n          nativeHandler = evt => {\n            const event = fix(evt || win.event);\n            event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n            self.executeHandlers(event, id);\n          };\n        }\n\n        callbackList = self.events[id][name];\n\n        if (!callbackList) {\n          self.events[id][name] = callbackList = [{\n            func: callback,\n            scope\n          }];\n          callbackList.fakeName = fakeName;\n          callbackList.capture = capture;\n          callbackList.nativeHandler = nativeHandler;\n\n          if (name === 'ready') {\n            bindOnReady(target, nativeHandler, self);\n          } else {\n            addEvent(target, fakeName || name, nativeHandler, capture);\n          }\n        } else {\n          if (name === 'ready' && self.domLoaded) {\n            callback(fix({\n              type: name\n            }));\n          } else {\n            callbackList.push({\n              func: callback,\n              scope\n            });\n          }\n        }\n      }\n\n      target = callbackList = null;\n      return callback;\n    }\n\n    unbind(target, names, callback) {\n      if (!target || isText$a(target) || isComment(target)) {\n        return this;\n      }\n\n      const id = target[this.expando];\n\n      if (id) {\n        let eventMap = this.events[id];\n\n        if (names) {\n          const namesList = names.split(' ');\n          let i = namesList.length;\n\n          while (i--) {\n            const name = namesList[i];\n            const callbackList = eventMap[name];\n\n            if (callbackList) {\n              if (callback) {\n                let ci = callbackList.length;\n\n                while (ci--) {\n                  if (callbackList[ci].func === callback) {\n                    const nativeHandler = callbackList.nativeHandler;\n                    const fakeName = callbackList.fakeName,\n                          capture = callbackList.capture;\n                    const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                    newCallbackList.nativeHandler = nativeHandler;\n                    newCallbackList.fakeName = fakeName;\n                    newCallbackList.capture = capture;\n                    eventMap[name] = newCallbackList;\n                  }\n                }\n              }\n\n              if (!callback || callbackList.length === 0) {\n                delete eventMap[name];\n                removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n              }\n            }\n          }\n        } else {\n          each$d(eventMap, (callbackList, name) => {\n            removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n          });\n          eventMap = {};\n        }\n\n        for (const name in eventMap) {\n          if (has$2(eventMap, name)) {\n            return this;\n          }\n        }\n\n        delete this.events[id];\n\n        try {\n          delete target[this.expando];\n        } catch (ex) {\n          target[this.expando] = null;\n        }\n      }\n\n      return this;\n    }\n\n    fire(target, name, args) {\n      return this.dispatch(target, name, args);\n    }\n\n    dispatch(target, name, args) {\n      if (!target || isText$a(target) || isComment(target)) {\n        return this;\n      }\n\n      const event = fix({\n        type: name,\n        target\n      }, args);\n\n      do {\n        const id = target[this.expando];\n\n        if (id) {\n          this.executeHandlers(event, id);\n        }\n\n        target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n      } while (target && !event.isPropagationStopped());\n\n      return this;\n    }\n\n    clean(target) {\n      if (!target || isText$a(target) || isComment(target)) {\n        return this;\n      }\n\n      if (target[this.expando]) {\n        this.unbind(target);\n      }\n\n      if (!target.getElementsByTagName) {\n        target = target.document;\n      }\n\n      if (target && target.getElementsByTagName) {\n        this.unbind(target);\n        const children = target.getElementsByTagName('*');\n        let i = children.length;\n\n        while (i--) {\n          target = children[i];\n\n          if (target[this.expando]) {\n            this.unbind(target);\n          }\n        }\n      }\n\n      return this;\n    }\n\n    destroy() {\n      this.events = {};\n    }\n\n    cancel(e) {\n      if (e) {\n        e.preventDefault();\n        e.stopImmediatePropagation();\n      }\n\n      return false;\n    }\n\n    executeHandlers(evt, id) {\n      const container = this.events[id];\n      const callbackList = container && container[evt.type];\n\n      if (callbackList) {\n        for (let i = 0, l = callbackList.length; i < l; i++) {\n          const callback = callbackList[i];\n\n          if (callback && callback.func.call(callback.scope, evt) === false) {\n            evt.preventDefault();\n          }\n\n          if (evt.isImmediatePropagationStopped()) {\n            return;\n          }\n        }\n      }\n    }\n\n  }\n\n  EventUtils.Event = new EventUtils();\n  const each$a = Tools.each;\n  const grep = Tools.grep;\n  const internalStyleName = 'data-mce-style';\n  const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n\n  const legacySetAttribute = (elm, name, value) => {\n    if (isNullable(value) || value === '') {\n      remove$a(elm, name);\n    } else {\n      set$3(elm, name, value);\n    }\n  };\n\n  const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n\n  const findNodeIndex = (node, normalized) => {\n    let idx = 0;\n\n    if (node) {\n      for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n        const nodeType = tempNode.nodeType;\n\n        if (normalized && isText$a(tempNode)) {\n          if (nodeType === lastNodeType || !tempNode.data.length) {\n            continue;\n          }\n        }\n\n        idx++;\n        lastNodeType = nodeType;\n      }\n    }\n\n    return idx;\n  };\n\n  const updateInternalStyleAttr = (styles, elm) => {\n    const rawValue = get$9(elm, 'style');\n    const value = styles.serialize(styles.parse(rawValue), name(elm));\n    legacySetAttribute(elm, internalStyleName, value);\n  };\n\n  const convertStyleToString = (cssValue, cssName) => {\n    if (isNumber(cssValue)) {\n      return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n    } else {\n      return cssValue;\n    }\n  };\n\n  const applyStyle$1 = ($elm, cssName, cssValue) => {\n    const normalizedName = camelCaseToHyphens(cssName);\n\n    if (isNullable(cssValue) || cssValue === '') {\n      remove$6($elm, normalizedName);\n    } else {\n      set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n    }\n  };\n\n  const setupAttrHooks = (styles, settings, getContext) => {\n    const keepValues = settings.keep_values;\n    const keepUrlHook = {\n      set: (elm, value, name) => {\n        const sugarElm = SugarElement.fromDom(elm);\n\n        if (isFunction(settings.url_converter) && isNonNullable(value)) {\n          value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n        }\n\n        const internalName = 'data-mce-' + name;\n        legacySetAttribute(sugarElm, internalName, value);\n        legacySetAttribute(sugarElm, name, value);\n      },\n      get: (elm, name) => {\n        const sugarElm = SugarElement.fromDom(elm);\n        return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n      }\n    };\n    const attrHooks = {\n      style: {\n        set: (elm, value) => {\n          const sugarElm = SugarElement.fromDom(elm);\n\n          if (keepValues) {\n            legacySetAttribute(sugarElm, internalStyleName, value);\n          }\n\n          remove$a(sugarElm, 'style');\n\n          if (isString(value)) {\n            setAll(sugarElm, styles.parse(value));\n          }\n        },\n        get: elm => {\n          const sugarElm = SugarElement.fromDom(elm);\n          const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n          return styles.serialize(styles.parse(value), name(sugarElm));\n        }\n      }\n    };\n\n    if (keepValues) {\n      attrHooks.href = attrHooks.src = keepUrlHook;\n    }\n\n    return attrHooks;\n  };\n\n  const DOMUtils = (doc, settings = {}) => {\n    const addedStyles = {};\n    const win = window;\n    const files = {};\n    let counter = 0;\n    const stdMode = true;\n    const boxModel = true;\n    const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n      contentCssCors: settings.contentCssCors,\n      referrerPolicy: settings.referrerPolicy\n    });\n    const boundEvents = [];\n    const schema = settings.schema ? settings.schema : Schema({});\n    const styles = Styles({\n      url_converter: settings.url_converter,\n      url_converter_scope: settings.url_converter_scope,\n      force_hex_color: settings.force_hex_color\n    }, settings.schema);\n    const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n    const blockElementsMap = schema.getBlockElements();\n\n    const isBlock = node => {\n      if (isString(node)) {\n        return has$2(blockElementsMap, node);\n      } else {\n        return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n      }\n    };\n\n    const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n\n    const _get = elm => {\n      const value = get(elm);\n      return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n    };\n\n    const getAttrib = (elm, name, defaultVal = '') => {\n      let value;\n\n      const $elm = _get(elm);\n\n      if (isNonNullable($elm) && isElement$7($elm)) {\n        const hook = attrHooks[name];\n\n        if (hook && hook.get) {\n          value = hook.get($elm.dom, name);\n        } else {\n          value = get$9($elm, name);\n        }\n      }\n\n      return isNonNullable(value) ? value : defaultVal;\n    };\n\n    const getAttribs = elm => {\n      const node = get(elm);\n      return isNullable(node) ? [] : node.attributes;\n    };\n\n    const setAttrib = (elm, name, value) => {\n      run(elm, e => {\n        if (isElement$6(e)) {\n          const $elm = SugarElement.fromDom(e);\n          const val = value === '' ? null : value;\n          const originalValue = get$9($elm, name);\n          const hook = attrHooks[name];\n\n          if (hook && hook.set) {\n            hook.set($elm.dom, val, name);\n          } else {\n            legacySetAttribute($elm, name, val);\n          }\n\n          if (originalValue !== val && settings.onSetAttrib) {\n            settings.onSetAttrib({\n              attrElm: $elm.dom,\n              attrName: name,\n              attrValue: val\n            });\n          }\n        }\n      });\n    };\n\n    const clone = (node, deep) => {\n      return node.cloneNode(deep);\n    };\n\n    const getRoot = () => settings.root_element || doc.body;\n\n    const getViewPort = argWin => {\n      const vp = getBounds(argWin);\n      return {\n        x: vp.x,\n        y: vp.y,\n        w: vp.width,\n        h: vp.height\n      };\n    };\n\n    const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n\n    const setStyle = (elm, name, value) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        applyStyle$1($elm, name, value);\n\n        if (settings.update_styles) {\n          updateInternalStyleAttr(styles, $elm);\n        }\n      });\n    };\n\n    const setStyles = (elm, stylesArg) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        each$d(stylesArg, (v, n) => {\n          applyStyle$1($elm, n, v);\n        });\n\n        if (settings.update_styles) {\n          updateInternalStyleAttr(styles, $elm);\n        }\n      });\n    };\n\n    const getStyle = (elm, name, computed) => {\n      const $elm = get(elm);\n\n      if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n        return undefined;\n      }\n\n      if (computed) {\n        return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n      } else {\n        name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n\n        if (name === 'float') {\n          name = 'cssFloat';\n        }\n\n        return $elm.style ? $elm.style[name] : undefined;\n      }\n    };\n\n    const getSize = elm => {\n      const $elm = get(elm);\n\n      if (!$elm) {\n        return {\n          w: 0,\n          h: 0\n        };\n      }\n\n      let w = getStyle($elm, 'width');\n      let h = getStyle($elm, 'height');\n\n      if (!w || w.indexOf('px') === -1) {\n        w = '0';\n      }\n\n      if (!h || h.indexOf('px') === -1) {\n        h = '0';\n      }\n\n      return {\n        w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n        h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n      };\n    };\n\n    const getRect = elm => {\n      const $elm = get(elm);\n      const pos = getPos$1($elm);\n      const size = getSize($elm);\n      return {\n        x: pos.x,\n        y: pos.y,\n        w: size.w,\n        h: size.h\n      };\n    };\n\n    const is = (elm, selector) => {\n      if (!elm) {\n        return false;\n      }\n\n      const elms = isArray$1(elm) ? elm : [elm];\n      return exists(elms, e => {\n        return is$1(SugarElement.fromDom(e), selector);\n      });\n    };\n\n    const getParents = (elm, selector, root, collect) => {\n      const result = [];\n      let node = get(elm);\n      collect = collect === undefined;\n      const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n\n      if (isString(selector)) {\n        if (selector === '*') {\n          selector = isElement$6;\n        } else {\n          const selectorVal = selector;\n\n          selector = node => is(node, selectorVal);\n        }\n      }\n\n      while (node) {\n        if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n          break;\n        }\n\n        if (!selector || selector(node)) {\n          if (collect) {\n            result.push(node);\n          } else {\n            return [node];\n          }\n        }\n\n        node = node.parentNode;\n      }\n\n      return collect ? result : null;\n    };\n\n    const getParent = (node, selector, root) => {\n      const parents = getParents(node, selector, root, false);\n      return parents && parents.length > 0 ? parents[0] : null;\n    };\n\n    const _findSib = (node, selector, name) => {\n      let func = selector;\n\n      if (node) {\n        if (isString(selector)) {\n          func = node => {\n            return is(node, selector);\n          };\n        }\n\n        for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n          if (isFunction(func) && func(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n\n      return null;\n    };\n\n    const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n\n    const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n\n    const isParentNode = node => isFunction(node.querySelectorAll);\n\n    const select = (selector, scope) => {\n      var _a, _b;\n\n      const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n      return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n    };\n\n    const run = function (elm, func, scope) {\n      const context = scope !== null && scope !== void 0 ? scope : this;\n\n      if (isArray$1(elm)) {\n        const result = [];\n        each$a(elm, (e, i) => {\n          const node = get(e);\n\n          if (node) {\n            result.push(func.call(context, node, i));\n          }\n        });\n        return result;\n      } else {\n        const node = get(elm);\n        return !node ? false : func.call(context, node);\n      }\n    };\n\n    const setAttribs = (elm, attrs) => {\n      run(elm, $elm => {\n        each$d(attrs, (value, name) => {\n          setAttrib($elm, name, value);\n        });\n      });\n    };\n\n    const setHTML = (elm, html) => {\n      run(elm, e => {\n        const $elm = SugarElement.fromDom(e);\n        set$1($elm, html);\n      });\n    };\n\n    const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n      const newElm = isString(name) ? doc.createElement(name) : name;\n\n      if (isNonNullable(attrs)) {\n        setAttribs(newElm, attrs);\n      }\n\n      if (html) {\n        if (!isString(html) && html.nodeType) {\n          newElm.appendChild(html);\n        } else if (isString(html)) {\n          setHTML(newElm, html);\n        }\n      }\n\n      return !create ? parentElm.appendChild(newElm) : newElm;\n    });\n\n    const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n\n    const decode = Entities.decode;\n    const encode = Entities.encodeAllRaw;\n\n    const createHTML = (name, attrs, html = '') => {\n      let outHtml = '<' + name;\n\n      for (const key in attrs) {\n        if (hasNonNullableKey(attrs, key)) {\n          outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n        }\n      }\n\n      if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n        return outHtml + ' />';\n      } else {\n        return outHtml + '>' + html + '</' + name + '>';\n      }\n    };\n\n    const createFragment = html => {\n      const container = doc.createElement('div');\n      const frag = doc.createDocumentFragment();\n      frag.appendChild(container);\n\n      if (html) {\n        container.innerHTML = html;\n      }\n\n      let node;\n\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n\n      frag.removeChild(container);\n      return frag;\n    };\n\n    const remove = (node, keepChildren) => {\n      return run(node, n => {\n        const $node = SugarElement.fromDom(n);\n\n        if (keepChildren) {\n          each$e(children$1($node), child => {\n            if (isText$b(child) && child.dom.length === 0) {\n              remove$5(child);\n            } else {\n              before$3($node, child);\n            }\n          });\n        }\n\n        remove$5($node);\n        return $node.dom;\n      });\n    };\n\n    const removeAllAttribs = e => run(e, e => {\n      const attrs = e.attributes;\n\n      for (let i = attrs.length - 1; i >= 0; i--) {\n        e.removeAttributeNode(attrs.item(i));\n      }\n    });\n\n    const parseStyle = cssText => styles.parse(cssText);\n\n    const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n\n    const addStyle = cssText => {\n      if (self !== DOMUtils.DOM && doc === document) {\n        if (addedStyles[cssText]) {\n          return;\n        }\n\n        addedStyles[cssText] = true;\n      }\n\n      let styleElm = doc.getElementById('mceDefaultStyles');\n\n      if (!styleElm) {\n        styleElm = doc.createElement('style');\n        styleElm.id = 'mceDefaultStyles';\n        styleElm.type = 'text/css';\n        const head = doc.head;\n\n        if (head.firstChild) {\n          head.insertBefore(styleElm, head.firstChild);\n        } else {\n          head.appendChild(styleElm);\n        }\n      }\n\n      if (styleElm.styleSheet) {\n        styleElm.styleSheet.cssText += cssText;\n      } else {\n        styleElm.appendChild(doc.createTextNode(cssText));\n      }\n    };\n\n    const loadCSS = urls => {\n      if (!urls) {\n        urls = '';\n      }\n\n      each$e(urls.split(','), url => {\n        files[url] = true;\n        styleSheetLoader.load(url).catch(noop);\n      });\n    };\n\n    const toggleClass = (elm, cls, state) => {\n      run(elm, e => {\n        if (isElement$6(e)) {\n          const $elm = SugarElement.fromDom(e);\n          const classes = cls.split(' ');\n          each$e(classes, c => {\n            if (isNonNullable(state)) {\n              const fn = state ? add$2 : remove$7;\n              fn($elm, c);\n            } else {\n              toggle$1($elm, c);\n            }\n          });\n        }\n      });\n    };\n\n    const addClass = (elm, cls) => {\n      toggleClass(elm, cls, true);\n    };\n\n    const removeClass = (elm, cls) => {\n      toggleClass(elm, cls, false);\n    };\n\n    const hasClass = (elm, cls) => {\n      const $elm = _get(elm);\n\n      const classes = cls.split(' ');\n      return isNonNullable($elm) && forall(classes, c => has($elm, c));\n    };\n\n    const show = elm => {\n      run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n    };\n\n    const hide = elm => {\n      run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n    };\n\n    const isHidden = elm => {\n      const $elm = _get(elm);\n\n      return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n    };\n\n    const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n\n    const getOuterHTML = elm => {\n      const $elm = _get(elm);\n\n      if (isNonNullable($elm)) {\n        return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n      } else {\n        return '';\n      }\n    };\n\n    const setOuterHTML = (elm, html) => {\n      run(elm, $elm => {\n        if (isElement$6($elm)) {\n          $elm.outerHTML = html;\n        }\n      });\n    };\n\n    const insertAfter = (node, reference) => {\n      const referenceNode = get(reference);\n      return run(node, node => {\n        const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n        const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n\n        if (parent) {\n          if (nextSibling) {\n            parent.insertBefore(node, nextSibling);\n          } else {\n            parent.appendChild(node);\n          }\n        }\n\n        return node;\n      });\n    };\n\n    const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n      var _a;\n\n      const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n\n      if (keepChildren) {\n        each$a(grep(elm.childNodes), node => {\n          replacee.appendChild(node);\n        });\n      }\n\n      (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n      return elm;\n    });\n\n    const rename = (elm, name) => {\n      if (elm.nodeName !== name.toUpperCase()) {\n        const newElm = create(name);\n        each$a(getAttribs(elm), attrNode => {\n          setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n        });\n        replace(newElm, elm, true);\n        return newElm;\n      } else {\n        return elm;\n      }\n    };\n\n    const findCommonAncestor = (a, b) => {\n      let ps = a;\n\n      while (ps) {\n        let pe = b;\n\n        while (pe && ps !== pe) {\n          pe = pe.parentNode;\n        }\n\n        if (ps === pe) {\n          break;\n        }\n\n        ps = ps.parentNode;\n      }\n\n      if (!ps && a.ownerDocument) {\n        return a.ownerDocument.documentElement;\n      } else {\n        return ps;\n      }\n    };\n\n    const isNonEmptyElement = node => {\n      if (isElement$6(node)) {\n        const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n\n        if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    const isEmpty = (node, elements, options) => {\n      let brCount = 0;\n\n      if (isNonEmptyElement(node)) {\n        return false;\n      }\n\n      const firstChild = node.firstChild;\n\n      if (firstChild) {\n        const walker = new DomTreeWalker(firstChild, node);\n        const whitespaceElements = schema ? schema.getWhitespaceElements() : {};\n        const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);\n        let tempNode = firstChild;\n\n        do {\n          if (isElement$6(tempNode)) {\n            const bogusVal = tempNode.getAttribute('data-mce-bogus');\n\n            if (bogusVal) {\n              tempNode = walker.next(bogusVal === 'all');\n              continue;\n            }\n\n            const name = tempNode.nodeName.toLowerCase();\n\n            if (nonEmptyElements && nonEmptyElements[name]) {\n              if (name === 'br') {\n                brCount++;\n                tempNode = walker.next();\n                continue;\n              }\n\n              return false;\n            }\n\n            if (isNonEmptyElement(tempNode)) {\n              return false;\n            }\n          }\n\n          if (isComment(tempNode)) {\n            return false;\n          }\n\n          if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {\n            return false;\n          }\n\n          if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {\n            return false;\n          }\n\n          tempNode = walker.next();\n        } while (tempNode);\n      }\n\n      return brCount <= 1;\n    };\n\n    const createRng = () => doc.createRange();\n\n    const split = (parentElm, splitElm, replacementElm) => {\n      let range = createRng();\n      let beforeFragment;\n      let afterFragment;\n\n      if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n        const parentNode = parentElm.parentNode;\n        range.setStart(parentNode, findNodeIndex(parentElm));\n        range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n        beforeFragment = range.extractContents();\n        range = createRng();\n        range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n        range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n        afterFragment = range.extractContents();\n        parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n\n        if (replacementElm) {\n          parentNode.insertBefore(replacementElm, parentElm);\n        } else {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n\n        parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n        remove(parentElm);\n        return replacementElm || splitElm;\n      } else {\n        return undefined;\n      }\n    };\n\n    const bind = (target, name, func, scope) => {\n      if (isArray$1(target)) {\n        let i = target.length;\n        const rv = [];\n\n        while (i--) {\n          rv[i] = bind(target[i], name, func, scope);\n        }\n\n        return rv;\n      } else {\n        if (settings.collect && (target === doc || target === win)) {\n          boundEvents.push([target, name, func, scope]);\n        }\n\n        return events.bind(target, name, func, scope || self);\n      }\n    };\n\n    const unbind = (target, name, func) => {\n      if (isArray$1(target)) {\n        let i = target.length;\n        const rv = [];\n\n        while (i--) {\n          rv[i] = unbind(target[i], name, func);\n        }\n\n        return rv;\n      } else {\n        if (boundEvents.length > 0 && (target === doc || target === win)) {\n          let i = boundEvents.length;\n\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n\n            if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n              events.unbind(boundTarget, boundName, boundFunc);\n            }\n          }\n        }\n\n        return events.unbind(target, name, func);\n      }\n    };\n\n    const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n\n    const fire = (target, name, evt) => events.dispatch(target, name, evt);\n\n    const getContentEditable = node => {\n      if (node && isHTMLElement(node)) {\n        const contentEditable = node.getAttribute('data-mce-contenteditable');\n\n        if (contentEditable && contentEditable !== 'inherit') {\n          return contentEditable;\n        }\n\n        return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n      } else {\n        return null;\n      }\n    };\n\n    const getContentEditableParent = node => {\n      const root = getRoot();\n      let state = null;\n\n      for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        state = getContentEditable(tempNode);\n\n        if (state !== null) {\n          break;\n        }\n      }\n\n      return state;\n    };\n\n    const isEditable = node => {\n      if (isNonNullable(node)) {\n        const scope = isElement$6(node) ? node : node.parentElement;\n        return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n      } else {\n        return false;\n      }\n    };\n\n    const destroy = () => {\n      if (boundEvents.length > 0) {\n        let i = boundEvents.length;\n\n        while (i--) {\n          const [boundTarget, boundName, boundFunc] = boundEvents[i];\n          events.unbind(boundTarget, boundName, boundFunc);\n        }\n      }\n\n      each$d(files, (_, url) => {\n        styleSheetLoader.unload(url);\n        delete files[url];\n      });\n    };\n\n    const isChildOf = (node, parent) => {\n      return node === parent || parent.contains(node);\n    };\n\n    const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n\n    const self = {\n      doc,\n      settings,\n      win,\n      files,\n      stdMode,\n      boxModel,\n      styleSheetLoader,\n      boundEvents,\n      styles,\n      schema,\n      events,\n      isBlock: isBlock,\n      root: null,\n      clone,\n      getRoot,\n      getViewPort,\n      getRect,\n      getSize,\n      getParent,\n      getParents: getParents,\n      get,\n      getNext,\n      getPrev,\n      select,\n      is,\n      add,\n      create,\n      createHTML,\n      createFragment,\n      remove,\n      setStyle,\n      getStyle: getStyle,\n      setStyles,\n      removeAllAttribs,\n      setAttrib,\n      setAttribs,\n      getAttrib,\n      getPos: getPos$1,\n      parseStyle,\n      serializeStyle,\n      addStyle,\n      loadCSS,\n      addClass,\n      removeClass,\n      hasClass,\n      toggleClass,\n      show,\n      hide,\n      isHidden,\n      uniqueId,\n      setHTML,\n      getOuterHTML,\n      setOuterHTML,\n      decode,\n      encode,\n      insertAfter,\n      replace,\n      rename,\n      findCommonAncestor,\n      run,\n      getAttribs,\n      isEmpty,\n      createRng,\n      nodeIndex: findNodeIndex,\n      split,\n      bind: bind,\n      unbind: unbind,\n      fire,\n      dispatch,\n      getContentEditable,\n      getContentEditableParent,\n      isEditable,\n      destroy,\n      isChildOf,\n      dumpRng\n    };\n    const attrHooks = setupAttrHooks(styles, settings, constant(self));\n    return self;\n  };\n\n  DOMUtils.DOM = DOMUtils(document);\n  DOMUtils.nodeIndex = findNodeIndex;\n  const DOM$b = DOMUtils.DOM;\n  const QUEUED = 0;\n  const LOADING = 1;\n  const LOADED = 2;\n  const FAILED = 3;\n\n  class ScriptLoader {\n    constructor(settings = {}) {\n      this.states = {};\n      this.queue = [];\n      this.scriptLoadedCallbacks = {};\n      this.queueLoadedCallbacks = [];\n      this.loading = false;\n      this.settings = settings;\n    }\n\n    _setReferrerPolicy(referrerPolicy) {\n      this.settings.referrerPolicy = referrerPolicy;\n    }\n\n    loadScript(url) {\n      return new Promise((resolve, reject) => {\n        const dom = DOM$b;\n        let elm;\n\n        const cleanup = () => {\n          dom.remove(id);\n\n          if (elm) {\n            elm.onerror = elm.onload = elm = null;\n          }\n        };\n\n        const done = () => {\n          cleanup();\n          resolve();\n        };\n\n        const error = () => {\n          cleanup();\n          reject('Failed to load script: ' + url);\n        };\n\n        const id = dom.uniqueId();\n        elm = document.createElement('script');\n        elm.id = id;\n        elm.type = 'text/javascript';\n        elm.src = Tools._addCacheSuffix(url);\n\n        if (this.settings.referrerPolicy) {\n          dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n        }\n\n        elm.onload = done;\n        elm.onerror = error;\n        (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n      });\n    }\n\n    isDone(url) {\n      return this.states[url] === LOADED;\n    }\n\n    markDone(url) {\n      this.states[url] = LOADED;\n    }\n\n    add(url) {\n      const self = this;\n      self.queue.push(url);\n      const state = self.states[url];\n\n      if (state === undefined) {\n        self.states[url] = QUEUED;\n      }\n\n      return new Promise((resolve, reject) => {\n        if (!self.scriptLoadedCallbacks[url]) {\n          self.scriptLoadedCallbacks[url] = [];\n        }\n\n        self.scriptLoadedCallbacks[url].push({\n          resolve,\n          reject\n        });\n      });\n    }\n\n    load(url) {\n      return this.add(url);\n    }\n\n    remove(url) {\n      delete this.states[url];\n      delete this.scriptLoadedCallbacks[url];\n    }\n\n    loadQueue() {\n      const queue = this.queue;\n      this.queue = [];\n      return this.loadScripts(queue);\n    }\n\n    loadScripts(scripts) {\n      const self = this;\n\n      const execCallbacks = (name, url) => {\n        get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n          each$e(callbacks, callback => callback[name](url));\n        });\n        delete self.scriptLoadedCallbacks[url];\n      };\n\n      const processResults = results => {\n        const failures = filter$5(results, result => result.status === 'rejected');\n\n        if (failures.length > 0) {\n          return Promise.reject(bind$3(failures, ({\n            reason\n          }) => isArray$1(reason) ? reason : [reason]));\n        } else {\n          return Promise.resolve();\n        }\n      };\n\n      const load = urls => Promise.allSettled(map$3(urls, url => {\n        if (self.states[url] === LOADED) {\n          execCallbacks('resolve', url);\n          return Promise.resolve();\n        } else if (self.states[url] === FAILED) {\n          execCallbacks('reject', url);\n          return Promise.reject(url);\n        } else {\n          self.states[url] = LOADING;\n          return self.loadScript(url).then(() => {\n            self.states[url] = LOADED;\n            execCallbacks('resolve', url);\n            const queue = self.queue;\n\n            if (queue.length > 0) {\n              self.queue = [];\n              return load(queue).then(processResults);\n            } else {\n              return Promise.resolve();\n            }\n          }, () => {\n            self.states[url] = FAILED;\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          });\n        }\n      }));\n\n      const processQueue = urls => {\n        self.loading = true;\n        return load(urls).then(results => {\n          self.loading = false;\n          const nextQueuedItem = self.queueLoadedCallbacks.shift();\n          Optional.from(nextQueuedItem).each(call);\n          return processResults(results);\n        });\n      };\n\n      const uniqueScripts = stringArray(scripts);\n\n      if (self.loading) {\n        return new Promise((resolve, reject) => {\n          self.queueLoadedCallbacks.push(() => {\n            processQueue(uniqueScripts).then(resolve, reject);\n          });\n        });\n      } else {\n        return processQueue(uniqueScripts);\n      }\n    }\n\n  }\n\n  ScriptLoader.ScriptLoader = new ScriptLoader();\n\n  const Cell = initial => {\n    let value = initial;\n\n    const get = () => {\n      return value;\n    };\n\n    const set = v => {\n      value = v;\n    };\n\n    return {\n      get,\n      set\n    };\n  };\n\n  const isDuplicated = (items, item) => {\n    const firstIndex = items.indexOf(item);\n    return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n  };\n\n  const isRaw = str => isObject(str) && has$2(str, 'raw');\n\n  const isTokenised = str => isArray$1(str) && str.length > 1;\n\n  const data = {};\n  const currentCode = Cell('en');\n\n  const getLanguageData = () => get$a(data, currentCode.get());\n\n  const getData$1 = () => map$2(data, value => ({ ...value\n  }));\n\n  const setCode = newCode => {\n    if (newCode) {\n      currentCode.set(newCode);\n    }\n  };\n\n  const getCode = () => currentCode.get();\n\n  const add$1 = (code, items) => {\n    let langData = data[code];\n\n    if (!langData) {\n      data[code] = langData = {};\n    }\n\n    const lcNames = map$3(keys(items), name => name.toLowerCase());\n    each$d(items, (translation, name) => {\n      const lcName = name.toLowerCase();\n\n      if (lcName !== name && isDuplicated(lcNames, lcName)) {\n        if (!has$2(items, lcName)) {\n          langData[lcName] = translation;\n        }\n\n        langData[name] = translation;\n      } else {\n        langData[lcName] = translation;\n      }\n    });\n  };\n\n  const translate = text => {\n    const langData = getLanguageData().getOr({});\n\n    const toString = obj => {\n      if (isFunction(obj)) {\n        return Object.prototype.toString.call(obj);\n      }\n\n      return !isEmpty(obj) ? '' + obj : '';\n    };\n\n    const isEmpty = text => text === '' || text === null || text === undefined;\n\n    const getLangData = text => {\n      const textStr = toString(text);\n      return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n    };\n\n    const removeContext = str => str.replace(/{context:\\w+}$/, '');\n\n    if (isEmpty(text)) {\n      return '';\n    }\n\n    if (isRaw(text)) {\n      return toString(text.raw);\n    }\n\n    if (isTokenised(text)) {\n      const values = text.slice(1);\n      const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n      return removeContext(substitued);\n    }\n\n    return removeContext(getLangData(text));\n  };\n\n  const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n\n  const hasCode = code => has$2(data, code);\n\n  const I18n = {\n    getData: getData$1,\n    setCode,\n    getCode,\n    add: add$1,\n    translate,\n    isRtl: isRtl$1,\n    hasCode\n  };\n\n  const AddOnManager = () => {\n    const items = [];\n    const urls = {};\n    const lookup = {};\n    const _listeners = [];\n\n    const runListeners = (name, state) => {\n      const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n      each$e(matchedListeners, listener => listener.resolve());\n    };\n\n    const isLoaded = name => has$2(urls, name);\n\n    const isAdded = name => has$2(lookup, name);\n\n    const get = name => {\n      if (lookup[name]) {\n        return lookup[name].instance;\n      }\n\n      return undefined;\n    };\n\n    const loadLanguagePack = (name, languages) => {\n      const language = I18n.getCode();\n      const wrappedLanguages = ',' + (languages || '') + ',';\n\n      if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n        return;\n      }\n\n      ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n    };\n\n    const requireLangPack = (name, languages) => {\n      if (AddOnManager.languageLoad !== false) {\n        if (isLoaded(name)) {\n          loadLanguagePack(name, languages);\n        } else {\n          waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n        }\n      }\n    };\n\n    const add = (id, addOn) => {\n      items.push(addOn);\n      lookup[id] = {\n        instance: addOn\n      };\n      runListeners(id, 'added');\n      return addOn;\n    };\n\n    const remove = name => {\n      delete urls[name];\n      delete lookup[name];\n    };\n\n    const createUrl = (baseUrl, dep) => {\n      if (isString(dep)) {\n        return isString(baseUrl) ? {\n          prefix: '',\n          resource: dep,\n          suffix: ''\n        } : {\n          prefix: baseUrl.prefix,\n          resource: dep,\n          suffix: baseUrl.suffix\n        };\n      } else {\n        return dep;\n      }\n    };\n\n    const load = (name, addOnUrl) => {\n      if (urls[name]) {\n        return Promise.resolve();\n      }\n\n      let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n\n      if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n        urlString = AddOnManager.baseURL + '/' + urlString;\n      }\n\n      urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n\n      const done = () => {\n        runListeners(name, 'loaded');\n        return Promise.resolve();\n      };\n\n      if (lookup[name]) {\n        return done();\n      } else {\n        return ScriptLoader.ScriptLoader.add(urlString).then(done);\n      }\n    };\n\n    const waitFor = (name, state = 'added') => {\n      if (state === 'added' && isAdded(name)) {\n        return Promise.resolve();\n      } else if (state === 'loaded' && isLoaded(name)) {\n        return Promise.resolve();\n      } else {\n        return new Promise(resolve => {\n          _listeners.push({\n            name,\n            state,\n            resolve\n          });\n        });\n      }\n    };\n\n    return {\n      items,\n      urls,\n      lookup,\n      get,\n      requireLangPack,\n      add,\n      remove,\n      createUrl,\n      load,\n      waitFor\n    };\n  };\n\n  AddOnManager.languageLoad = true;\n  AddOnManager.baseURL = '';\n  AddOnManager.PluginManager = AddOnManager();\n  AddOnManager.ThemeManager = AddOnManager();\n  AddOnManager.ModelManager = AddOnManager();\n\n  const singleton = doRevoke => {\n    const subject = Cell(Optional.none());\n\n    const revoke = () => subject.get().each(doRevoke);\n\n    const clear = () => {\n      revoke();\n      subject.set(Optional.none());\n    };\n\n    const isSet = () => subject.get().isSome();\n\n    const get = () => subject.get();\n\n    const set = s => {\n      revoke();\n      subject.set(Optional.some(s));\n    };\n\n    return {\n      clear,\n      isSet,\n      get,\n      set\n    };\n  };\n\n  const repeatable = delay => {\n    const intervalId = Cell(Optional.none());\n\n    const revoke = () => intervalId.get().each(id => clearInterval(id));\n\n    const clear = () => {\n      revoke();\n      intervalId.set(Optional.none());\n    };\n\n    const isSet = () => intervalId.get().isSome();\n\n    const get = () => intervalId.get();\n\n    const set = functionToRepeat => {\n      revoke();\n      intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n    };\n\n    return {\n      clear,\n      isSet,\n      get,\n      set\n    };\n  };\n\n  const value$2 = () => {\n    const subject = singleton(noop);\n\n    const on = f => subject.get().each(f);\n\n    return { ...subject,\n      on\n    };\n  };\n\n  const first$1 = (fn, rate) => {\n    let timer = null;\n\n    const cancel = () => {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n\n    const throttle = (...args) => {\n      if (isNull(timer)) {\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      }\n    };\n\n    return {\n      cancel,\n      throttle\n    };\n  };\n\n  const last$1 = (fn, rate) => {\n    let timer = null;\n\n    const cancel = () => {\n      if (!isNull(timer)) {\n        clearTimeout(timer);\n        timer = null;\n      }\n    };\n\n    const throttle = (...args) => {\n      cancel();\n      timer = setTimeout(() => {\n        timer = null;\n        fn.apply(null, args);\n      }, rate);\n    };\n\n    return {\n      cancel,\n      throttle\n    };\n  };\n\n  const annotation = constant('mce-annotation');\n  const dataAnnotation = constant('data-mce-annotation');\n  const dataAnnotationId = constant('data-mce-annotation-uid');\n  const dataAnnotationActive = constant('data-mce-annotation-active');\n  const dataAnnotationClasses = constant('data-mce-annotation-classes');\n  const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n\n  const isRoot$1 = root => node => eq(node, root);\n\n  const identify = (editor, annotationName) => {\n    const rng = editor.selection.getRng();\n    const start = SugarElement.fromDom(rng.startContainer);\n    const root = SugarElement.fromDom(editor.getBody());\n    const selector = annotationName.fold(() => '.' + annotation(), an => `[${dataAnnotation()}=\"${an}\"]`);\n    const newStart = child$1(start, rng.startOffset).getOr(start);\n    const closest = closest$3(newStart, selector, isRoot$1(root));\n    return closest.bind(c => getOpt(c, `${dataAnnotationId()}`).bind(uid => getOpt(c, `${dataAnnotation()}`).map(name => {\n      const elements = findMarkers(editor, uid);\n      return {\n        uid,\n        name,\n        elements\n      };\n    })));\n  };\n\n  const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n\n  const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n\n  const findMarkers = (editor, uid) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const descendants$1 = descendants(body, `[${dataAnnotationId()}=\"${uid}\"]`);\n    return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n  };\n\n  const findAll = (editor, name) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const markers = descendants(body, `[${dataAnnotation()}=\"${name}\"]`);\n    const directory = {};\n    each$e(markers, m => {\n      if (!isBogusElement(m, body)) {\n        const uid = get$9(m, dataAnnotationId());\n        const nodesAlready = get$a(directory, uid).getOr([]);\n        directory[uid] = nodesAlready.concat([m]);\n      }\n    });\n    return directory;\n  };\n\n  const setup$y = (editor, registry) => {\n    const changeCallbacks = Cell({});\n\n    const initData = () => ({\n      listeners: [],\n      previous: value$2()\n    });\n\n    const withCallbacks = (name, f) => {\n      updateCallbacks(name, data => {\n        f(data);\n        return data;\n      });\n    };\n\n    const updateCallbacks = (name, f) => {\n      const callbackMap = changeCallbacks.get();\n      const data = get$a(callbackMap, name).getOrThunk(initData);\n      const outputData = f(data);\n      callbackMap[name] = outputData;\n      changeCallbacks.set(callbackMap);\n    };\n\n    const fireCallbacks = (name, uid, elements) => {\n      withCallbacks(name, data => {\n        each$e(data.listeners, f => f(true, name, {\n          uid,\n          nodes: map$3(elements, elem => elem.dom)\n        }));\n      });\n    };\n\n    const fireNoAnnotation = name => {\n      withCallbacks(name, data => {\n        each$e(data.listeners, f => f(false, name));\n      });\n    };\n\n    const toggleActiveAttr = (uid, state) => {\n      each$e(findMarkers(editor, uid), elem => {\n        if (state) {\n          set$3(elem, dataAnnotationActive(), 'true');\n        } else {\n          remove$a(elem, dataAnnotationActive());\n        }\n      });\n    };\n\n    const onNodeChange = last$1(() => {\n      const annotations = sort(registry.getNames());\n      each$e(annotations, name => {\n        updateCallbacks(name, data => {\n          const prev = data.previous.get();\n          identify(editor, Optional.some(name)).fold(() => {\n            prev.each(uid => {\n              fireNoAnnotation(name);\n              data.previous.clear();\n              toggleActiveAttr(uid, false);\n            });\n          }, ({\n            uid,\n            name,\n            elements\n          }) => {\n            if (!is$2(prev, uid)) {\n              prev.each(uid => toggleActiveAttr(uid, false));\n              fireCallbacks(name, uid, elements);\n              data.previous.set(uid);\n              toggleActiveAttr(uid, true);\n            }\n          });\n          return {\n            previous: data.previous,\n            listeners: data.listeners\n          };\n        });\n      });\n    }, 30);\n    editor.on('remove', () => {\n      onNodeChange.cancel();\n    });\n    editor.on('NodeChange', () => {\n      onNodeChange.throttle();\n    });\n\n    const addListener = (name, f) => {\n      updateCallbacks(name, data => ({\n        previous: data.previous,\n        listeners: data.listeners.concat([f])\n      }));\n    };\n\n    return {\n      addListener\n    };\n  };\n\n  const setup$x = (editor, registry) => {\n    const dataAnnotation$1 = dataAnnotation();\n\n    const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n\n    const removeDirectAnnotation = node => {\n      var _a, _b;\n\n      node.attr(dataAnnotationId(), null);\n      node.attr(dataAnnotation(), null);\n      node.attr(dataAnnotationActive(), null);\n      const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n      const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => node.attr(name, null));\n      const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n      const newClassList = difference(classList, [annotation()].concat(customClasses));\n      node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n      node.attr(dataAnnotationClasses(), null);\n      node.attr(dataAnnotationAttributes(), null);\n    };\n\n    editor.serializer.addTempAttr(dataAnnotationActive());\n    editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n      for (const node of nodes) {\n        identifyParserNode(node).each(settings => {\n          if (settings.persistent === false) {\n            if (node.name === 'span') {\n              node.unwrap();\n            } else {\n              removeDirectAnnotation(node);\n            }\n          }\n        });\n      }\n    });\n  };\n\n  const create$c = () => {\n    const annotations = {};\n\n    const register = (name, settings) => {\n      annotations[name] = {\n        name,\n        settings\n      };\n    };\n\n    const lookup = name => get$a(annotations, name).map(a => a.settings);\n\n    const getNames = () => keys(annotations);\n\n    return {\n      register,\n      lookup,\n      getNames\n    };\n  };\n\n  let unique = 0;\n\n  const generate$1 = prefix => {\n    const date = new Date();\n    const time = date.getTime();\n    const random = Math.floor(Math.random() * 1000000000);\n    unique++;\n    return prefix + '_' + random + unique + String(time);\n  };\n\n  const add = (element, classes) => {\n    each$e(classes, x => {\n      add$2(element, x);\n    });\n  };\n\n  const remove$4 = (element, classes) => {\n    each$e(classes, x => {\n      remove$7(element, x);\n    });\n  };\n\n  const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n\n  const shallow$1 = original => clone$2(original, false);\n\n  const deep$1 = original => clone$2(original, true);\n\n  const shallowAs = (original, tag) => {\n    const nu = SugarElement.fromTag(tag);\n    const attributes = clone$4(original);\n    setAll$1(nu, attributes);\n    return nu;\n  };\n\n  const mutate = (original, tag) => {\n    const nu = shallowAs(original, tag);\n    after$4(original, nu);\n    const children = children$1(original);\n    append(nu, children);\n    remove$5(original);\n    return nu;\n  };\n\n  const TextWalker = (startNode, rootNode, isBoundary = never) => {\n    const walker = new DomTreeWalker(startNode, rootNode);\n\n    const walk = direction => {\n      let next;\n\n      do {\n        next = walker[direction]();\n      } while (next && !isText$a(next) && !isBoundary(next));\n\n      return Optional.from(next).filter(isText$a);\n    };\n\n    return {\n      current: () => Optional.from(walker.current()).filter(isText$a),\n      next: () => walk('next'),\n      prev: () => walk('prev'),\n      prev2: () => walk('prev2')\n    };\n  };\n\n  const TextSeeker = (dom, isBoundary) => {\n    const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n\n    const walk = (node, offset, walker, process) => {\n      if (isText$a(node)) {\n        const newOffset = process(node, offset, node.data);\n\n        if (newOffset !== -1) {\n          return Optional.some({\n            container: node,\n            offset: newOffset\n          });\n        }\n      }\n\n      return walker().bind(next => walk(next.container, next.offset, walker, process));\n    };\n\n    const backwards = (node, offset, process, root) => {\n      const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n      return walk(node, offset, () => walker.prev().map(prev => ({\n        container: prev,\n        offset: prev.length\n      })), process).getOrNull();\n    };\n\n    const forwards = (node, offset, process, root) => {\n      const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n      return walk(node, offset, () => walker.next().map(next => ({\n        container: next,\n        offset: 0\n      })), process).getOrNull();\n    };\n\n    return {\n      backwards,\n      forwards\n    };\n  };\n\n  const round$2 = Math.round;\n\n  const clone$1 = rect => {\n    if (!rect) {\n      return {\n        left: 0,\n        top: 0,\n        bottom: 0,\n        right: 0,\n        width: 0,\n        height: 0\n      };\n    }\n\n    return {\n      left: round$2(rect.left),\n      top: round$2(rect.top),\n      bottom: round$2(rect.bottom),\n      right: round$2(rect.right),\n      width: round$2(rect.width),\n      height: round$2(rect.height)\n    };\n  };\n\n  const collapse = (rect, toStart) => {\n    rect = clone$1(rect);\n\n    if (toStart) {\n      rect.right = rect.left;\n    } else {\n      rect.left = rect.left + rect.width;\n      rect.right = rect.left;\n    }\n\n    rect.width = 0;\n    return rect;\n  };\n\n  const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n\n  const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n\n  const isAbove$1 = (rect1, rect2) => {\n    const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n\n    if (rect1.bottom - halfHeight < rect2.top) {\n      return true;\n    }\n\n    if (rect1.top > rect2.bottom) {\n      return false;\n    }\n\n    return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n  };\n\n  const isBelow$1 = (rect1, rect2) => {\n    if (rect1.top > rect2.bottom) {\n      return true;\n    }\n\n    if (rect1.bottom < rect2.top) {\n      return false;\n    }\n\n    return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n  };\n\n  const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n\n  const boundingClientRectFromRects = rects => {\n    return foldl(rects, (acc, rect) => {\n      return acc.fold(() => Optional.some(rect), prevRect => {\n        const left = Math.min(rect.left, prevRect.left);\n        const top = Math.min(rect.top, prevRect.top);\n        const right = Math.max(rect.right, prevRect.right);\n        const bottom = Math.max(rect.bottom, prevRect.bottom);\n        return Optional.some({\n          top,\n          right,\n          bottom,\n          left,\n          width: right - left,\n          height: bottom - top\n        });\n      });\n    }, Optional.none());\n  };\n\n  const distanceToRectEdgeFromXY = (rect, x, y) => {\n    const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n    const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n    return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n  };\n\n  const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n  const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n  const getSelectedNode = range => {\n    const startContainer = range.startContainer,\n          startOffset = range.startOffset;\n\n    if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n      return startContainer.childNodes[startOffset];\n    }\n\n    return null;\n  };\n\n  const getNode$1 = (container, offset) => {\n    if (isElement$6(container) && container.hasChildNodes()) {\n      const childNodes = container.childNodes;\n      const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n      return childNodes[safeOffset];\n    } else {\n      return container;\n    }\n  };\n\n  const getNodeUnsafe = (container, offset) => {\n    if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n      return undefined;\n    } else {\n      return getNode$1(container, offset);\n    }\n  };\n\n  const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n\n  const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n  const or = (...args) => {\n    return x => {\n      for (let i = 0; i < args.length; i++) {\n        if (args[i](x)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  };\n\n  const and = (...args) => {\n    return x => {\n      for (let i = 0; i < args.length; i++) {\n        if (!args[i](x)) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n  };\n\n  const isElement$4 = isElement$6;\n  const isCaretCandidate$2 = isCaretCandidate$3;\n  const isBlock$2 = matchStyleValues('display', 'block table');\n  const isFloated = matchStyleValues('float', 'left right');\n  const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n  const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n  const isText$7 = isText$a;\n  const isBr$3 = isBr$6;\n  const nodeIndex$1 = DOMUtils.nodeIndex;\n  const resolveIndex$1 = getNodeUnsafe;\n\n  const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n\n  const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n\n  const isRange = rng => !!rng.setStart && !!rng.setEnd;\n\n  const isHiddenWhiteSpaceRange = range => {\n    const container = range.startContainer;\n    const offset = range.startOffset;\n\n    if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {\n      const text = container.data;\n\n      if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const getBrClientRect = brNode => {\n    const doc = brNode.ownerDocument;\n    const rng = createRange$1(doc);\n    const nbsp$1 = doc.createTextNode(nbsp);\n    const parentNode = brNode.parentNode;\n    parentNode.insertBefore(nbsp$1, brNode);\n    rng.setStart(nbsp$1, 0);\n    rng.setEnd(nbsp$1, 1);\n    const clientRect = clone$1(rng.getBoundingClientRect());\n    parentNode.removeChild(nbsp$1);\n    return clientRect;\n  };\n\n  const getBoundingClientRectWebKitText = rng => {\n    const sc = rng.startContainer;\n    const ec = rng.endContainer;\n    const so = rng.startOffset;\n    const eo = rng.endOffset;\n\n    if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {\n      const newRng = rng.cloneRange();\n      newRng.setEndAfter(ec);\n      return getBoundingClientRect$1(newRng);\n    } else {\n      return null;\n    }\n  };\n\n  const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n\n  const getBoundingClientRect$1 = item => {\n    var _a;\n\n    let clientRect;\n    const clientRects = item.getClientRects();\n\n    if (clientRects.length > 0) {\n      clientRect = clone$1(clientRects[0]);\n    } else {\n      clientRect = clone$1(item.getBoundingClientRect());\n    }\n\n    if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n      return getBrClientRect(item);\n    }\n\n    if (isZeroRect(clientRect) && isRange(item)) {\n      return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n    }\n\n    return clientRect;\n  };\n\n  const collapseAndInflateWidth = (clientRect, toStart) => {\n    const newClientRect = collapse(clientRect, toStart);\n    newClientRect.width = 1;\n    newClientRect.right = newClientRect.left + 1;\n    return newClientRect;\n  };\n\n  const getCaretPositionClientRects = caretPosition => {\n    const clientRects = [];\n\n    const addUniqueAndValidRect = clientRect => {\n      if (clientRect.height === 0) {\n        return;\n      }\n\n      if (clientRects.length > 0) {\n        if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n          return;\n        }\n      }\n\n      clientRects.push(clientRect);\n    };\n\n    const addCharacterOffset = (container, offset) => {\n      const range = createRange$1(container.ownerDocument);\n\n      if (offset < container.data.length) {\n        if (isExtendingChar(container.data[offset])) {\n          return;\n        }\n\n        if (isExtendingChar(container.data[offset - 1])) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n            return;\n          }\n        }\n      }\n\n      if (offset > 0) {\n        range.setStart(container, offset - 1);\n        range.setEnd(container, offset);\n\n        if (!isHiddenWhiteSpaceRange(range)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n        }\n      }\n\n      if (offset < container.data.length) {\n        range.setStart(container, offset);\n        range.setEnd(container, offset + 1);\n\n        if (!isHiddenWhiteSpaceRange(range)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n        }\n      }\n    };\n\n    const container = caretPosition.container();\n    const offset = caretPosition.offset();\n\n    if (isText$7(container)) {\n      addCharacterOffset(container, offset);\n      return clientRects;\n    }\n\n    if (isElement$4(container)) {\n      if (caretPosition.isAtEnd()) {\n        const node = resolveIndex$1(container, offset);\n\n        if (isText$7(node)) {\n          addCharacterOffset(node, node.data.length);\n        }\n\n        if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n        }\n      } else {\n        const node = resolveIndex$1(container, offset);\n\n        if (isText$7(node)) {\n          addCharacterOffset(node, 0);\n        }\n\n        if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          return clientRects;\n        }\n\n        const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n\n        if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n          if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n          }\n        }\n\n        if (isValidElementCaretCandidate(node)) {\n          addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n        }\n      }\n    }\n\n    return clientRects;\n  };\n\n  const CaretPosition = (container, offset, clientRects) => {\n    const isAtStart = () => {\n      if (isText$7(container)) {\n        return offset === 0;\n      }\n\n      return offset === 0;\n    };\n\n    const isAtEnd = () => {\n      if (isText$7(container)) {\n        return offset >= container.data.length;\n      }\n\n      return offset >= container.childNodes.length;\n    };\n\n    const toRange = () => {\n      const range = createRange$1(container.ownerDocument);\n      range.setStart(container, offset);\n      range.setEnd(container, offset);\n      return range;\n    };\n\n    const getClientRects = () => {\n      if (!clientRects) {\n        clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n      }\n\n      return clientRects;\n    };\n\n    const isVisible = () => getClientRects().length > 0;\n\n    const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n\n    const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n\n    return {\n      container: constant(container),\n      offset: constant(offset),\n      toRange,\n      getClientRects,\n      isVisible,\n      isAtStart,\n      isAtEnd,\n      isEqual,\n      getNode\n    };\n  };\n\n  CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n\n  CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n\n  CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n\n  CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n\n  CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n\n  CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n\n  CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n\n  CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n\n  CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;\n\n  CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n\n  const trimEmptyTextNode$1 = (dom, node) => {\n    if (isText$a(node) && node.data.length === 0) {\n      dom.remove(node);\n    }\n  };\n\n  const insertNode = (dom, rng, node) => {\n    rng.insertNode(node);\n    trimEmptyTextNode$1(dom, node.previousSibling);\n    trimEmptyTextNode$1(dom, node.nextSibling);\n  };\n\n  const insertFragment = (dom, rng, frag) => {\n    const firstChild = Optional.from(frag.firstChild);\n    const lastChild = Optional.from(frag.lastChild);\n    rng.insertNode(frag);\n    firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n    lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n  };\n\n  const rangeInsertNode = (dom, rng, node) => {\n    if (isDocumentFragment(node)) {\n      insertFragment(dom, rng, node);\n    } else {\n      insertNode(dom, rng, node);\n    }\n  };\n\n  const isText$6 = isText$a;\n  const isBogus = isBogus$2;\n  const nodeIndex = DOMUtils.nodeIndex;\n\n  const normalizedParent = node => {\n    const parentNode = node.parentNode;\n\n    if (isBogus(parentNode)) {\n      return normalizedParent(parentNode);\n    }\n\n    return parentNode;\n  };\n\n  const getChildNodes = node => {\n    if (!node) {\n      return [];\n    }\n\n    return reduce(node.childNodes, (result, node) => {\n      if (isBogus(node) && node.nodeName !== 'BR') {\n        result = result.concat(getChildNodes(node));\n      } else {\n        result.push(node);\n      }\n\n      return result;\n    }, []);\n  };\n\n  const normalizedTextOffset = (node, offset) => {\n    let tempNode = node;\n\n    while (tempNode = tempNode.previousSibling) {\n      if (!isText$6(tempNode)) {\n        break;\n      }\n\n      offset += tempNode.data.length;\n    }\n\n    return offset;\n  };\n\n  const equal = a => b => a === b;\n\n  const normalizedNodeIndex = node => {\n    let nodes, index;\n    nodes = getChildNodes(normalizedParent(node));\n    index = findIndex$1(nodes, equal(node), node);\n    nodes = nodes.slice(0, index + 1);\n    const numTextFragments = reduce(nodes, (result, node, i) => {\n      if (isText$6(node) && isText$6(nodes[i - 1])) {\n        result++;\n      }\n\n      return result;\n    }, 0);\n    nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n    index = findIndex$1(nodes, equal(node), node);\n    return index - numTextFragments;\n  };\n\n  const createPathItem = node => {\n    const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n    return name + '[' + normalizedNodeIndex(node) + ']';\n  };\n\n  const parentsUntil$1 = (root, node, predicate) => {\n    const parents = [];\n\n    for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n      if (predicate && predicate(tempNode)) {\n        break;\n      }\n\n      parents.push(tempNode);\n    }\n\n    return parents;\n  };\n\n  const create$b = (root, caretPosition) => {\n    let path = [];\n    let container = caretPosition.container();\n    let offset = caretPosition.offset();\n    let outputOffset;\n\n    if (isText$6(container)) {\n      outputOffset = normalizedTextOffset(container, offset);\n    } else {\n      const childNodes = container.childNodes;\n\n      if (offset >= childNodes.length) {\n        outputOffset = 'after';\n        offset = childNodes.length - 1;\n      } else {\n        outputOffset = 'before';\n      }\n\n      container = childNodes[offset];\n    }\n\n    path.push(createPathItem(container));\n    let parents = parentsUntil$1(root, container);\n    parents = filter$3(parents, not(isBogus$2));\n    path = path.concat(map$1(parents, node => {\n      return createPathItem(node);\n    }));\n    return path.reverse().join('/') + ',' + outputOffset;\n  };\n\n  const resolvePathItem = (node, name, index) => {\n    let nodes = getChildNodes(node);\n    nodes = filter$3(nodes, (node, index) => {\n      return !isText$6(node) || !isText$6(nodes[index - 1]);\n    });\n    nodes = filter$3(nodes, matchNodeNames([name]));\n    return nodes[index];\n  };\n\n  const findTextPosition = (container, offset) => {\n    let node = container;\n    let targetOffset = 0;\n\n    while (isText$6(node)) {\n      const dataLen = node.data.length;\n\n      if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n        container = node;\n        offset = offset - targetOffset;\n        break;\n      }\n\n      if (!isText$6(node.nextSibling)) {\n        container = node;\n        offset = dataLen;\n        break;\n      }\n\n      targetOffset += dataLen;\n      node = node.nextSibling;\n    }\n\n    if (isText$6(container) && offset > container.data.length) {\n      offset = container.data.length;\n    }\n\n    return CaretPosition(container, offset);\n  };\n\n  const resolve$1 = (root, path) => {\n    if (!path) {\n      return null;\n    }\n\n    const parts = path.split(',');\n    const paths = parts[0].split('/');\n    const offset = parts.length > 1 ? parts[1] : 'before';\n    const container = reduce(paths, (result, value) => {\n      const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n\n      if (!match) {\n        return null;\n      }\n\n      if (match[1] === 'text()') {\n        match[1] = '#text';\n      }\n\n      return resolvePathItem(result, match[1], parseInt(match[2], 10));\n    }, root);\n\n    if (!container) {\n      return null;\n    }\n\n    if (!isText$6(container) && container.parentNode) {\n      let nodeOffset;\n\n      if (offset === 'after') {\n        nodeOffset = nodeIndex(container) + 1;\n      } else {\n        nodeOffset = nodeIndex(container);\n      }\n\n      return CaretPosition(container.parentNode, nodeOffset);\n    }\n\n    return findTextPosition(container, parseInt(offset, 10));\n  };\n\n  const isContentEditableFalse$9 = isContentEditableFalse$b;\n\n  const getNormalizedTextOffset$1 = (trim, container, offset) => {\n    let trimmedOffset = trim(container.data.slice(0, offset)).length;\n\n    for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {\n      trimmedOffset += trim(node.data).length;\n    }\n\n    return trimmedOffset;\n  };\n\n  const getPoint = (dom, trim, normalized, rng, start) => {\n    const container = start ? rng.startContainer : rng.endContainer;\n    let offset = start ? rng.startOffset : rng.endOffset;\n    const point = [];\n    const root = dom.getRoot();\n\n    if (isText$a(container)) {\n      point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n    } else {\n      let after = 0;\n      const childNodes = container.childNodes;\n\n      if (offset >= childNodes.length && childNodes.length) {\n        after = 1;\n        offset = Math.max(0, childNodes.length - 1);\n      }\n\n      point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n    }\n\n    for (let node = container; node && node !== root; node = node.parentNode) {\n      point.push(dom.nodeIndex(node, normalized));\n    }\n\n    return point;\n  };\n\n  const getLocation = (trim, selection, normalized, rng) => {\n    const dom = selection.dom;\n    const start = getPoint(dom, trim, normalized, rng, true);\n    const forward = selection.isForward();\n    const fakeCaret = isRangeInCaretContainerBlock(rng) ? {\n      isFakeCaret: true\n    } : {};\n\n    if (!selection.isCollapsed()) {\n      const end = getPoint(dom, trim, normalized, rng, false);\n      return {\n        start,\n        end,\n        forward,\n        ...fakeCaret\n      };\n    } else {\n      return {\n        start,\n        forward,\n        ...fakeCaret\n      };\n    }\n  };\n\n  const findIndex = (dom, name, element) => {\n    let count = 0;\n    Tools.each(dom.select(name), node => {\n      if (node.getAttribute('data-mce-bogus') === 'all') {\n        return;\n      } else if (node === element) {\n        return false;\n      } else {\n        count++;\n        return;\n      }\n    });\n    return count;\n  };\n\n  const moveEndPoint$1 = (rng, start) => {\n    let container = start ? rng.startContainer : rng.endContainer;\n    let offset = start ? rng.startOffset : rng.endOffset;\n\n    if (isElement$6(container) && container.nodeName === 'TR') {\n      const childNodes = container.childNodes;\n      container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n\n      if (container) {\n        offset = start ? 0 : container.childNodes.length;\n\n        if (start) {\n          rng.setStart(container, offset);\n        } else {\n          rng.setEnd(container, offset);\n        }\n      }\n    }\n  };\n\n  const normalizeTableCellSelection = rng => {\n    moveEndPoint$1(rng, true);\n    moveEndPoint$1(rng, false);\n    return rng;\n  };\n\n  const findSibling = (node, offset) => {\n    if (isElement$6(node)) {\n      node = getNode$1(node, offset);\n\n      if (isContentEditableFalse$9(node)) {\n        return node;\n      }\n    }\n\n    if (isCaretContainer$2(node)) {\n      if (isText$a(node) && isCaretContainerBlock$1(node)) {\n        node = node.parentNode;\n      }\n\n      let sibling = node.previousSibling;\n\n      if (isContentEditableFalse$9(sibling)) {\n        return sibling;\n      }\n\n      sibling = node.nextSibling;\n\n      if (isContentEditableFalse$9(sibling)) {\n        return sibling;\n      }\n    }\n\n    return undefined;\n  };\n\n  const findAdjacentContentEditableFalseElm = rng => {\n    return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n  };\n\n  const getOffsetBookmark = (trim, normalized, selection) => {\n    const element = selection.getNode();\n    const rng = selection.getRng();\n\n    if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n      const name = element.nodeName;\n      return {\n        name,\n        index: findIndex(selection.dom, name, element)\n      };\n    }\n\n    const sibling = findAdjacentContentEditableFalseElm(rng);\n\n    if (sibling) {\n      const name = sibling.tagName;\n      return {\n        name,\n        index: findIndex(selection.dom, name, sibling)\n      };\n    }\n\n    return getLocation(trim, selection, normalized, rng);\n  };\n\n  const getCaretBookmark = selection => {\n    const rng = selection.getRng();\n    return {\n      start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n      end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n      forward: selection.isForward()\n    };\n  };\n\n  const getRangeBookmark = selection => {\n    return {\n      rng: selection.getRng(),\n      forward: selection.isForward()\n    };\n  };\n\n  const createBookmarkSpan = (dom, id, filled) => {\n    const args = {\n      'data-mce-type': 'bookmark',\n      id,\n      'style': 'overflow:hidden;line-height:0px'\n    };\n    return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n  };\n\n  const getPersistentBookmark = (selection, filled) => {\n    const dom = selection.dom;\n    let rng = selection.getRng();\n    const id = dom.uniqueId();\n    const collapsed = selection.isCollapsed();\n    const element = selection.getNode();\n    const name = element.nodeName;\n    const forward = selection.isForward();\n\n    if (name === 'IMG') {\n      return {\n        name,\n        index: findIndex(dom, name, element)\n      };\n    }\n\n    const rng2 = normalizeTableCellSelection(rng.cloneRange());\n\n    if (!collapsed) {\n      rng2.collapse(false);\n      const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n      rangeInsertNode(dom, rng2, endBookmarkNode);\n    }\n\n    rng = normalizeTableCellSelection(rng);\n    rng.collapse(true);\n    const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n    rangeInsertNode(dom, rng, startBookmarkNode);\n    selection.moveToBookmark({\n      id,\n      keep: true,\n      forward\n    });\n    return {\n      id,\n      forward\n    };\n  };\n\n  const getBookmark$2 = (selection, type, normalized = false) => {\n    if (type === 2) {\n      return getOffsetBookmark(trim$2, normalized, selection);\n    } else if (type === 3) {\n      return getCaretBookmark(selection);\n    } else if (type) {\n      return getRangeBookmark(selection);\n    } else {\n      return getPersistentBookmark(selection, false);\n    }\n  };\n\n  const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n  const value$1 = value => {\n    const applyHelper = fn => fn(value);\n\n    const constHelper = constant(value);\n\n    const outputHelper = () => output;\n\n    const output = {\n      tag: true,\n      inner: value,\n      fold: (_onError, onValue) => onValue(value),\n      isValue: always,\n      isError: never,\n      map: mapper => Result.value(mapper(value)),\n      mapError: outputHelper,\n      bind: applyHelper,\n      exists: applyHelper,\n      forall: applyHelper,\n      getOr: constHelper,\n      or: outputHelper,\n      getOrThunk: constHelper,\n      orThunk: outputHelper,\n      getOrDie: constHelper,\n      each: fn => {\n        fn(value);\n      },\n      toOptional: () => Optional.some(value)\n    };\n    return output;\n  };\n\n  const error = error => {\n    const outputHelper = () => output;\n\n    const output = {\n      tag: false,\n      inner: error,\n      fold: (onError, _onValue) => onError(error),\n      isValue: never,\n      isError: always,\n      map: outputHelper,\n      mapError: mapper => Result.error(mapper(error)),\n      bind: outputHelper,\n      exists: never,\n      forall: always,\n      getOr: identity,\n      or: identity,\n      getOrThunk: apply$1,\n      orThunk: apply$1,\n      getOrDie: die(String(error)),\n      each: noop,\n      toOptional: Optional.none\n    };\n    return output;\n  };\n\n  const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n\n  const Result = {\n    value: value$1,\n    error,\n    fromOption\n  };\n\n  const generate = cases => {\n    if (!isArray$1(cases)) {\n      throw new Error('cases must be an array');\n    }\n\n    if (cases.length === 0) {\n      throw new Error('there must be at least one case');\n    }\n\n    const constructors = [];\n    const adt = {};\n    each$e(cases, (acase, count) => {\n      const keys$1 = keys(acase);\n\n      if (keys$1.length !== 1) {\n        throw new Error('one and only one name per case');\n      }\n\n      const key = keys$1[0];\n      const value = acase[key];\n\n      if (adt[key] !== undefined) {\n        throw new Error('duplicate key detected:' + key);\n      } else if (key === 'cata') {\n        throw new Error('cannot have a case named cata (sorry)');\n      } else if (!isArray$1(value)) {\n        throw new Error('case arguments must be an array');\n      }\n\n      constructors.push(key);\n\n      adt[key] = (...args) => {\n        const argLength = args.length;\n\n        if (argLength !== value.length) {\n          throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n        }\n\n        const match = branches => {\n          const branchKeys = keys(branches);\n\n          if (constructors.length !== branchKeys.length) {\n            throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n          }\n\n          const allReqd = forall(constructors, reqKey => {\n            return contains$2(branchKeys, reqKey);\n          });\n\n          if (!allReqd) {\n            throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n          }\n\n          return branches[key].apply(null, args);\n        };\n\n        return {\n          fold: (...foldArgs) => {\n            if (foldArgs.length !== cases.length) {\n              throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n            }\n\n            const target = foldArgs[count];\n            return target.apply(null, args);\n          },\n          match,\n          log: label => {\n            console.log(label, {\n              constructors,\n              constructor: key,\n              params: args\n            });\n          }\n        };\n      };\n    });\n    return adt;\n  };\n\n  const Adt = {\n    generate\n  };\n  Adt.generate([{\n    bothErrors: ['error1', 'error2']\n  }, {\n    firstError: ['error1', 'value2']\n  }, {\n    secondError: ['value1', 'error2']\n  }, {\n    bothValues: ['value1', 'value2']\n  }]);\n\n  const partition$1 = results => {\n    const errors = [];\n    const values = [];\n    each$e(results, result => {\n      result.fold(err => {\n        errors.push(err);\n      }, value => {\n        values.push(value);\n      });\n    });\n    return {\n      errors,\n      values\n    };\n  };\n\n  const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n\n  const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n\n  const normalizePattern = pattern => {\n    const err = message => Result.error({\n      message,\n      pattern\n    });\n\n    const formatOrCmd = (name, onFormat, onCommand) => {\n      if (pattern.format !== undefined) {\n        let formats;\n\n        if (isArray$1(pattern.format)) {\n          if (!forall(pattern.format, isString)) {\n            return err(name + ' pattern has non-string items in the `format` array');\n          }\n\n          formats = pattern.format;\n        } else if (isString(pattern.format)) {\n          formats = [pattern.format];\n        } else {\n          return err(name + ' pattern has non-string `format` parameter');\n        }\n\n        return Result.value(onFormat(formats));\n      } else if (pattern.cmd !== undefined) {\n        if (!isString(pattern.cmd)) {\n          return err(name + ' pattern has non-string `cmd` parameter');\n        }\n\n        return Result.value(onCommand(pattern.cmd, pattern.value));\n      } else {\n        return err(name + ' pattern is missing both `format` and `cmd` parameters');\n      }\n    };\n\n    if (!isObject(pattern)) {\n      return err('Raw pattern is not an object');\n    }\n\n    if (!isString(pattern.start)) {\n      return err('Raw pattern is missing `start` parameter');\n    }\n\n    if (pattern.end !== undefined) {\n      if (!isString(pattern.end)) {\n        return err('Inline pattern has non-string `end` parameter');\n      }\n\n      if (pattern.start.length === 0 && pattern.end.length === 0) {\n        return err('Inline pattern has empty `start` and `end` parameters');\n      }\n\n      let start = pattern.start;\n      let end = pattern.end;\n\n      if (end.length === 0) {\n        end = start;\n        start = '';\n      }\n\n      return formatOrCmd('Inline', format => ({\n        type: 'inline-format',\n        start,\n        end,\n        format\n      }), (cmd, value) => ({\n        type: 'inline-command',\n        start,\n        end,\n        cmd,\n        value\n      }));\n    } else if (pattern.replacement !== undefined) {\n      if (!isString(pattern.replacement)) {\n        return err('Replacement pattern has non-string `replacement` parameter');\n      }\n\n      if (pattern.start.length === 0) {\n        return err('Replacement pattern has empty `start` parameter');\n      }\n\n      return Result.value({\n        type: 'inline-command',\n        start: '',\n        end: pattern.start,\n        cmd: 'mceInsertContent',\n        value: pattern.replacement\n      });\n    } else {\n      if (pattern.start.length === 0) {\n        return err('Block pattern has empty `start` parameter');\n      }\n\n      return formatOrCmd('Block', formats => ({\n        type: 'block-format',\n        start: pattern.start,\n        format: formats[0]\n      }), (command, commandValue) => ({\n        type: 'block-command',\n        start: pattern.start,\n        cmd: command,\n        value: commandValue\n      }));\n    }\n  };\n\n  const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n\n  const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n\n  const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n    inlinePatterns: getInlinePatterns(patterns),\n    blockPatterns: getBlockPatterns(patterns),\n    dynamicPatternsLookup\n  });\n\n  const fromRawPatterns = patterns => {\n    const normalized = partition$1(map$3(patterns, normalizePattern));\n    each$e(normalized.errors, err => console.error(err.message, err.pattern));\n    return normalized.values;\n  };\n\n  const fromRawPatternsLookup = lookupFn => {\n    return ctx => {\n      const rawPatterns = lookupFn(ctx);\n      return fromRawPatterns(rawPatterns);\n    };\n  };\n\n  const deviceDetection$1 = detect$2().deviceType;\n  const isTouch = deviceDetection$1.isTouch();\n  const DOM$a = DOMUtils.DOM;\n\n  const getHash = value => {\n    const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n    return foldl(items, (output, item) => {\n      const arr = item.split('=');\n      const key = arr[0];\n      const val = arr.length > 1 ? arr[1] : key;\n      output[trim$4(key)] = trim$4(val);\n      return output;\n    }, {});\n  };\n\n  const isRegExp = x => is$4(x, RegExp);\n\n  const option = name => editor => editor.options.get(name);\n\n  const stringOrObjectProcessor = value => isString(value) || isObject(value);\n\n  const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n    const valid = isString(value);\n\n    if (valid) {\n      if (value.indexOf('=') !== -1) {\n        const bodyObj = getHash(value);\n        return {\n          value: get$a(bodyObj, editor.id).getOr(defaultValue),\n          valid\n        };\n      } else {\n        return {\n          value,\n          valid\n        };\n      }\n    } else {\n      return {\n        valid: false,\n        message: 'Must be a string.'\n      };\n    }\n  };\n\n  const register$7 = editor => {\n    const registerOption = editor.options.register;\n    registerOption('id', {\n      processor: 'string',\n      default: editor.id\n    });\n    registerOption('selector', {\n      processor: 'string'\n    });\n    registerOption('target', {\n      processor: 'object'\n    });\n    registerOption('suffix', {\n      processor: 'string'\n    });\n    registerOption('cache_suffix', {\n      processor: 'string'\n    });\n    registerOption('base_url', {\n      processor: 'string'\n    });\n    registerOption('referrer_policy', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('language_load', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('inline', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('iframe_attrs', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('doctype', {\n      processor: 'string',\n      default: '<!DOCTYPE html>'\n    });\n    registerOption('document_base_url', {\n      processor: 'string',\n      default: editor.documentBaseUrl\n    });\n    registerOption('body_id', {\n      processor: bodyOptionProcessor(editor, 'tinymce'),\n      default: 'tinymce'\n    });\n    registerOption('body_class', {\n      processor: bodyOptionProcessor(editor),\n      default: ''\n    });\n    registerOption('content_security_policy', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('br_in_pre', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('forced_root_block', {\n      processor: value => {\n        const valid = isString(value) && isNotEmpty(value);\n\n        if (valid) {\n          return {\n            value,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a non-empty string.'\n          };\n        }\n      },\n      default: 'p'\n    });\n    registerOption('forced_root_block_attrs', {\n      processor: 'object',\n      default: {}\n    });\n    registerOption('newline_behavior', {\n      processor: value => {\n        const valid = contains$2(['block', 'linebreak', 'invert', 'default'], value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be one of: block, linebreak, invert or default.'\n        };\n      },\n      default: 'default'\n    });\n    registerOption('br_newline_selector', {\n      processor: 'string',\n      default: '.mce-toc h2,figcaption,caption'\n    });\n    registerOption('no_newline_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('keep_styles', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('end_container_on_empty_block', {\n      processor: value => {\n        if (isBoolean(value)) {\n          return {\n            valid: true,\n            value\n          };\n        } else if (isString(value)) {\n          return {\n            valid: true,\n            value\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be boolean or a string'\n          };\n        }\n      },\n      default: 'blockquote'\n    });\n    registerOption('font_size_style_values', {\n      processor: 'string',\n      default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n    });\n    registerOption('font_size_legacy_values', {\n      processor: 'string',\n      default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n    });\n    registerOption('font_size_classes', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('automatic_uploads', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('images_reuse_filename', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('images_replace_blob_uris', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('icons', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('icons_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_base_path', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('images_upload_credentials', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('images_upload_handler', {\n      processor: 'function'\n    });\n    registerOption('language', {\n      processor: 'string',\n      default: 'en'\n    });\n    registerOption('language_url', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('entity_encoding', {\n      processor: 'string',\n      default: 'named'\n    });\n    registerOption('indent', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('indent_before', {\n      processor: 'string',\n      default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n    });\n    registerOption('indent_after', {\n      processor: 'string',\n      default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n    });\n    registerOption('indent_use_margin', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('indentation', {\n      processor: 'string',\n      default: '40px'\n    });\n    registerOption('content_css', {\n      processor: value => {\n        const valid = value === false || isString(value) || isArrayOf(value, isString);\n\n        if (valid) {\n          if (isString(value)) {\n            return {\n              value: map$3(value.split(','), trim$4),\n              valid\n            };\n          } else if (isArray$1(value)) {\n            return {\n              value,\n              valid\n            };\n          } else if (value === false) {\n            return {\n              value: [],\n              valid\n            };\n          } else {\n            return {\n              value,\n              valid\n            };\n          }\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false, a string or an array of strings.'\n          };\n        }\n      },\n      default: isInline$1(editor) ? [] : ['default']\n    });\n    registerOption('content_style', {\n      processor: 'string'\n    });\n    registerOption('content_css_cors', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('font_css', {\n      processor: value => {\n        const valid = isString(value) || isArrayOf(value, isString);\n\n        if (valid) {\n          const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n          return {\n            value: newValue,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a string or an array of strings.'\n          };\n        }\n      },\n      default: []\n    });\n    registerOption('inline_boundaries', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('inline_boundaries_selector', {\n      processor: 'string',\n      default: 'a[href],code,span.mce-annotation'\n    });\n    registerOption('object_resizing', {\n      processor: value => {\n        const valid = isBoolean(value) || isString(value);\n\n        if (valid) {\n          if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n            return {\n              value: '',\n              valid\n            };\n          } else {\n            return {\n              value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n              valid\n            };\n          }\n        } else {\n          return {\n            valid: false,\n            message: 'Must be boolean or a string'\n          };\n        }\n      },\n      default: !isTouch\n    });\n    registerOption('resize_img_proportional', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('event_root', {\n      processor: 'object'\n    });\n    registerOption('service_message', {\n      processor: 'string'\n    });\n    registerOption('theme', {\n      processor: value => value === false || isString(value) || isFunction(value),\n      default: 'silver'\n    });\n    registerOption('theme_url', {\n      processor: 'string'\n    });\n    registerOption('formats', {\n      processor: 'object'\n    });\n    registerOption('format_empty_lines', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('format_noneditable_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('preview_styles', {\n      processor: value => {\n        const valid = value === false || isString(value);\n\n        if (valid) {\n          return {\n            value: value === false ? '' : value,\n            valid\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be false or a string'\n          };\n        }\n      },\n      default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n    });\n    registerOption('custom_ui_selector', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('hidden_input', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('submit_patch', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('encoding', {\n      processor: 'string'\n    });\n    registerOption('add_form_submit_trigger', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('add_unload_trigger', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('custom_undo_redo_levels', {\n      processor: 'number',\n      default: 0\n    });\n    registerOption('disable_nodechange', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('readonly', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('editable_root', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('plugins', {\n      processor: 'string[]',\n      default: []\n    });\n    registerOption('external_plugins', {\n      processor: 'object'\n    });\n    registerOption('forced_plugins', {\n      processor: 'string[]'\n    });\n    registerOption('model', {\n      processor: 'string',\n      default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n    });\n    registerOption('model_url', {\n      processor: 'string'\n    });\n    registerOption('block_unsupported_drop', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('visual', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('visual_table_class', {\n      processor: 'string',\n      default: 'mce-item-table'\n    });\n    registerOption('visual_anchor_class', {\n      processor: 'string',\n      default: 'mce-item-anchor'\n    });\n    registerOption('iframe_aria_text', {\n      processor: 'string',\n      default: 'Rich Text Area. Press ALT-0 for help.'\n    });\n    registerOption('setup', {\n      processor: 'function'\n    });\n    registerOption('init_instance_callback', {\n      processor: 'function'\n    });\n    registerOption('url_converter', {\n      processor: 'function',\n      default: editor.convertURL\n    });\n    registerOption('url_converter_scope', {\n      processor: 'object',\n      default: editor\n    });\n    registerOption('urlconverter_callback', {\n      processor: 'function'\n    });\n    registerOption('allow_conditional_comments', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_html_data_urls', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_svg_data_urls', {\n      processor: 'boolean'\n    });\n    registerOption('allow_html_in_named_anchor', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_script_urls', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('allow_unsafe_link_target', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('convert_fonts_to_spans', {\n      processor: 'boolean',\n      default: true,\n      deprecated: true\n    });\n    registerOption('fix_list_elements', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('preserve_cdata', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('remove_trailing_brs', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('pad_empty_with_br', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('inline_styles', {\n      processor: 'boolean',\n      default: true,\n      deprecated: true\n    });\n    registerOption('element_format', {\n      processor: 'string',\n      default: 'html'\n    });\n    registerOption('entities', {\n      processor: 'string'\n    });\n    registerOption('schema', {\n      processor: 'string',\n      default: 'html5'\n    });\n    registerOption('convert_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('relative_urls', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('remove_script_host', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('custom_elements', {\n      processor: 'string'\n    });\n    registerOption('extended_valid_elements', {\n      processor: 'string'\n    });\n    registerOption('invalid_elements', {\n      processor: 'string'\n    });\n    registerOption('invalid_styles', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('valid_children', {\n      processor: 'string'\n    });\n    registerOption('valid_classes', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('valid_elements', {\n      processor: 'string'\n    });\n    registerOption('valid_styles', {\n      processor: stringOrObjectProcessor\n    });\n    registerOption('verify_html', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('auto_focus', {\n      processor: value => isString(value) || value === true\n    });\n    registerOption('browser_spellcheck', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('protect', {\n      processor: 'array'\n    });\n    registerOption('images_file_types', {\n      processor: 'string',\n      default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n    });\n    registerOption('deprecation_warnings', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('a11y_advanced_options', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('api_key', {\n      processor: 'string'\n    });\n    registerOption('paste_block_drop', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('paste_data_images', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_preprocess', {\n      processor: 'function'\n    });\n    registerOption('paste_postprocess', {\n      processor: 'function'\n    });\n    registerOption('paste_webkit_styles', {\n      processor: 'string',\n      default: 'none'\n    });\n    registerOption('paste_remove_styles_if_webkit', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_merge_formats', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('smart_paste', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('paste_as_text', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('paste_tab_spaces', {\n      processor: 'number',\n      default: 4\n    });\n    registerOption('text_patterns', {\n      processor: value => {\n        if (isArrayOf(value, isObject) || value === false) {\n          const patterns = value === false ? [] : value;\n          return {\n            value: fromRawPatterns(patterns),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be an array of objects or false.'\n          };\n        }\n      },\n      default: [{\n        start: '*',\n        end: '*',\n        format: 'italic'\n      }, {\n        start: '**',\n        end: '**',\n        format: 'bold'\n      }, {\n        start: '#',\n        format: 'h1'\n      }, {\n        start: '##',\n        format: 'h2'\n      }, {\n        start: '###',\n        format: 'h3'\n      }, {\n        start: '####',\n        format: 'h4'\n      }, {\n        start: '#####',\n        format: 'h5'\n      }, {\n        start: '######',\n        format: 'h6'\n      }, {\n        start: '1. ',\n        cmd: 'InsertOrderedList'\n      }, {\n        start: '* ',\n        cmd: 'InsertUnorderedList'\n      }, {\n        start: '- ',\n        cmd: 'InsertUnorderedList'\n      }]\n    });\n    registerOption('text_patterns_lookup', {\n      processor: value => {\n        if (isFunction(value)) {\n          return {\n            value: fromRawPatternsLookup(value),\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a single function'\n          };\n        }\n      },\n      default: _ctx => []\n    });\n    registerOption('noneditable_class', {\n      processor: 'string',\n      default: 'mceNonEditable'\n    });\n    registerOption('editable_class', {\n      processor: 'string',\n      default: 'mceEditable'\n    });\n    registerOption('noneditable_regexp', {\n      processor: value => {\n        if (isArrayOf(value, isRegExp)) {\n          return {\n            value,\n            valid: true\n          };\n        } else if (isRegExp(value)) {\n          return {\n            value: [value],\n            valid: true\n          };\n        } else {\n          return {\n            valid: false,\n            message: 'Must be a RegExp or an array of RegExp.'\n          };\n        }\n      },\n      default: []\n    });\n    registerOption('table_tab_navigation', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('highlight_on_focus', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('xss_sanitization', {\n      processor: 'boolean',\n      default: true\n    });\n    registerOption('details_initial_state', {\n      processor: value => {\n        const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be one of: inherited, collapsed, or expanded.'\n        };\n      },\n      default: 'inherited'\n    });\n    registerOption('details_serialized_state', {\n      processor: value => {\n        const valid = contains$2(['inherited', 'collapsed', 'expanded'], value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: 'Must be one of: inherited, collapsed, or expanded.'\n        };\n      },\n      default: 'inherited'\n    });\n    registerOption('init_content_sync', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('newdocument_content', {\n      processor: 'string',\n      default: ''\n    });\n    registerOption('force_hex_color', {\n      processor: value => {\n        const options = ['always', 'rgb_only', 'off'];\n        const valid = contains$2(options, value);\n        return valid ? {\n          value,\n          valid\n        } : {\n          valid: false,\n          message: `Must be one of: ${options.join(', ')}.`\n        };\n      },\n      default: 'off'\n    });\n    registerOption('sandbox_iframes', {\n      processor: 'boolean',\n      default: false\n    });\n    registerOption('convert_unsafe_embeds', {\n      processor: 'boolean',\n      default: false\n    });\n    editor.on('ScriptsLoaded', () => {\n      registerOption('directionality', {\n        processor: 'string',\n        default: I18n.isRtl() ? 'rtl' : undefined\n      });\n      registerOption('placeholder', {\n        processor: 'string',\n        default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n      });\n    });\n  };\n\n  const getIframeAttrs = option('iframe_attrs');\n  const getDocType = option('doctype');\n  const getDocumentBaseUrl = option('document_base_url');\n  const getBodyId = option('body_id');\n  const getBodyClass = option('body_class');\n  const getContentSecurityPolicy = option('content_security_policy');\n  const shouldPutBrInPre$1 = option('br_in_pre');\n  const getForcedRootBlock = option('forced_root_block');\n  const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n  const getNewlineBehavior = option('newline_behavior');\n  const getBrNewLineSelector = option('br_newline_selector');\n  const getNoNewLineSelector = option('no_newline_selector');\n  const shouldKeepStyles = option('keep_styles');\n  const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n  const isAutomaticUploadsEnabled = option('automatic_uploads');\n  const shouldReuseFileName = option('images_reuse_filename');\n  const shouldReplaceBlobUris = option('images_replace_blob_uris');\n  const getIconPackName = option('icons');\n  const getIconsUrl = option('icons_url');\n  const getImageUploadUrl = option('images_upload_url');\n  const getImageUploadBasePath = option('images_upload_base_path');\n  const getImagesUploadCredentials = option('images_upload_credentials');\n  const getImagesUploadHandler = option('images_upload_handler');\n  const shouldUseContentCssCors = option('content_css_cors');\n  const getReferrerPolicy = option('referrer_policy');\n  const getLanguageCode = option('language');\n  const getLanguageUrl = option('language_url');\n  const shouldIndentUseMargin = option('indent_use_margin');\n  const getIndentation = option('indentation');\n  const getContentCss = option('content_css');\n  const getContentStyle = option('content_style');\n  const getFontCss = option('font_css');\n  const getDirectionality = option('directionality');\n  const getInlineBoundarySelector = option('inline_boundaries_selector');\n  const getObjectResizing = option('object_resizing');\n  const getResizeImgProportional = option('resize_img_proportional');\n  const getPlaceholder = option('placeholder');\n  const getEventRoot = option('event_root');\n  const getServiceMessage = option('service_message');\n  const getTheme = option('theme');\n  const getThemeUrl = option('theme_url');\n  const getModel = option('model');\n  const getModelUrl = option('model_url');\n  const isInlineBoundariesEnabled = option('inline_boundaries');\n  const getFormats = option('formats');\n  const getPreviewStyles = option('preview_styles');\n  const canFormatEmptyLines = option('format_empty_lines');\n  const getFormatNoneditableSelector = option('format_noneditable_selector');\n  const getCustomUiSelector = option('custom_ui_selector');\n  const isInline$1 = option('inline');\n  const hasHiddenInput = option('hidden_input');\n  const shouldPatchSubmit = option('submit_patch');\n  const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n  const shouldAddUnloadTrigger = option('add_unload_trigger');\n  const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n  const shouldDisableNodeChange = option('disable_nodechange');\n  const isReadOnly$1 = option('readonly');\n  const hasEditableRoot$1 = option('editable_root');\n  const hasContentCssCors = option('content_css_cors');\n  const getPlugins = option('plugins');\n  const getExternalPlugins$1 = option('external_plugins');\n  const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n  const isVisualAidsEnabled = option('visual');\n  const getVisualAidsTableClass = option('visual_table_class');\n  const getVisualAidsAnchorClass = option('visual_anchor_class');\n  const getIframeAriaText = option('iframe_aria_text');\n  const getSetupCallback = option('setup');\n  const getInitInstanceCallback = option('init_instance_callback');\n  const getUrlConverterCallback = option('urlconverter_callback');\n  const getAutoFocus = option('auto_focus');\n  const shouldBrowserSpellcheck = option('browser_spellcheck');\n  const getProtect = option('protect');\n  const shouldPasteBlockDrop = option('paste_block_drop');\n  const shouldPasteDataImages = option('paste_data_images');\n  const getPastePreProcess = option('paste_preprocess');\n  const getPastePostProcess = option('paste_postprocess');\n  const getNewDocumentContent = option('newdocument_content');\n  const getPasteWebkitStyles = option('paste_webkit_styles');\n  const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n  const shouldPasteMergeFormats = option('paste_merge_formats');\n  const isSmartPasteEnabled = option('smart_paste');\n  const isPasteAsTextEnabled = option('paste_as_text');\n  const getPasteTabSpaces = option('paste_tab_spaces');\n  const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n  const getTextPatterns = option('text_patterns');\n  const getTextPatternsLookup = option('text_patterns_lookup');\n  const getNonEditableClass = option('noneditable_class');\n  const getEditableClass = option('editable_class');\n  const getNonEditableRegExps = option('noneditable_regexp');\n  const shouldPreserveCData = option('preserve_cdata');\n  const shouldHighlightOnFocus = option('highlight_on_focus');\n  const shouldSanitizeXss = option('xss_sanitization');\n  const shouldUseDocumentWrite = option('init_content_sync');\n\n  const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n\n  const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n\n  const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n\n  const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n\n  const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n\n  const hasTableTabNavigation = option('table_tab_navigation');\n  const getDetailsInitialState = option('details_initial_state');\n  const getDetailsSerializedState = option('details_serialized_state');\n  const shouldForceHexColor = option('force_hex_color');\n  const shouldSandboxIframes = option('sandbox_iframes');\n  const isElement$3 = isElement$6;\n  const isText$5 = isText$a;\n\n  const removeNode$1 = node => {\n    const parentNode = node.parentNode;\n\n    if (parentNode) {\n      parentNode.removeChild(node);\n    }\n  };\n\n  const trimCount = text => {\n    const trimmedText = trim$2(text);\n    return {\n      count: text.length - trimmedText.length,\n      text: trimmedText\n    };\n  };\n\n  const deleteZwspChars = caretContainer => {\n    let idx;\n\n    while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n      caretContainer.deleteData(idx, 1);\n    }\n  };\n\n  const removeUnchanged = (caretContainer, pos) => {\n    remove$3(caretContainer);\n    return pos;\n  };\n\n  const removeTextAndReposition = (caretContainer, pos) => {\n    const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n    const after = trimCount(caretContainer.data.substr(pos.offset()));\n    const text = before.text + after.text;\n\n    if (text.length > 0) {\n      deleteZwspChars(caretContainer);\n      return CaretPosition(caretContainer, pos.offset() - before.count);\n    } else {\n      return pos;\n    }\n  };\n\n  const removeElementAndReposition = (caretContainer, pos) => {\n    const parentNode = pos.container();\n    const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n      return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n    }).getOr(pos);\n    remove$3(caretContainer);\n    return newPosition;\n  };\n\n  const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n\n  const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n\n  const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n\n  const remove$3 = caretContainerNode => {\n    if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n      if (hasContent(caretContainerNode)) {\n        caretContainerNode.removeAttribute('data-mce-caret');\n      } else {\n        removeNode$1(caretContainerNode);\n      }\n    }\n\n    if (isText$5(caretContainerNode)) {\n      deleteZwspChars(caretContainerNode);\n\n      if (caretContainerNode.data.length === 0) {\n        removeNode$1(caretContainerNode);\n      }\n    }\n  };\n\n  const isContentEditableFalse$8 = isContentEditableFalse$b;\n  const isMedia$1 = isMedia$2;\n  const isTableCell$1 = isTableCell$3;\n  const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n\n  const getAbsoluteClientRect = (root, element, before) => {\n    const clientRect = collapse(element.getBoundingClientRect(), before);\n    let scrollX;\n    let scrollY;\n\n    if (root.tagName === 'BODY') {\n      const docElm = root.ownerDocument.documentElement;\n      scrollX = root.scrollLeft || docElm.scrollLeft;\n      scrollY = root.scrollTop || docElm.scrollTop;\n    } else {\n      const rootRect = root.getBoundingClientRect();\n      scrollX = root.scrollLeft - rootRect.left;\n      scrollY = root.scrollTop - rootRect.top;\n    }\n\n    clientRect.left += scrollX;\n    clientRect.right += scrollX;\n    clientRect.top += scrollY;\n    clientRect.bottom += scrollY;\n    clientRect.width = 1;\n    let margin = element.offsetWidth - element.clientWidth;\n\n    if (margin > 0) {\n      if (before) {\n        margin *= -1;\n      }\n\n      clientRect.left += margin;\n      clientRect.right += margin;\n    }\n\n    return clientRect;\n  };\n\n  const trimInlineCaretContainers = root => {\n    var _a, _b;\n\n    const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n\n    for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n      const node = fakeCaretTargetNodes[i].dom;\n      let sibling = node.previousSibling;\n\n      if (endsWithCaretContainer$1(sibling)) {\n        const data = sibling.data;\n\n        if (data.length === 1) {\n          (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n        } else {\n          sibling.deleteData(data.length - 1, 1);\n        }\n      }\n\n      sibling = node.nextSibling;\n\n      if (startsWithCaretContainer$1(sibling)) {\n        const data = sibling.data;\n\n        if (data.length === 1) {\n          (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n        } else {\n          sibling.deleteData(0, 1);\n        }\n      }\n    }\n  };\n\n  const FakeCaret = (editor, root, isBlock, hasFocus) => {\n    const lastVisualCaret = value$2();\n    let cursorInterval;\n    let caretContainerNode;\n    const caretBlock = getForcedRootBlock(editor);\n    const dom = editor.dom;\n\n    const show = (before, element) => {\n      let rng;\n      hide();\n\n      if (isTableCell$1(element)) {\n        return null;\n      }\n\n      if (isBlock(element)) {\n        const caretContainer = insertBlock(caretBlock, element, before);\n        const clientRect = getAbsoluteClientRect(root, element, before);\n        dom.setStyle(caretContainer, 'top', clientRect.top);\n        caretContainerNode = caretContainer;\n        const caret = dom.create('div', {\n          'class': 'mce-visual-caret',\n          'data-mce-bogus': 'all'\n        });\n        dom.setStyles(caret, { ...clientRect\n        });\n        dom.add(root, caret);\n        lastVisualCaret.set({\n          caret,\n          element,\n          before\n        });\n\n        if (before) {\n          dom.addClass(caret, 'mce-visual-caret-before');\n        }\n\n        startBlink();\n        rng = element.ownerDocument.createRange();\n        rng.setStart(caretContainer, 0);\n        rng.setEnd(caretContainer, 0);\n      } else {\n        caretContainerNode = insertInline$1(element, before);\n        rng = element.ownerDocument.createRange();\n\n        if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n          rng.setStart(caretContainerNode, 0);\n          rng.setEnd(caretContainerNode, 0);\n        } else {\n          rng.setStart(caretContainerNode, 1);\n          rng.setEnd(caretContainerNode, 1);\n        }\n\n        return rng;\n      }\n\n      return rng;\n    };\n\n    const hide = () => {\n      trimInlineCaretContainers(root);\n\n      if (caretContainerNode) {\n        remove$3(caretContainerNode);\n        caretContainerNode = null;\n      }\n\n      lastVisualCaret.on(caretState => {\n        dom.remove(caretState.caret);\n        lastVisualCaret.clear();\n      });\n\n      if (cursorInterval) {\n        clearInterval(cursorInterval);\n        cursorInterval = undefined;\n      }\n    };\n\n    const startBlink = () => {\n      cursorInterval = setInterval(() => {\n        lastVisualCaret.on(caretState => {\n          if (hasFocus()) {\n            dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n          } else {\n            dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n          }\n        });\n      }, 500);\n    };\n\n    const reposition = () => {\n      lastVisualCaret.on(caretState => {\n        const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n        dom.setStyles(caretState.caret, { ...clientRect\n        });\n      });\n    };\n\n    const destroy = () => clearInterval(cursorInterval);\n\n    const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n\n    return {\n      show,\n      hide,\n      getCss,\n      reposition,\n      destroy\n    };\n  };\n\n  const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n\n  const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n\n  const isFakeCaretTarget = node => {\n    const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n    return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n  };\n\n  const isContentEditableTrue$1 = isContentEditableTrue$3;\n  const isContentEditableFalse$7 = isContentEditableFalse$b;\n  const isMedia = isMedia$2;\n  const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n  const isCaretContainer = isCaretContainer$2;\n  const isCaretContainerBlock = isCaretContainerBlock$1;\n  const isElement$2 = isElement$6;\n  const isText$4 = isText$a;\n  const isCaretCandidate$1 = isCaretCandidate$3;\n\n  const isForwards = direction => direction > 0;\n\n  const isBackwards = direction => direction < 0;\n\n  const skipCaretContainers = (walk, shallow) => {\n    let node;\n\n    while (node = walk(shallow)) {\n      if (!isCaretContainerBlock(node)) {\n        return node;\n      }\n    }\n\n    return null;\n  };\n\n  const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n    const walker = new DomTreeWalker(node, rootNode);\n    const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n    let tempNode;\n\n    if (isBackwards(direction)) {\n      if (isCefOrCaretContainer) {\n        tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n\n      while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n    }\n\n    if (isForwards(direction)) {\n      if (isCefOrCaretContainer) {\n        tempNode = skipCaretContainers(walker.next.bind(walker), true);\n\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n\n      while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n        if (predicateFn(tempNode)) {\n          return tempNode;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  const getEditingHost = (node, rootNode) => {\n    const isCETrue = node => isContentEditableTrue$1(node.dom);\n\n    const isRoot = node => node.dom === rootNode;\n\n    return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n  };\n\n  const getParentBlock$3 = (node, rootNode) => {\n    while (node && node !== rootNode) {\n      if (isBlockLike(node)) {\n        return node;\n      }\n\n      node = node.parentNode;\n    }\n\n    return null;\n  };\n\n  const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n\n  const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n    if (!caretPosition) {\n      return Optional.none();\n    }\n\n    const container = caretPosition.container();\n    const offset = caretPosition.offset();\n\n    if (!isElement$2(container)) {\n      return Optional.none();\n    }\n\n    return Optional.from(container.childNodes[offset + relativeOffset]);\n  };\n\n  const beforeAfter = (before, node) => {\n    var _a;\n\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const range = doc.createRange();\n\n    if (before) {\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n    } else {\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n    }\n\n    return range;\n  };\n\n  const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n\n  const lean = (left, root, node) => {\n    const siblingName = left ? 'previousSibling' : 'nextSibling';\n    let tempNode = node;\n\n    while (tempNode && tempNode !== root) {\n      let sibling = tempNode[siblingName];\n\n      if (sibling && isCaretContainer(sibling)) {\n        sibling = sibling[siblingName];\n      }\n\n      if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n        if (isNodesInSameBlock(root, sibling, tempNode)) {\n          return sibling;\n        }\n\n        break;\n      }\n\n      if (isCaretCandidate$1(sibling)) {\n        break;\n      }\n\n      tempNode = tempNode.parentNode;\n    }\n\n    return null;\n  };\n\n  const before$2 = curry(beforeAfter, true);\n  const after$2 = curry(beforeAfter, false);\n\n  const normalizeRange = (direction, root, range) => {\n    let node;\n    const leanLeft = curry(lean, true, root);\n    const leanRight = curry(lean, false, root);\n    const container = range.startContainer;\n    const offset = range.startOffset;\n\n    if (isCaretContainerBlock$1(container)) {\n      const block = isText$4(container) ? container.parentNode : container;\n      const location = block.getAttribute('data-mce-caret');\n\n      if (location === 'before') {\n        node = block.nextSibling;\n\n        if (isFakeCaretTarget(node)) {\n          return before$2(node);\n        }\n      }\n\n      if (location === 'after') {\n        node = block.previousSibling;\n\n        if (isFakeCaretTarget(node)) {\n          return after$2(node);\n        }\n      }\n    }\n\n    if (!range.collapsed) {\n      return range;\n    }\n\n    if (isText$a(container)) {\n      if (isCaretContainer(container)) {\n        if (direction === 1) {\n          node = leanRight(container);\n\n          if (node) {\n            return before$2(node);\n          }\n\n          node = leanLeft(container);\n\n          if (node) {\n            return after$2(node);\n          }\n        }\n\n        if (direction === -1) {\n          node = leanLeft(container);\n\n          if (node) {\n            return after$2(node);\n          }\n\n          node = leanRight(container);\n\n          if (node) {\n            return before$2(node);\n          }\n        }\n\n        return range;\n      }\n\n      if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n        if (direction === 1) {\n          node = leanRight(container);\n\n          if (node) {\n            return before$2(node);\n          }\n        }\n\n        return range;\n      }\n\n      if (startsWithCaretContainer$1(container) && offset <= 1) {\n        if (direction === -1) {\n          node = leanLeft(container);\n\n          if (node) {\n            return after$2(node);\n          }\n        }\n\n        return range;\n      }\n\n      if (offset === container.data.length) {\n        node = leanRight(container);\n\n        if (node) {\n          return before$2(node);\n        }\n\n        return range;\n      }\n\n      if (offset === 0) {\n        node = leanLeft(container);\n\n        if (node) {\n          return after$2(node);\n        }\n\n        return range;\n      }\n    }\n\n    return range;\n  };\n\n  const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n\n  const getNormalizedRangeEndPoint = (direction, root, range) => {\n    const normalizedRange = normalizeRange(direction, root, range);\n    return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n  };\n\n  const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n\n  const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n\n  const getVisualCaretPosition = (walkFn, caretPosition) => {\n    let pos = caretPosition;\n\n    while (pos = walkFn(pos)) {\n      if (pos.isVisible()) {\n        return pos;\n      }\n    }\n\n    return pos;\n  };\n\n  const isMoveInsideSameBlock = (from, to) => {\n    const inSameBlock = isInSameBlock(from, to);\n\n    if (!inSameBlock && isBr$6(from.getNode())) {\n      return true;\n    }\n\n    return inSameBlock;\n  };\n\n  var HDirection;\n\n  (function (HDirection) {\n    HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n    HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n  })(HDirection || (HDirection = {}));\n\n  const isContentEditableFalse$6 = isContentEditableFalse$b;\n  const isText$3 = isText$a;\n  const isElement$1 = isElement$6;\n  const isBr$2 = isBr$6;\n  const isCaretCandidate = isCaretCandidate$3;\n  const isAtomic = isAtomic$1;\n  const isEditableCaretCandidate = isEditableCaretCandidate$1;\n\n  const getParents$3 = (node, root) => {\n    const parents = [];\n    let tempNode = node;\n\n    while (tempNode && tempNode !== root) {\n      parents.push(tempNode);\n      tempNode = tempNode.parentNode;\n    }\n\n    return parents;\n  };\n\n  const nodeAtIndex = (container, offset) => {\n    if (container.hasChildNodes() && offset < container.childNodes.length) {\n      return container.childNodes[offset];\n    }\n\n    return null;\n  };\n\n  const getCaretCandidatePosition = (direction, node) => {\n    if (isForwards(direction)) {\n      if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n        return CaretPosition.before(node);\n      }\n\n      if (isText$3(node)) {\n        return CaretPosition(node, 0);\n      }\n    }\n\n    if (isBackwards(direction)) {\n      if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n        return CaretPosition.after(node);\n      }\n\n      if (isText$3(node)) {\n        return CaretPosition(node, node.data.length);\n      }\n    }\n\n    if (isBackwards(direction)) {\n      if (isBr$2(node)) {\n        return CaretPosition.before(node);\n      }\n\n      return CaretPosition.after(node);\n    }\n\n    return CaretPosition.before(node);\n  };\n\n  const moveForwardFromBr = (root, nextNode) => {\n    const nextSibling = nextNode.nextSibling;\n\n    if (nextSibling && isCaretCandidate(nextSibling)) {\n      if (isText$3(nextSibling)) {\n        return CaretPosition(nextSibling, 0);\n      } else {\n        return CaretPosition.before(nextSibling);\n      }\n    } else {\n      return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n    }\n  };\n\n  const findCaretPosition$1 = (direction, startPos, root) => {\n    let node;\n    let nextNode;\n    let innerNode;\n    let caretPosition;\n\n    if (!isElement$1(root) || !startPos) {\n      return null;\n    }\n\n    if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n      caretPosition = CaretPosition.after(root.lastChild);\n\n      if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n        return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n      }\n    } else {\n      caretPosition = startPos;\n    }\n\n    const container = caretPosition.container();\n    let offset = caretPosition.offset();\n\n    if (isText$3(container)) {\n      if (isBackwards(direction) && offset > 0) {\n        return CaretPosition(container, --offset);\n      }\n\n      if (isForwards(direction) && offset < container.length) {\n        return CaretPosition(container, ++offset);\n      }\n\n      node = container;\n    } else {\n      if (isBackwards(direction) && offset > 0) {\n        nextNode = nodeAtIndex(container, offset - 1);\n\n        if (isCaretCandidate(nextNode)) {\n          if (!isAtomic(nextNode)) {\n            innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n\n            if (innerNode) {\n              if (isText$3(innerNode)) {\n                return CaretPosition(innerNode, innerNode.data.length);\n              }\n\n              return CaretPosition.after(innerNode);\n            }\n          }\n\n          if (isText$3(nextNode)) {\n            return CaretPosition(nextNode, nextNode.data.length);\n          }\n\n          return CaretPosition.before(nextNode);\n        }\n      }\n\n      if (isForwards(direction) && offset < container.childNodes.length) {\n        nextNode = nodeAtIndex(container, offset);\n\n        if (isCaretCandidate(nextNode)) {\n          if (isBr$2(nextNode)) {\n            return moveForwardFromBr(root, nextNode);\n          }\n\n          if (!isAtomic(nextNode)) {\n            innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n\n            if (innerNode) {\n              if (isText$3(innerNode)) {\n                return CaretPosition(innerNode, 0);\n              }\n\n              return CaretPosition.before(innerNode);\n            }\n          }\n\n          if (isText$3(nextNode)) {\n            return CaretPosition(nextNode, 0);\n          }\n\n          return CaretPosition.after(nextNode);\n        }\n      }\n\n      node = nextNode ? nextNode : caretPosition.getNode();\n    }\n\n    if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n      node = findNode(node, direction, always, root, true);\n\n      if (isEditableCaretCandidate(node, root)) {\n        return getCaretCandidatePosition(direction, node);\n      }\n    }\n\n    nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n    const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n\n    if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n      if (isForwards(direction)) {\n        caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n      } else {\n        caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n      }\n\n      return caretPosition;\n    }\n\n    if (nextNode) {\n      return getCaretCandidatePosition(direction, nextNode);\n    }\n\n    return null;\n  };\n\n  const CaretWalker = root => ({\n    next: caretPosition => {\n      return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n    },\n    prev: caretPosition => {\n      return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n    }\n  });\n\n  const walkToPositionIn = (forward, root, start) => {\n    const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n    return fromPosition(forward, root, position);\n  };\n\n  const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n\n  const isBeforeOrStart = position => {\n    if (CaretPosition.isTextPosition(position)) {\n      return position.offset() === 0;\n    } else {\n      return isCaretCandidate$3(position.getNode());\n    }\n  };\n\n  const isAfterOrEnd = position => {\n    if (CaretPosition.isTextPosition(position)) {\n      const container = position.container();\n      return position.offset() === container.data.length;\n    } else {\n      return isCaretCandidate$3(position.getNode(true));\n    }\n  };\n\n  const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n\n  const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n\n  const shouldSkipPosition = (forward, from, to) => {\n    if (forward) {\n      return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n    } else {\n      return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n    }\n  };\n\n  const fromPosition = (forward, root, pos) => {\n    const walker = CaretWalker(root);\n    return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n  };\n\n  const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n    if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n      return fromPosition(forward, root, to);\n    } else {\n      return Optional.some(to);\n    }\n  });\n\n  const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n\n  const positionIn = (forward, element) => {\n    const startNode = forward ? element.firstChild : element.lastChild;\n\n    if (isText$a(startNode)) {\n      return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n    } else if (startNode) {\n      if (isCaretCandidate$3(startNode)) {\n        return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n      } else {\n        return walkToPositionIn(forward, element, startNode);\n      }\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const nextPosition = curry(fromPosition, true);\n  const prevPosition = curry(fromPosition, false);\n  const firstPositionIn = curry(positionIn, true);\n  const lastPositionIn = curry(positionIn, false);\n  const CARET_ID = '_mce_caret';\n\n  const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n\n  const getParentCaretContainer = (body, node) => {\n    let currentNode = node;\n\n    while (currentNode && currentNode !== body) {\n      if (isCaretNode(currentNode)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.parentNode;\n    }\n\n    return null;\n  };\n\n  const isStringPathBookmark = bookmark => isString(bookmark.start);\n\n  const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n\n  const isIdBookmark = bookmark => has$2(bookmark, 'id');\n\n  const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n\n  const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n  const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n\n  const addBogus = (dom, node) => {\n    if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n      node.innerHTML = '<br data-mce-bogus=\"1\" />';\n    }\n\n    return node;\n  };\n\n  const resolveCaretPositionBookmark = (dom, bookmark) => {\n    const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n    const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n    return lift2(startPos, endPos, (start, end) => {\n      const range = dom.createRng();\n      range.setStart(start.container(), start.offset());\n      range.setEnd(end.container(), end.offset());\n      return {\n        range,\n        forward: isForwardBookmark(bookmark)\n      };\n    });\n  };\n\n  const insertZwsp = (node, rng) => {\n    var _a;\n\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    const textNode = doc.createTextNode(ZWSP$1);\n    node.appendChild(textNode);\n    rng.setStart(textNode, 0);\n    rng.setEnd(textNode, 0);\n  };\n\n  const isEmpty$1 = node => !node.hasChildNodes();\n\n  const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n    rng.setStart(pos.container(), pos.offset());\n    rng.setEnd(pos.container(), pos.offset());\n    return true;\n  });\n\n  const padEmptyCaretContainer = (root, node, rng) => {\n    if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n      insertZwsp(node, rng);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const setEndPoint = (dom, start, bookmark, rng) => {\n    const point = bookmark[start ? 'start' : 'end'];\n    const root = dom.getRoot();\n\n    if (point) {\n      let node = root;\n      let offset = point[0];\n\n      for (let i = point.length - 1; node && i >= 1; i--) {\n        const children = node.childNodes;\n\n        if (padEmptyCaretContainer(root, node, rng)) {\n          return true;\n        }\n\n        if (point[i] > children.length - 1) {\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n\n          return tryFindRangePosition(node, rng);\n        }\n\n        node = children[point[i]];\n      }\n\n      if (isText$a(node)) {\n        offset = Math.min(point[0], node.data.length);\n      }\n\n      if (isElement$6(node)) {\n        offset = Math.min(point[0], node.childNodes.length);\n      }\n\n      if (start) {\n        rng.setStart(node, offset);\n      } else {\n        rng.setEnd(node, offset);\n      }\n    }\n\n    return true;\n  };\n\n  const isValidTextNode = node => isText$a(node) && node.data.length > 0;\n\n  const restoreEndPoint = (dom, suffix, bookmark) => {\n    const marker = dom.get(bookmark.id + '_' + suffix);\n    const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n    const keep = bookmark.keep;\n\n    if (marker && markerParent) {\n      let container;\n      let offset;\n\n      if (suffix === 'start') {\n        if (!keep) {\n          container = markerParent;\n          offset = dom.nodeIndex(marker);\n        } else {\n          if (marker.hasChildNodes()) {\n            container = marker.firstChild;\n            offset = 1;\n          } else if (isValidTextNode(marker.nextSibling)) {\n            container = marker.nextSibling;\n            offset = 0;\n          } else if (isValidTextNode(marker.previousSibling)) {\n            container = marker.previousSibling;\n            offset = marker.previousSibling.data.length;\n          } else {\n            container = markerParent;\n            offset = dom.nodeIndex(marker) + 1;\n          }\n        }\n      } else {\n        if (!keep) {\n          container = markerParent;\n          offset = dom.nodeIndex(marker);\n        } else {\n          if (marker.hasChildNodes()) {\n            container = marker.firstChild;\n            offset = 1;\n          } else if (isValidTextNode(marker.previousSibling)) {\n            container = marker.previousSibling;\n            offset = marker.previousSibling.data.length;\n          } else {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          }\n        }\n      }\n\n      if (!keep) {\n        const prev = marker.previousSibling;\n        const next = marker.nextSibling;\n        Tools.each(Tools.grep(marker.childNodes), node => {\n          if (isText$a(node)) {\n            node.data = node.data.replace(/\\uFEFF/g, '');\n          }\n        });\n        let otherMarker;\n\n        while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n          dom.remove(otherMarker, true);\n        }\n\n        if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {\n          const idx = prev.data.length;\n          prev.appendData(next.data);\n          dom.remove(next);\n          container = prev;\n          offset = idx;\n        }\n      }\n\n      return Optional.some(CaretPosition(container, offset));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const resolvePaths = (dom, bookmark) => {\n    const range = dom.createRng();\n\n    if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n      return Optional.some({\n        range,\n        forward: isForwardBookmark(bookmark)\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const resolveId = (dom, bookmark) => {\n    const startPos = restoreEndPoint(dom, 'start', bookmark);\n    const endPos = restoreEndPoint(dom, 'end', bookmark);\n    return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n      const range = dom.createRng();\n      range.setStart(addBogus(dom, spos.container()), spos.offset());\n      range.setEnd(addBogus(dom, epos.container()), epos.offset());\n      return {\n        range,\n        forward: isForwardBookmark(bookmark)\n      };\n    });\n  };\n\n  const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n    const range = dom.createRng();\n    range.selectNode(elm);\n    return {\n      range,\n      forward: true\n    };\n  });\n\n  const resolve = (selection, bookmark) => {\n    const dom = selection.dom;\n\n    if (bookmark) {\n      if (isPathBookmark(bookmark)) {\n        return resolvePaths(dom, bookmark);\n      } else if (isStringPathBookmark(bookmark)) {\n        return resolveCaretPositionBookmark(dom, bookmark);\n      } else if (isIdBookmark(bookmark)) {\n        return resolveId(dom, bookmark);\n      } else if (isIndexBookmark(bookmark)) {\n        return resolveIndex(dom, bookmark);\n      } else if (isRangeBookmark(bookmark)) {\n        return Optional.some({\n          range: bookmark.rng,\n          forward: isForwardBookmark(bookmark)\n        });\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const getBookmark$1 = (selection, type, normalized) => {\n    return getBookmark$2(selection, type, normalized);\n  };\n\n  const moveToBookmark = (selection, bookmark) => {\n    resolve(selection, bookmark).each(({\n      range,\n      forward\n    }) => {\n      selection.setRng(range, forward);\n    });\n  };\n\n  const isBookmarkNode$1 = node => {\n    return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n  };\n\n  const is = expected => actual => expected === actual;\n\n  const isNbsp = is(nbsp);\n\n  const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n  const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n\n  const getRanges$1 = selection => {\n    const ranges = [];\n\n    if (selection) {\n      for (let i = 0; i < selection.rangeCount; i++) {\n        ranges.push(selection.getRangeAt(i));\n      }\n    }\n\n    return ranges;\n  };\n\n  const getSelectedNodes = ranges => {\n    return bind$3(ranges, range => {\n      const node = getSelectedNode(range);\n      return node ? [SugarElement.fromDom(node)] : [];\n    });\n  };\n\n  const hasMultipleRanges = selection => {\n    return getRanges$1(selection).length > 1;\n  };\n\n  const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n\n  const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n\n  const getCellsFromElementOrRanges = (ranges, element) => {\n    const selectedCells = getCellsFromElement(element);\n    return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n  };\n\n  const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n\n  const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n\n  const getStartNode = rng => {\n    const sc = rng.startContainer,\n          so = rng.startOffset;\n\n    if (isText$a(sc)) {\n      return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n    } else {\n      return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n    }\n  };\n\n  const getEndNode = rng => {\n    const ec = rng.endContainer,\n          eo = rng.endOffset;\n\n    if (isText$a(ec)) {\n      return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n    } else {\n      return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n    }\n  };\n\n  const getFirstChildren = node => {\n    return firstChild(node).fold(constant([node]), child => {\n      return [node].concat(getFirstChildren(child));\n    });\n  };\n\n  const getLastChildren = node => {\n    return lastChild(node).fold(constant([node]), child => {\n      if (name(child) === 'br') {\n        return prevSibling(child).map(sibling => {\n          return [node].concat(getLastChildren(sibling));\n        }).getOr([]);\n      } else {\n        return [node].concat(getLastChildren(child));\n      }\n    });\n  };\n\n  const hasAllContentsSelected = (elm, rng) => {\n    return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n      const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n      const end = find$2(getLastChildren(elm), curry(eq, endNode));\n      return start.isSome() && end.isSome();\n    }).getOr(false);\n  };\n\n  const moveEndPoint = (dom, rng, node, start) => {\n    const root = node;\n    const walker = new DomTreeWalker(node, root);\n    const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2(['td', 'th', 'table'], name.toLowerCase()));\n    let currentNode = node;\n\n    do {\n      if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n        if (start) {\n          rng.setStart(currentNode, 0);\n        } else {\n          rng.setEnd(currentNode, currentNode.data.length);\n        }\n\n        return;\n      }\n\n      if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n        if (start) {\n          rng.setStartBefore(currentNode);\n        } else {\n          if (currentNode.nodeName === 'BR') {\n            rng.setEndBefore(currentNode);\n          } else {\n            rng.setEndAfter(currentNode);\n          }\n        }\n\n        return;\n      }\n    } while (currentNode = start ? walker.next() : walker.prev());\n\n    if (root.nodeName === 'BODY') {\n      if (start) {\n        rng.setStart(root, 0);\n      } else {\n        rng.setEnd(root, root.childNodes.length);\n      }\n    }\n  };\n\n  const hasAnyRanges = editor => {\n    const sel = editor.selection.getSel();\n    return isNonNullable(sel) && sel.rangeCount > 0;\n  };\n\n  const runOnRanges = (editor, executor) => {\n    const fakeSelectionNodes = getCellsFromEditor(editor);\n\n    if (fakeSelectionNodes.length > 0) {\n      each$e(fakeSelectionNodes, elem => {\n        const node = elem.dom;\n        const fakeNodeRng = editor.dom.createRng();\n        fakeNodeRng.setStartBefore(node);\n        fakeNodeRng.setEndAfter(node);\n        executor(fakeNodeRng, true);\n      });\n    } else {\n      executor(editor.selection.getRng(), false);\n    }\n  };\n\n  const preserve = (selection, fillBookmark, executor) => {\n    const bookmark = getPersistentBookmark(selection, fillBookmark);\n    executor(bookmark);\n    selection.moveToBookmark(bookmark);\n  };\n\n  const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n\n  const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n\n  const isElementDirectlySelected = (dom, node) => {\n    if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n      const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n      const value = parseInt(selectedAttr, 10);\n      return !isNaN(value) && value > 0;\n    } else {\n      return false;\n    }\n  };\n\n  const preserveSelection = (editor, action, shouldMoveStart) => {\n    const {\n      selection,\n      dom\n    } = editor;\n    const selectedNodeBeforeAction = selection.getNode();\n    const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n    preserve(selection, true, () => {\n      action();\n    });\n    const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n\n    if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n      editor.selection.select(selectedNodeBeforeAction);\n    } else if (shouldMoveStart(selection.getStart())) {\n      moveStartToNearestText(dom, selection);\n    }\n  };\n\n  const moveStartToNearestText = (dom, selection) => {\n    var _a, _b;\n\n    const rng = selection.getRng();\n    const {\n      startContainer,\n      startOffset\n    } = rng;\n    const selectedNode = selection.getNode();\n\n    if (isElementDirectlySelected(dom, selectedNode)) {\n      return;\n    }\n\n    if (isElement$6(startContainer)) {\n      const nodes = startContainer.childNodes;\n      const root = dom.getRoot();\n      let walker;\n\n      if (startOffset < nodes.length) {\n        const startNode = nodes[startOffset];\n        walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n      } else {\n        const startNode = nodes[nodes.length - 1];\n        walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n        walker.next(true);\n      }\n\n      for (let node = walker.current(); node; node = walker.next()) {\n        if (dom.getContentEditable(node) === 'false') {\n          return;\n        } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {\n          rng.setStart(node, 0);\n          selection.setRng(rng);\n          return;\n        }\n      }\n    }\n  };\n\n  const getNonWhiteSpaceSibling = (node, next, inc) => {\n    if (node) {\n      const nextName = next ? 'nextSibling' : 'previousSibling';\n\n      for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n        if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n          return node;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n\n  const isValid = (ed, parent, child) => {\n    return ed.schema.isValidChild(parent, child);\n  };\n\n  const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n    if (isNonNullable(node) && isText$a(node)) {\n      const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n      return isWhitespaceText(data);\n    } else {\n      return false;\n    }\n  };\n\n  const isEmptyTextNode$1 = node => {\n    return isNonNullable(node) && isText$a(node) && node.length === 0;\n  };\n\n  const isWrapNoneditableTarget = (editor, node) => {\n    const baseDataSelector = '[data-mce-cef-wrappable]';\n    const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n    const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${baseDataSelector},${formatNoneditableSelector}`;\n    return is$1(SugarElement.fromDom(node), selector);\n  };\n\n  const isWrappableNoneditable = (editor, node) => {\n    const dom = editor.dom;\n    return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n  };\n\n  const replaceVars = (value, vars) => {\n    if (isFunction(value)) {\n      return value(vars);\n    } else if (isNonNullable(vars)) {\n      value = value.replace(/%(\\w+)/g, (str, name) => {\n        return vars[name] || str;\n      });\n    }\n\n    return value;\n  };\n\n  const isEq$5 = (str1, str2) => {\n    str1 = str1 || '';\n    str2 = str2 || '';\n    str1 = '' + (str1.nodeName || str1);\n    str2 = '' + (str2.nodeName || str2);\n    return str1.toLowerCase() === str2.toLowerCase();\n  };\n\n  const normalizeStyleValue = (value, name) => {\n    if (isNullable(value)) {\n      return null;\n    } else {\n      let strValue = String(value);\n\n      if (name === 'color' || name === 'backgroundColor') {\n        strValue = rgbaToHexString(strValue);\n      }\n\n      if (name === 'fontWeight' && value === 700) {\n        strValue = 'bold';\n      }\n\n      if (name === 'fontFamily') {\n        strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n      }\n\n      return strValue;\n    }\n  };\n\n  const getStyle = (dom, node, name) => {\n    const style = dom.getStyle(node, name);\n    return normalizeStyleValue(style, name);\n  };\n\n  const getTextDecoration = (dom, node) => {\n    let decoration;\n    dom.getParent(node, n => {\n      if (isElement$6(n)) {\n        decoration = dom.getStyle(n, 'text-decoration');\n        return !!decoration && decoration !== 'none';\n      } else {\n        return false;\n      }\n    });\n    return decoration;\n  };\n\n  const getParents$2 = (dom, node, selector) => {\n    return dom.getParents(node, selector, dom.getRoot());\n  };\n\n  const isFormatPredicate = (editor, formatName, predicate) => {\n    const formats = editor.formatter.get(formatName);\n    return isNonNullable(formats) && exists(formats, predicate);\n  };\n\n  const isVariableFormatName = (editor, formatName) => {\n    const hasVariableValues = format => {\n      const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n\n      return exists(['styles', 'attributes'], key => get$a(format, key).exists(field => {\n        const fieldValues = isArray$1(field) ? field : values(field);\n        return exists(fieldValues, isVariableValue);\n      }));\n    };\n\n    return isFormatPredicate(editor, formatName, hasVariableValues);\n  };\n\n  const areSimilarFormats = (editor, formatName, otherFormatName) => {\n    const validKeys = ['inline', 'block', 'selector', 'attributes', 'styles', 'classes'];\n\n    const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n\n    return isFormatPredicate(editor, formatName, fmt1 => {\n      const filteredFmt1 = filterObj(fmt1);\n      return isFormatPredicate(editor, otherFormatName, fmt2 => {\n        const filteredFmt2 = filterObj(fmt2);\n        return equal$1(filteredFmt1, filteredFmt2);\n      });\n    });\n  };\n\n  const isBlockFormat = format => hasNonNullableKey(format, 'block');\n\n  const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n\n  const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n\n  const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n\n  const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n\n  const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n\n  const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n\n  const getEmptyCaretContainers = node => {\n    const nodes = [];\n    let tempNode = node;\n\n    while (tempNode) {\n      if (isText$a(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n        return [];\n      }\n\n      if (isElement$6(tempNode)) {\n        nodes.push(tempNode);\n      }\n\n      tempNode = tempNode.firstChild;\n    }\n\n    return nodes;\n  };\n\n  const isCaretContainerEmpty = node => {\n    return getEmptyCaretContainers(node).length > 0;\n  };\n\n  const isEmptyCaretFormatElement = element => {\n    return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n  };\n\n  const isBookmarkNode = isBookmarkNode$1;\n  const getParents$1 = getParents$2;\n  const isWhiteSpaceNode = isWhiteSpaceNode$1;\n  const isTextBlock = isTextBlock$1;\n\n  const isBogusBr = node => {\n    return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n  };\n\n  const findParentContentEditable = (dom, node) => {\n    let parent = node;\n\n    while (parent) {\n      if (isElement$6(parent) && dom.getContentEditable(parent)) {\n        return dom.getContentEditable(parent) === 'false' ? parent : node;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return node;\n  };\n\n  const walkText = (start, node, offset, predicate) => {\n    const str = node.data;\n\n    if (start) {\n      for (let i = offset; i > 0; i--) {\n        if (predicate(str.charAt(i - 1))) {\n          return i;\n        }\n      }\n    } else {\n      for (let i = offset; i < str.length; i++) {\n        if (predicate(str.charAt(i))) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n\n  const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n\n  const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n    let lastTextNode;\n    const rootNode = dom.getParent(container, dom.isBlock) || body;\n\n    const walk = (container, offset, pred) => {\n      const textSeeker = TextSeeker(dom);\n      const walker = start ? textSeeker.backwards : textSeeker.forwards;\n      return Optional.from(walker(container, offset, (text, textOffset) => {\n        if (isBookmarkNode(text.parentNode)) {\n          return -1;\n        } else {\n          lastTextNode = text;\n          return pred(start, text, textOffset);\n        }\n      }, rootNode));\n    };\n\n    const spaceResult = walk(container, offset, findSpace);\n    return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n      container: lastTextNode,\n      offset: start ? 0 : lastTextNode.length\n    }) : Optional.none());\n  };\n\n  const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n    const sibling = container[siblingName];\n\n    if (isText$a(container) && isEmpty$3(container.data) && sibling) {\n      container = sibling;\n    }\n\n    const parents = getParents$1(dom, container);\n\n    for (let i = 0; i < parents.length; i++) {\n      for (let y = 0; y < formatList.length; y++) {\n        const curFormat = formatList[y];\n\n        if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n          continue;\n        }\n\n        if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n          return parents[i];\n        }\n      }\n    }\n\n    return container;\n  };\n\n  const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n    var _a;\n\n    let node = container;\n    const root = dom.getRoot();\n    const format = formatList[0];\n\n    if (isBlockFormat(format)) {\n      node = format.wrapper ? null : dom.getParent(container, format.block, root);\n    }\n\n    if (!node) {\n      const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n      node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n    }\n\n    if (node && isBlockFormat(format) && format.wrapper) {\n      node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n    }\n\n    if (!node) {\n      node = container;\n\n      while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n        node = node[siblingName];\n\n        if (isEq$5(node, 'br')) {\n          break;\n        }\n      }\n    }\n\n    return node || container;\n  };\n\n  const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n    const parent = container.parentNode;\n\n    if (isNonNullable(container[siblingName])) {\n      return false;\n    } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n      return true;\n    } else {\n      return isAtBlockBoundary$1(dom, root, parent, siblingName);\n    }\n  };\n\n  const findParentContainer = (dom, formatList, container, offset, start) => {\n    let parent = container;\n    const siblingName = start ? 'previousSibling' : 'nextSibling';\n    const root = dom.getRoot();\n\n    if (isText$a(container) && !isWhiteSpaceNode(container)) {\n      if (start ? offset > 0 : offset < container.data.length) {\n        return container;\n      }\n    }\n\n    while (parent) {\n      if (!formatList[0].block_expand && dom.isBlock(parent)) {\n        return parent;\n      }\n\n      for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n        const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n\n        if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n          return parent;\n        }\n      }\n\n      if (parent === root || parent.parentNode === root) {\n        container = parent;\n        break;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return container;\n  };\n\n  const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n\n  const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n    let {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    } = rng;\n    const format = formatList[0];\n\n    if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n      startContainer = getNode$1(startContainer, startOffset);\n\n      if (isText$a(startContainer)) {\n        startOffset = 0;\n      }\n    }\n\n    if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n      endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n\n      if (isText$a(endContainer)) {\n        endOffset = endContainer.data.length;\n      }\n    }\n\n    startContainer = findParentContentEditable(dom, startContainer);\n    endContainer = findParentContentEditable(dom, endContainer);\n\n    if (isSelfOrParentBookmark(startContainer)) {\n      startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n\n      if (rng.collapsed) {\n        startContainer = startContainer.previousSibling || startContainer;\n      } else {\n        startContainer = startContainer.nextSibling || startContainer;\n      }\n\n      if (isText$a(startContainer)) {\n        startOffset = rng.collapsed ? startContainer.length : 0;\n      }\n    }\n\n    if (isSelfOrParentBookmark(endContainer)) {\n      endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n\n      if (rng.collapsed) {\n        endContainer = endContainer.nextSibling || endContainer;\n      } else {\n        endContainer = endContainer.previousSibling || endContainer;\n      }\n\n      if (isText$a(endContainer)) {\n        endOffset = rng.collapsed ? 0 : endContainer.length;\n      }\n    }\n\n    if (rng.collapsed) {\n      const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n      startPoint.each(({\n        container,\n        offset\n      }) => {\n        startContainer = container;\n        startOffset = offset;\n      });\n      const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n      endPoint.each(({\n        container,\n        offset\n      }) => {\n        endContainer = container;\n        endOffset = offset;\n      });\n    }\n\n    if (isInlineFormat(format) || format.block_expand) {\n      if (!isInlineFormat(format) || !isText$a(startContainer) || startOffset === 0) {\n        startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n      }\n\n      if (!isInlineFormat(format) || !isText$a(endContainer) || endOffset === endContainer.data.length) {\n        endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n      }\n    }\n\n    if (shouldExpandToSelector(format)) {\n      startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n      endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n    }\n\n    if (isBlockFormat(format) || isSelectorFormat(format)) {\n      startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n      endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n\n      if (isBlockFormat(format)) {\n        if (!dom.isBlock(startContainer)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n\n        if (!dom.isBlock(endContainer)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n    }\n\n    if (isElement$6(startContainer) && startContainer.parentNode) {\n      startOffset = dom.nodeIndex(startContainer);\n      startContainer = startContainer.parentNode;\n    }\n\n    if (isElement$6(endContainer) && endContainer.parentNode) {\n      endOffset = dom.nodeIndex(endContainer) + 1;\n      endContainer = endContainer.parentNode;\n    }\n\n    return {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    };\n  };\n\n  const walk$3 = (dom, rng, callback) => {\n    var _a;\n\n    const startOffset = rng.startOffset;\n    const startContainer = getNode$1(rng.startContainer, startOffset);\n    const endOffset = rng.endOffset;\n    const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n\n    const exclude = nodes => {\n      const firstNode = nodes[0];\n\n      if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n        nodes.splice(0, 1);\n      }\n\n      const lastNode = nodes[nodes.length - 1];\n\n      if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {\n        nodes.splice(nodes.length - 1, 1);\n      }\n\n      return nodes;\n    };\n\n    const collectSiblings = (node, name, endNode) => {\n      const siblings = [];\n\n      for (; node && node !== endNode; node = node[name]) {\n        siblings.push(node);\n      }\n\n      return siblings;\n    };\n\n    const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n\n    const walkBoundary = (startNode, endNode, next) => {\n      const siblingName = next ? 'nextSibling' : 'previousSibling';\n\n      for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n        parent = node.parentNode;\n        const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n\n        if (siblings.length) {\n          if (!next) {\n            siblings.reverse();\n          }\n\n          callback(exclude(siblings));\n        }\n      }\n    };\n\n    if (startContainer === endContainer) {\n      return callback(exclude([startContainer]));\n    }\n\n    const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n\n    if (dom.isChildOf(startContainer, endContainer)) {\n      return walkBoundary(startContainer, ancestor, true);\n    }\n\n    if (dom.isChildOf(endContainer, startContainer)) {\n      return walkBoundary(endContainer, ancestor);\n    }\n\n    const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n    const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n    walkBoundary(startContainer, startPoint, true);\n    const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n\n    if (siblings.length) {\n      callback(exclude(siblings));\n    }\n\n    walkBoundary(endContainer, endPoint);\n  };\n\n  const validBlocks = ['pre[class*=language-][contenteditable=\"false\"]', 'figure.image', 'div[data-ephox-embed-iri]', 'div.tiny-pageembed', 'div.mce-toc', 'div[data-mce-toc]'];\n\n  const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;\n\n  const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n    if (nodeName === 'br' || isZeroWidth(elem)) {\n      return 'valid';\n    } else if (isAnnotation(elem)) {\n      return 'existing';\n    } else if (isCaretNode(elem.dom)) {\n      return 'caret';\n    } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n      return 'valid-block';\n    } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n      return 'invalid-child';\n    } else {\n      return 'valid';\n    }\n  });\n\n  const applyWordGrab = (editor, rng) => {\n    const r = expandRng(editor.dom, rng, [{\n      inline: 'span'\n    }]);\n    rng.setStart(r.startContainer, r.startOffset);\n    rng.setEnd(r.endContainer, r.endOffset);\n    editor.selection.setRng(rng);\n  };\n\n  const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n    const {\n      uid = masterUId,\n      ...otherData\n    } = data;\n    add$2(elem, annotation());\n    set$3(elem, `${dataAnnotationId()}`, uid);\n    set$3(elem, `${dataAnnotation()}`, annotationName);\n    const {\n      attributes = {},\n      classes = []\n    } = decorate(uid, otherData);\n    setAll$1(elem, attributes);\n    add(elem, classes);\n\n    if (directAnnotation) {\n      if (classes.length > 0) {\n        set$3(elem, `${dataAnnotationClasses()}`, classes.join(','));\n      }\n\n      const attributeNames = keys(attributes);\n\n      if (attributeNames.length > 0) {\n        set$3(elem, `${dataAnnotationAttributes()}`, attributeNames.join(','));\n      }\n    }\n  };\n\n  const removeDirectAnnotation = elem => {\n    remove$7(elem, annotation());\n    remove$a(elem, `${dataAnnotationId()}`);\n    remove$a(elem, `${dataAnnotation()}`);\n    remove$a(elem, `${dataAnnotationActive()}`);\n    const customAttrNames = getOpt(elem, `${dataAnnotationAttributes()}`).map(names => names.split(',')).getOr([]);\n    const customClasses = getOpt(elem, `${dataAnnotationClasses()}`).map(names => names.split(',')).getOr([]);\n    each$e(customAttrNames, name => remove$a(elem, name));\n    remove$4(elem, customClasses);\n    remove$a(elem, `${dataAnnotationClasses()}`);\n    remove$a(elem, `${dataAnnotationAttributes()}`);\n  };\n\n  const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n    const master = SugarElement.fromTag('span', eDoc);\n    applyAnnotation(master, uid, data, annotationName, decorate, false);\n    return master;\n  };\n\n  const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n    const newWrappers = [];\n    const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n    const wrapper = value$2();\n\n    const finishWrapper = () => {\n      wrapper.clear();\n    };\n\n    const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n      const nu = shallow$1(master);\n      newWrappers.push(nu);\n      wrapper.set(nu);\n      return nu;\n    });\n\n    const processElements = elems => {\n      each$e(elems, processElement);\n    };\n\n    const processElement = elem => {\n      const ctx = context(editor, elem, 'span', name(elem));\n\n      switch (ctx) {\n        case 'invalid-child':\n          {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n\n        case 'valid-block':\n          {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n\n        case 'valid':\n          {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n      }\n    };\n\n    const processNodes = nodes => {\n      const elems = map$3(nodes, SugarElement.fromDom);\n      processElements(elems);\n    };\n\n    walk$3(editor.dom, rng, nodes => {\n      finishWrapper();\n      processNodes(nodes);\n    });\n    return newWrappers;\n  };\n\n  const annotateWithBookmark = (editor, name, settings, data) => {\n    editor.undoManager.transact(() => {\n      const selection = editor.selection;\n      const initialRng = selection.getRng();\n      const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n      const masterUid = generate$1('mce-annotation');\n\n      if (initialRng.collapsed && !hasFakeSelection) {\n        applyWordGrab(editor, initialRng);\n      }\n\n      if (selection.getRng().collapsed && !hasFakeSelection) {\n        const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n        set$1(wrapper, nbsp);\n        selection.getRng().insertNode(wrapper.dom);\n        selection.select(wrapper.dom);\n      } else {\n        preserve(selection, false, () => {\n          runOnRanges(editor, selectionRng => {\n            annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n          });\n        });\n      }\n    });\n  };\n\n  const Annotator = editor => {\n    const registry = create$c();\n    setup$x(editor, registry);\n    const changes = setup$y(editor, registry);\n    const isSpan = isTag('span');\n\n    const removeAnnotations = elements => {\n      each$e(elements, element => {\n        if (isSpan(element)) {\n          unwrap(element);\n        } else {\n          removeDirectAnnotation(element);\n        }\n      });\n    };\n\n    return {\n      register: (name, settings) => {\n        registry.register(name, settings);\n      },\n      annotate: (name, data) => {\n        registry.lookup(name).each(settings => {\n          annotateWithBookmark(editor, name, settings, data);\n        });\n      },\n      annotationChanged: (name, callback) => {\n        changes.addListener(name, callback);\n      },\n      remove: name => {\n        identify(editor, Optional.some(name)).each(({\n          elements\n        }) => {\n          const bookmark = editor.selection.getBookmark();\n          removeAnnotations(elements);\n          editor.selection.moveToBookmark(bookmark);\n        });\n      },\n      removeAll: name => {\n        const bookmark = editor.selection.getBookmark();\n        each$d(findAll(editor, name), (elements, _) => {\n          removeAnnotations(elements);\n        });\n        editor.selection.moveToBookmark(bookmark);\n      },\n      getAll: name => {\n        const directory = findAll(editor, name);\n        return map$2(directory, elems => map$3(elems, elem => elem.dom));\n      }\n    };\n  };\n\n  const BookmarkManager = selection => {\n    return {\n      getBookmark: curry(getBookmark$1, selection),\n      moveToBookmark: curry(moveToBookmark, selection)\n    };\n  };\n\n  BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n  const isXYWithinRange = (clientX, clientY, range) => {\n    if (range.collapsed) {\n      return false;\n    } else {\n      return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n    }\n  };\n\n  const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n\n  const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n\n  const fireRemove = editor => {\n    editor.dispatch('remove');\n  };\n\n  const fireDetach = editor => {\n    editor.dispatch('detach');\n  };\n\n  const fireSwitchMode = (editor, mode) => {\n    editor.dispatch('SwitchMode', {\n      mode\n    });\n  };\n\n  const fireObjectResizeStart = (editor, target, width, height, origin) => {\n    editor.dispatch('ObjectResizeStart', {\n      target,\n      width,\n      height,\n      origin\n    });\n  };\n\n  const fireObjectResized = (editor, target, width, height, origin) => {\n    editor.dispatch('ObjectResized', {\n      target,\n      width,\n      height,\n      origin\n    });\n  };\n\n  const firePreInit = editor => {\n    editor.dispatch('PreInit');\n  };\n\n  const firePostRender = editor => {\n    editor.dispatch('PostRender');\n  };\n\n  const fireInit = editor => {\n    editor.dispatch('Init');\n  };\n\n  const firePlaceholderToggle = (editor, state) => {\n    editor.dispatch('PlaceholderToggle', {\n      state\n    });\n  };\n\n  const fireError = (editor, errorType, error) => {\n    editor.dispatch(errorType, error);\n  };\n\n  const fireFormatApply = (editor, format, node, vars) => {\n    editor.dispatch('FormatApply', {\n      format,\n      node,\n      vars\n    });\n  };\n\n  const fireFormatRemove = (editor, format, node, vars) => {\n    editor.dispatch('FormatRemove', {\n      format,\n      node,\n      vars\n    });\n  };\n\n  const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n\n  const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n\n  const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n\n  const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n\n  const fireAutocompleterStart = (editor, args) => {\n    editor.dispatch('AutocompleterStart', args);\n  };\n\n  const fireAutocompleterUpdate = (editor, args) => {\n    editor.dispatch('AutocompleterUpdate', args);\n  };\n\n  const fireAutocompleterEnd = editor => {\n    editor.dispatch('AutocompleterEnd');\n  };\n\n  const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n    content: html,\n    internal\n  });\n\n  const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n    node,\n    internal\n  });\n\n  const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', {\n    state\n  });\n\n  const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', {\n    state\n  });\n\n  const VK = {\n    BACKSPACE: 8,\n    DELETE: 46,\n    DOWN: 40,\n    ENTER: 13,\n    ESC: 27,\n    LEFT: 37,\n    RIGHT: 39,\n    SPACEBAR: 32,\n    TAB: 9,\n    UP: 38,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    END: 35,\n    HOME: 36,\n    modifierPressed: e => {\n      return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n    },\n    metaKeyPressed: e => {\n      return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n    }\n  };\n  const elementSelectionAttr = 'data-mce-selected';\n  const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n  const abs = Math.abs;\n  const round$1 = Math.round;\n  const resizeHandles = {\n    nw: [0, 0, -1, -1],\n    ne: [1, 0, 1, -1],\n    se: [1, 1, 1, 1],\n    sw: [0, 1, -1, 1]\n  };\n\n  const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n\n  const ControlSelection = (selection, editor) => {\n    const dom = editor.dom;\n    const editableDoc = editor.getDoc();\n    const rootDocument = document;\n    const rootElement = editor.getBody();\n    let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n    let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n    let width;\n    let height;\n    let startScrollWidth;\n    let startScrollHeight;\n\n    const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n\n    const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n\n    const isEventOnImageOutsideRange = (evt, range) => {\n      if (isTouchEvent(evt)) {\n        const touch = evt.touches[0];\n        return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n      } else {\n        return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n      }\n    };\n\n    const contextMenuSelectImage = evt => {\n      const target = evt.target;\n\n      if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n        editor.selection.select(target);\n      }\n    };\n\n    const getResizeTargets = elm => {\n      if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n        return [elm, elm.firstElementChild];\n      } else if (dom.is(elm, 'figure.image')) {\n        return [elm.querySelector('img')];\n      } else {\n        return [elm];\n      }\n    };\n\n    const isResizable = elm => {\n      const selector = getObjectResizing(editor);\n\n      if (!selector) {\n        return false;\n      }\n\n      if (elm.getAttribute('data-mce-resize') === 'false') {\n        return false;\n      }\n\n      if (elm === editor.getBody()) {\n        return false;\n      }\n\n      if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n        return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n      } else {\n        return is$1(SugarElement.fromDom(elm), selector);\n      }\n    };\n\n    const createGhostElement = elm => {\n      if (isMedia(elm)) {\n        return dom.create('img', {\n          src: Env.transparentSrc\n        });\n      } else {\n        return elm.cloneNode(true);\n      }\n    };\n\n    const setSizeProp = (element, name, value) => {\n      if (isNonNullable(value)) {\n        const targets = getResizeTargets(element);\n        each$e(targets, target => {\n          if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n            dom.setStyle(target, name, value);\n          } else {\n            dom.setAttrib(target, name, '' + value);\n          }\n        });\n      }\n    };\n\n    const setGhostElmSize = (ghostElm, width, height) => {\n      setSizeProp(ghostElm, 'width', width);\n      setSizeProp(ghostElm, 'height', height);\n    };\n\n    const resizeGhostElement = e => {\n      let deltaX, deltaY, proportional;\n      let resizeHelperX, resizeHelperY;\n      deltaX = e.screenX - startX;\n      deltaY = e.screenY - startY;\n      width = deltaX * selectedHandle[2] + startW;\n      height = deltaY * selectedHandle[3] + startH;\n      width = width < 5 ? 5 : width;\n      height = height < 5 ? 5 : height;\n\n      if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n        proportional = !VK.modifierPressed(e);\n      } else {\n        proportional = VK.modifierPressed(e);\n      }\n\n      if (proportional) {\n        if (abs(deltaX) > abs(deltaY)) {\n          height = round$1(width * ratio);\n          width = round$1(height / ratio);\n        } else {\n          width = round$1(height / ratio);\n          height = round$1(width * ratio);\n        }\n      }\n\n      setGhostElmSize(selectedElmGhost, width, height);\n      resizeHelperX = selectedHandle.startPos.x + deltaX;\n      resizeHelperY = selectedHandle.startPos.y + deltaY;\n      resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n      resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n      dom.setStyles(resizeHelper, {\n        left: resizeHelperX,\n        top: resizeHelperY,\n        display: 'block'\n      });\n      resizeHelper.innerHTML = width + ' &times; ' + height;\n\n      if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n        dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n      }\n\n      if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n        dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n      }\n\n      deltaX = rootElement.scrollWidth - startScrollWidth;\n      deltaY = rootElement.scrollHeight - startScrollHeight;\n\n      if (deltaX + deltaY !== 0) {\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX - deltaX,\n          top: resizeHelperY - deltaY\n        });\n      }\n\n      if (!resizeStarted) {\n        fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n        resizeStarted = true;\n      }\n    };\n\n    const endGhostResize = () => {\n      const wasResizeStarted = resizeStarted;\n      resizeStarted = false;\n\n      if (wasResizeStarted) {\n        setSizeProp(selectedElm, 'width', width);\n        setSizeProp(selectedElm, 'height', height);\n      }\n\n      dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n      dom.unbind(editableDoc, 'mouseup', endGhostResize);\n\n      if (rootDocument !== editableDoc) {\n        dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n        dom.unbind(rootDocument, 'mouseup', endGhostResize);\n      }\n\n      dom.remove(selectedElmGhost);\n      dom.remove(resizeHelper);\n      dom.remove(resizeBackdrop);\n      showResizeRect(selectedElm);\n\n      if (wasResizeStarted) {\n        fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n        dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n      }\n\n      editor.nodeChanged();\n    };\n\n    const showResizeRect = targetElm => {\n      unbindResizeHandleEvents();\n      const position = dom.getPos(targetElm, rootElement);\n      const selectedElmX = position.x;\n      const selectedElmY = position.y;\n      const rect = targetElm.getBoundingClientRect();\n      const targetWidth = rect.width || rect.right - rect.left;\n      const targetHeight = rect.height || rect.bottom - rect.top;\n\n      if (selectedElm !== targetElm) {\n        hideResizeRect();\n        selectedElm = targetElm;\n        width = height = 0;\n      }\n\n      const e = editor.dispatch('ObjectSelected', {\n        target: targetElm\n      });\n\n      if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n        each$d(resizeHandles, (handle, name) => {\n          const startDrag = e => {\n            const target = getResizeTargets(selectedElm)[0];\n            startX = e.screenX;\n            startY = e.screenY;\n            startW = target.clientWidth;\n            startH = target.clientHeight;\n            ratio = startH / startW;\n            selectedHandle = handle;\n            selectedHandle.name = name;\n            selectedHandle.startPos = {\n              x: targetWidth * handle[0] + selectedElmX,\n              y: targetHeight * handle[1] + selectedElmY\n            };\n            startScrollWidth = rootElement.scrollWidth;\n            startScrollHeight = rootElement.scrollHeight;\n            resizeBackdrop = dom.add(rootElement, 'div', {\n              'class': 'mce-resize-backdrop',\n              'data-mce-bogus': 'all'\n            });\n            dom.setStyles(resizeBackdrop, {\n              position: 'fixed',\n              left: '0',\n              top: '0',\n              width: '100%',\n              height: '100%'\n            });\n            selectedElmGhost = createGhostElement(selectedElm);\n            dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n            dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n            selectedElmGhost.contentEditable = 'false';\n            dom.setStyles(selectedElmGhost, {\n              left: selectedElmX,\n              top: selectedElmY,\n              margin: 0\n            });\n            setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n            selectedElmGhost.removeAttribute(elementSelectionAttr);\n            rootElement.appendChild(selectedElmGhost);\n            dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n            dom.bind(editableDoc, 'mouseup', endGhostResize);\n\n            if (rootDocument !== editableDoc) {\n              dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n              dom.bind(rootDocument, 'mouseup', endGhostResize);\n            }\n\n            resizeHelper = dom.add(rootElement, 'div', {\n              'class': 'mce-resize-helper',\n              'data-mce-bogus': 'all'\n            }, startW + ' &times; ' + startH);\n          };\n\n          let handleElm = dom.get('mceResizeHandle' + name);\n\n          if (handleElm) {\n            dom.remove(handleElm);\n          }\n\n          handleElm = dom.add(rootElement, 'div', {\n            'id': 'mceResizeHandle' + name,\n            'data-mce-bogus': 'all',\n            'class': 'mce-resizehandle',\n            'unselectable': true,\n            'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n          });\n          dom.bind(handleElm, 'mousedown', e => {\n            e.stopImmediatePropagation();\n            e.preventDefault();\n            startDrag(e);\n          });\n          handle.elm = handleElm;\n          dom.setStyles(handleElm, {\n            left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n            top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n          });\n        });\n      } else {\n        hideResizeRect(false);\n      }\n    };\n\n    const throttledShowResizeRect = first$1(showResizeRect, 0);\n\n    const hideResizeRect = (removeSelected = true) => {\n      throttledShowResizeRect.cancel();\n      unbindResizeHandleEvents();\n\n      if (selectedElm && removeSelected) {\n        selectedElm.removeAttribute(elementSelectionAttr);\n      }\n\n      each$d(resizeHandles, (value, name) => {\n        const handleElm = dom.get('mceResizeHandle' + name);\n\n        if (handleElm) {\n          dom.unbind(handleElm);\n          dom.remove(handleElm);\n        }\n      });\n    };\n\n    const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n\n    const updateResizeRect = e => {\n      if (resizeStarted || editor.removed || editor.composing) {\n        return;\n      }\n\n      const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n      const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n      const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n      each$e(dom.select(`img[${elementSelectionAttr}],hr[${elementSelectionAttr}]`), img => {\n        img.removeAttribute(elementSelectionAttr);\n      });\n\n      if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n        disableGeckoResize();\n        const startElm = selection.getStart(true);\n\n        if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n          dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n          throttledShowResizeRect.throttle(controlElm);\n          return;\n        }\n      }\n\n      hideResizeRect();\n    };\n\n    const unbindResizeHandleEvents = () => {\n      each$d(resizeHandles, handle => {\n        if (handle.elm) {\n          dom.unbind(handle.elm);\n          delete handle.elm;\n        }\n      });\n    };\n\n    const disableGeckoResize = () => {\n      try {\n        editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n      } catch (ex) {}\n    };\n\n    editor.on('init', () => {\n      disableGeckoResize();\n      editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n      editor.on('keyup compositionend', e => {\n        if (selectedElm && selectedElm.nodeName === 'TABLE') {\n          updateResizeRect(e);\n        }\n      });\n      editor.on('hide blur', hideResizeRect);\n      editor.on('contextmenu longpress', contextMenuSelectImage, true);\n    });\n    editor.on('remove', unbindResizeHandleEvents);\n\n    const destroy = () => {\n      throttledShowResizeRect.cancel();\n      selectedElm = selectedElmGhost = resizeBackdrop = null;\n    };\n\n    return {\n      isResizable,\n      showResizeRect,\n      hideResizeRect,\n      updateResizeRect,\n      destroy\n    };\n  };\n\n  const setStart = (rng, situ) => {\n    situ.fold(e => {\n      rng.setStartBefore(e.dom);\n    }, (e, o) => {\n      rng.setStart(e.dom, o);\n    }, e => {\n      rng.setStartAfter(e.dom);\n    });\n  };\n\n  const setFinish = (rng, situ) => {\n    situ.fold(e => {\n      rng.setEndBefore(e.dom);\n    }, (e, o) => {\n      rng.setEnd(e.dom, o);\n    }, e => {\n      rng.setEndAfter(e.dom);\n    });\n  };\n\n  const relativeToNative = (win, startSitu, finishSitu) => {\n    const range = win.document.createRange();\n    setStart(range, startSitu);\n    setFinish(range, finishSitu);\n    return range;\n  };\n\n  const exactToNative = (win, start, soffset, finish, foffset) => {\n    const rng = win.document.createRange();\n    rng.setStart(start.dom, soffset);\n    rng.setEnd(finish.dom, foffset);\n    return rng;\n  };\n\n  const adt$3 = Adt.generate([{\n    ltr: ['start', 'soffset', 'finish', 'foffset']\n  }, {\n    rtl: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n\n  const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n\n  const getRanges = (win, selection) => selection.match({\n    domRange: rng => {\n      return {\n        ltr: constant(rng),\n        rtl: Optional.none\n      };\n    },\n    relative: (startSitu, finishSitu) => {\n      return {\n        ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n        rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n      };\n    },\n    exact: (start, soffset, finish, foffset) => {\n      return {\n        ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n        rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n      };\n    }\n  });\n\n  const doDiagnose = (win, ranges) => {\n    const rng = ranges.ltr();\n\n    if (rng.collapsed) {\n      const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n      return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n    } else {\n      return fromRange(win, adt$3.ltr, rng);\n    }\n  };\n\n  const diagnose = (win, selection) => {\n    const ranges = getRanges(win, selection);\n    return doDiagnose(win, ranges);\n  };\n\n  adt$3.ltr;\n  adt$3.rtl;\n\n  const create$a = (start, soffset, finish, foffset) => ({\n    start,\n    soffset,\n    finish,\n    foffset\n  });\n\n  const SimRange = {\n    create: create$a\n  };\n\n  const caretPositionFromPoint = (doc, x, y) => {\n    var _a, _b;\n\n    return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n      if (pos.offsetNode === null) {\n        return Optional.none();\n      }\n\n      const r = doc.dom.createRange();\n      r.setStart(pos.offsetNode, pos.offset);\n      r.collapse();\n      return Optional.some(r);\n    });\n  };\n\n  const caretRangeFromPoint = (doc, x, y) => {\n    var _a, _b;\n\n    return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n  };\n\n  const availableSearch = (() => {\n    if (document.caretPositionFromPoint) {\n      return caretPositionFromPoint;\n    } else if (document.caretRangeFromPoint) {\n      return caretRangeFromPoint;\n    } else {\n      return Optional.none;\n    }\n  })();\n\n  const fromPoint$1 = (win, x, y) => {\n    const doc = SugarElement.fromDom(win.document);\n    return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n  };\n\n  const adt$2 = Adt.generate([{\n    before: ['element']\n  }, {\n    on: ['element', 'offset']\n  }, {\n    after: ['element']\n  }]);\n\n  const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n\n  const getStart$2 = situ => situ.fold(identity, identity, identity);\n\n  const before$1 = adt$2.before;\n  const on = adt$2.on;\n  const after$1 = adt$2.after;\n  const Situ = {\n    before: before$1,\n    on,\n    after: after$1,\n    cata,\n    getStart: getStart$2\n  };\n  const adt$1 = Adt.generate([{\n    domRange: ['rng']\n  }, {\n    relative: ['startSitu', 'finishSitu']\n  }, {\n    exact: ['start', 'soffset', 'finish', 'foffset']\n  }]);\n\n  const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n\n  const getStart$1 = selection => selection.match({\n    domRange: rng => SugarElement.fromDom(rng.startContainer),\n    relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n    exact: (start, _soffset, _finish, _foffset) => start\n  });\n\n  const domRange = adt$1.domRange;\n  const relative = adt$1.relative;\n  const exact = adt$1.exact;\n\n  const getWin = selection => {\n    const start = getStart$1(selection);\n    return defaultView(start);\n  };\n\n  const range = SimRange.create;\n  const SimSelection = {\n    domRange,\n    relative,\n    exact,\n    exactFromRange,\n    getWin,\n    range\n  };\n\n  const beforeSpecial = (element, offset) => {\n    const name$1 = name(element);\n\n    if ('input' === name$1) {\n      return Situ.after(element);\n    } else if (!contains$2(['br', 'img'], name$1)) {\n      return Situ.on(element, offset);\n    } else {\n      return offset === 0 ? Situ.before(element) : Situ.after(element);\n    }\n  };\n\n  const preprocessRelative = (startSitu, finishSitu) => {\n    const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n    const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n    return SimSelection.relative(start, finish);\n  };\n\n  const preprocessExact = (start, soffset, finish, foffset) => {\n    const startSitu = beforeSpecial(start, soffset);\n    const finishSitu = beforeSpecial(finish, foffset);\n    return SimSelection.relative(startSitu, finishSitu);\n  };\n\n  const preprocess = selection => selection.match({\n    domRange: rng => {\n      const start = SugarElement.fromDom(rng.startContainer);\n      const finish = SugarElement.fromDom(rng.endContainer);\n      return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n    },\n    relative: preprocessRelative,\n    exact: preprocessExact\n  });\n\n  const fromElements = (elements, scope) => {\n    const doc = scope || document;\n    const fragment = doc.createDocumentFragment();\n    each$e(elements, element => {\n      fragment.appendChild(element.dom);\n    });\n    return SugarElement.fromDom(fragment);\n  };\n\n  const toNative = selection => {\n    const win = SimSelection.getWin(selection).dom;\n\n    const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n\n    const filtered = preprocess(selection);\n    return diagnose(win, filtered).match({\n      ltr: getDomRange,\n      rtl: getDomRange\n    });\n  };\n\n  const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n  const fromPoint = (clientX, clientY, doc) => {\n    const win = defaultView(SugarElement.fromDom(doc));\n    return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n      const rng = doc.createRange();\n      rng.setStart(simRange.start.dom, simRange.soffset);\n      rng.setEnd(simRange.finish.dom, simRange.foffset);\n      return rng;\n    }).getOrUndefined();\n  };\n\n  const isEq$4 = (rng1, rng2) => {\n    return isNonNullable(rng1) && isNonNullable(rng2) && rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset && rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset;\n  };\n\n  const findParent = (node, rootNode, predicate) => {\n    let currentNode = node;\n\n    while (currentNode && currentNode !== rootNode) {\n      if (predicate(currentNode)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.parentNode;\n    }\n\n    return null;\n  };\n\n  const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n\n  const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n\n  const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n\n  const hasBrBeforeAfter = (dom, node, left) => {\n    const parentNode = node.parentNode;\n\n    if (parentNode) {\n      const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n      let currentNode;\n\n      while (currentNode = walker[left ? 'prev' : 'next']()) {\n        if (isBr$6(currentNode)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  const isPrevNode = (node, name) => {\n    var _a;\n\n    return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n  };\n\n  const hasContentEditableFalseParent = (root, node) => {\n    let currentNode = node;\n\n    while (currentNode && currentNode !== root) {\n      if (isContentEditableFalse$b(currentNode)) {\n        return true;\n      }\n\n      currentNode = currentNode.parentNode;\n    }\n\n    return false;\n  };\n\n  const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n    const body = dom.getRoot();\n    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n    const parentNode = startNode.parentNode;\n    let lastInlineElement;\n    let node;\n\n    if (!parentNode) {\n      return Optional.none();\n    }\n\n    const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n\n    if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n      return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n    }\n\n    const walker = new DomTreeWalker(startNode, parentBlockContainer);\n\n    while (node = walker[left ? 'prev' : 'next']()) {\n      if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n        return Optional.none();\n      }\n\n      if (isText$a(node) && node.data.length > 0) {\n        if (!hasParentWithName(node, body, 'A')) {\n          return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n        }\n\n        return Optional.none();\n      }\n\n      if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n        return Optional.none();\n      }\n\n      lastInlineElement = node;\n    }\n\n    if (isComment(lastInlineElement)) {\n      return Optional.none();\n    }\n\n    if (collapsed && lastInlineElement) {\n      return Optional.some(CaretPosition(lastInlineElement, 0));\n    }\n\n    return Optional.none();\n  };\n\n  const normalizeEndPoint = (dom, collapsed, start, rng) => {\n    const body = dom.getRoot();\n    let node;\n    let normalized = false;\n    let container = start ? rng.startContainer : rng.endContainer;\n    let offset = start ? rng.startOffset : rng.endOffset;\n    const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n    const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n    let directionLeft = start;\n\n    if (isCaretContainer$2(container)) {\n      return Optional.none();\n    }\n\n    if (isElement$6(container) && offset > container.childNodes.length - 1) {\n      directionLeft = false;\n    }\n\n    if (isDocument$1(container)) {\n      container = body;\n      offset = 0;\n    }\n\n    if (container === body) {\n      if (directionLeft) {\n        node = container.childNodes[offset > 0 ? offset - 1 : 0];\n\n        if (node) {\n          if (isCaretContainer$2(node)) {\n            return Optional.none();\n          }\n\n          if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n            return Optional.none();\n          }\n        }\n      }\n\n      if (container.hasChildNodes()) {\n        offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n        container = container.childNodes[offset];\n        offset = isText$a(container) && isAfterNode ? container.data.length : 0;\n\n        if (!collapsed && container === body.lastChild && isTable$2(container)) {\n          return Optional.none();\n        }\n\n        if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n          return Optional.none();\n        }\n\n        if (isDetails(container)) {\n          return Optional.none();\n        }\n\n        if (container.hasChildNodes() && !isTable$2(container)) {\n          node = container;\n          const walker = new DomTreeWalker(container, body);\n\n          do {\n            if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n              normalized = false;\n              break;\n            }\n\n            if (isText$a(node) && node.data.length > 0) {\n              offset = directionLeft ? 0 : node.data.length;\n              container = node;\n              normalized = true;\n              break;\n            }\n\n            if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n              offset = dom.nodeIndex(node);\n              container = node.parentNode;\n\n              if (!directionLeft) {\n                offset++;\n              }\n\n              normalized = true;\n              break;\n            }\n          } while (node = directionLeft ? walker.next() : walker.prev());\n        }\n      }\n    }\n\n    if (collapsed) {\n      if (isText$a(container) && offset === 0) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n\n      if (isElement$6(container)) {\n        node = container.childNodes[offset];\n\n        if (!node) {\n          node = container.childNodes[offset - 1];\n        }\n\n        if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n      }\n    }\n\n    if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {\n      findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n        container = pos.container();\n        offset = pos.offset();\n        normalized = true;\n      });\n    }\n\n    return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n  };\n\n  const normalize$2 = (dom, rng) => {\n    const collapsed = rng.collapsed,\n          normRng = rng.cloneRange();\n    const startPos = CaretPosition.fromRangeStart(rng);\n    normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n      if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n        normRng.setStart(pos.container(), pos.offset());\n      }\n    });\n\n    if (!collapsed) {\n      normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n        normRng.setEnd(pos.container(), pos.offset());\n      });\n    }\n\n    if (collapsed) {\n      normRng.collapse(true);\n    }\n\n    return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n  };\n\n  const splitText = (node, offset) => {\n    return node.splitText(offset);\n  };\n\n  const split = rng => {\n    let startContainer = rng.startContainer,\n        startOffset = rng.startOffset,\n        endContainer = rng.endContainer,\n        endOffset = rng.endOffset;\n\n    if (startContainer === endContainer && isText$a(startContainer)) {\n      if (startOffset > 0 && startOffset < startContainer.data.length) {\n        endContainer = splitText(startContainer, startOffset);\n        startContainer = endContainer.previousSibling;\n\n        if (endOffset > startOffset) {\n          endOffset = endOffset - startOffset;\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          startContainer = endContainer = newContainer;\n          endOffset = newContainer.data.length;\n          startOffset = 0;\n        } else {\n          endOffset = 0;\n        }\n      }\n    } else {\n      if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n        startContainer = splitText(startContainer, startOffset);\n        startOffset = 0;\n      }\n\n      if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n        const newContainer = splitText(endContainer, endOffset).previousSibling;\n        endContainer = newContainer;\n        endOffset = newContainer.data.length;\n      }\n    }\n\n    return {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    };\n  };\n\n  const RangeUtils = dom => {\n    const walk = (rng, callback) => {\n      return walk$3(dom, rng, callback);\n    };\n\n    const split$1 = split;\n\n    const normalize = rng => {\n      return normalize$2(dom, rng).fold(never, normalizedRng => {\n        rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n        rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n        return true;\n      });\n    };\n\n    const expand = (rng, options = {\n      type: 'word'\n    }) => {\n      if (options.type === 'word') {\n        const rangeLike = expandRng(dom, rng, [{\n          inline: 'span'\n        }]);\n        const newRange = dom.createRng();\n        newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n        newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n        return newRange;\n      }\n\n      return rng;\n    };\n\n    return {\n      walk,\n      split: split$1,\n      expand,\n      normalize\n    };\n  };\n\n  RangeUtils.compareRanges = isEq$4;\n  RangeUtils.getCaretRangeFromPoint = fromPoint;\n  RangeUtils.getSelectedNode = getSelectedNode;\n  RangeUtils.getNode = getNode$1;\n\n  const Dimension = (name, getOffset) => {\n    const set = (element, h) => {\n      if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n        throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n      }\n\n      const dom = element.dom;\n\n      if (isSupported(dom)) {\n        dom.style[name] = h + 'px';\n      }\n    };\n\n    const get = element => {\n      const r = getOffset(element);\n\n      if (r <= 0 || r === null) {\n        const css = get$7(element, name);\n        return parseFloat(css) || 0;\n      }\n\n      return r;\n    };\n\n    const getOuter = get;\n\n    const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n      const val = get$7(element, property);\n      const value = val === undefined ? 0 : parseInt(val, 10);\n      return isNaN(value) ? acc : acc + value;\n    }, 0);\n\n    const max = (element, value, properties) => {\n      const cumulativeInclusions = aggregate(element, properties);\n      const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n      return absoluteMax;\n    };\n\n    return {\n      set,\n      get,\n      getOuter,\n      aggregate,\n      max\n    };\n  };\n\n  const api = Dimension('height', element => {\n    const dom = element.dom;\n    return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n  });\n\n  const get$2 = element => api.get(element);\n\n  const getDocument = () => SugarElement.fromDom(document);\n\n  const walkUp = (navigation, doc) => {\n    const frame = navigation.view(doc);\n    return frame.fold(constant([]), f => {\n      const parent = navigation.owner(f);\n      const rest = walkUp(navigation, parent);\n      return [f].concat(rest);\n    });\n  };\n\n  const pathTo = (element, navigation) => {\n    const d = navigation.owner(element);\n    return walkUp(navigation, d);\n  };\n\n  const view = doc => {\n    var _a;\n\n    const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n    return element.map(SugarElement.fromDom);\n  };\n\n  const owner = element => documentOrOwner(element);\n\n  var Navigation = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    view: view,\n    owner: owner\n  });\n\n  const find = element => {\n    const doc = getDocument();\n    const scroll = get$5(doc);\n    const frames = pathTo(element, Navigation);\n    const offset = viewport(element);\n    const r = foldr(frames, (b, a) => {\n      const loc = viewport(a);\n      return {\n        left: b.left + loc.left,\n        top: b.top + loc.top\n      };\n    }, {\n      left: 0,\n      top: 0\n    });\n    return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n  };\n\n  const excludeFromDescend = element => name(element) === 'textarea';\n\n  const fireScrollIntoViewEvent = (editor, data) => {\n    const scrollEvent = editor.dispatch('ScrollIntoView', data);\n    return scrollEvent.isDefaultPrevented();\n  };\n\n  const fireAfterScrollIntoViewEvent = (editor, data) => {\n    editor.dispatch('AfterScrollIntoView', data);\n  };\n\n  const descend = (element, offset) => {\n    const children = children$1(element);\n\n    if (children.length === 0 || excludeFromDescend(element)) {\n      return {\n        element,\n        offset\n      };\n    } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n      return {\n        element: children[offset],\n        offset: 0\n      };\n    } else {\n      const last = children[children.length - 1];\n\n      if (excludeFromDescend(last)) {\n        return {\n          element,\n          offset\n        };\n      } else {\n        if (name(last) === 'img') {\n          return {\n            element: last,\n            offset: 1\n          };\n        } else if (isText$b(last)) {\n          return {\n            element: last,\n            offset: get$3(last).length\n          };\n        } else {\n          return {\n            element: last,\n            offset: children$1(last).length\n          };\n        }\n      }\n    }\n  };\n\n  const markerInfo = (element, cleanupFun) => {\n    const pos = absolute(element);\n    const height = get$2(element);\n    return {\n      element,\n      bottom: pos.top + height,\n      height,\n      pos,\n      cleanup: cleanupFun\n    };\n  };\n\n  const createMarker$1 = (element, offset) => {\n    const startPoint = descend(element, offset);\n    const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n    before$3(startPoint.element, span);\n    return markerInfo(span, () => remove$5(span));\n  };\n\n  const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n\n  const withMarker = (editor, f, rng, alignToTop) => {\n    preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n  };\n\n  const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n    const data = {\n      elm: marker.element.dom,\n      alignToTop\n    };\n\n    if (fireScrollIntoViewEvent(editor, data)) {\n      return;\n    }\n\n    const scrollTop = get$5(doc).top;\n    f(editor, doc, scrollTop, marker, alignToTop);\n    fireAfterScrollIntoViewEvent(editor, data);\n  };\n\n  const applyWithMarker = (editor, f, rng, alignToTop) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const doc = SugarElement.fromDom(editor.getDoc());\n    reflow(body);\n    const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n    withScrollEvents(editor, doc, f, marker, alignToTop);\n    marker.cleanup();\n  };\n\n  const withElement = (editor, element, f, alignToTop) => {\n    const doc = SugarElement.fromDom(editor.getDoc());\n    withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n  };\n\n  const preserveWith = (editor, f, rng) => {\n    const startElement = rng.startContainer;\n    const startOffset = rng.startOffset;\n    const endElement = rng.endContainer;\n    const endOffset = rng.endOffset;\n    f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n    const newRng = editor.dom.createRng();\n    newRng.setStart(startElement, startOffset);\n    newRng.setEnd(endElement, endOffset);\n    editor.selection.setRng(rng);\n  };\n\n  const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n    const pos = marker.pos;\n\n    if (alignToTop) {\n      to(pos.left, pos.top, doc);\n    } else {\n      const y = pos.top - viewHeight + marker.height;\n      to(-editor.getBody().getBoundingClientRect().left, y, doc);\n    }\n  };\n\n  const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n    const viewportBottom = viewHeight + scrollTop;\n    const markerTop = marker.pos.top;\n    const markerBottom = marker.bottom;\n    const largerThanViewport = markerBottom - markerTop >= viewHeight;\n\n    if (markerTop < scrollTop) {\n      scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n    } else if (markerTop > viewportBottom) {\n      const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n      scrollToMarker(editor, marker, viewHeight, align, doc);\n    } else if (markerBottom > viewportBottom && !largerThanViewport) {\n      scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n    }\n  };\n\n  const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n    const viewHeight = defaultView(doc).dom.innerHeight;\n    intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n  };\n\n  const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n    const frameViewHeight = defaultView(doc).dom.innerHeight;\n    intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n    const op = find(marker.element);\n    const viewportBounds = getBounds(window);\n\n    if (op.top < viewportBounds.y) {\n      intoView(marker.element, alignToTop !== false);\n    } else if (op.top > viewportBounds.bottom) {\n      intoView(marker.element, alignToTop === true);\n    }\n  };\n\n  const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n\n  const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n\n  const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n\n  const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n\n  const scrollElementIntoView = (editor, element, alignToTop) => {\n    const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n    scroller(editor, element, alignToTop);\n  };\n\n  const scrollRangeIntoView = (editor, rng, alignToTop) => {\n    const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n    scroller(editor, rng, alignToTop);\n  };\n\n  const focus$1 = (element, preventScroll = false) => element.dom.focus({\n    preventScroll\n  });\n\n  const hasFocus$1 = element => {\n    const root = getRootNode(element).dom;\n    return element.dom === root.activeElement;\n  };\n\n  const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n\n  const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n  const clamp$1 = (offset, element) => {\n    const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;\n\n    if (offset > max) {\n      return max;\n    } else if (offset < 0) {\n      return 0;\n    }\n\n    return offset;\n  };\n\n  const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n\n  const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n\n  const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n\n  const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n\n  const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n\n  const readRange = win => {\n    const selection = win.getSelection();\n    const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n    return rng.map(nativeRangeToSelectionRange);\n  };\n\n  const getBookmark = root => {\n    const win = defaultView(root);\n    return readRange(win.dom).filter(isRngInRoot(root));\n  };\n\n  const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n\n  const bookmarkToNativeRng = bookmark => {\n    const rng = document.createRange();\n\n    try {\n      rng.setStart(bookmark.start.dom, bookmark.soffset);\n      rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n      return Optional.some(rng);\n    } catch (_) {\n      return Optional.none();\n    }\n  };\n\n  const store = editor => {\n    const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n    editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n  };\n\n  const getRng = editor => {\n    const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n    return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n  };\n\n  const restore = editor => {\n    getRng(editor).each(rng => editor.selection.setRng(rng));\n  };\n\n  const isEditorUIElement$1 = elm => {\n    const className = elm.className.toString();\n    return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n  };\n\n  const FocusManager = {\n    isEditorUIElement: isEditorUIElement$1\n  };\n\n  const wrappedSetTimeout = (callback, time) => {\n    if (!isNumber(time)) {\n      time = 0;\n    }\n\n    return setTimeout(callback, time);\n  };\n\n  const wrappedSetInterval = (callback, time) => {\n    if (!isNumber(time)) {\n      time = 0;\n    }\n\n    return setInterval(callback, time);\n  };\n\n  const Delay = {\n    setEditorTimeout: (editor, callback, time) => {\n      return wrappedSetTimeout(() => {\n        if (!editor.removed) {\n          callback();\n        }\n      }, time);\n    },\n    setEditorInterval: (editor, callback, time) => {\n      const timer = wrappedSetInterval(() => {\n        if (!editor.removed) {\n          callback();\n        } else {\n          clearInterval(timer);\n        }\n      }, time);\n      return timer;\n    }\n  };\n\n  const isManualNodeChange = e => {\n    return e.type === 'nodechange' && e.selectionChange;\n  };\n\n  const registerPageMouseUp = (editor, throttledStore) => {\n    const mouseUpPage = () => {\n      throttledStore.throttle();\n    };\n\n    DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n    editor.on('remove', () => {\n      DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n    });\n  };\n\n  const registerMouseUp = (editor, throttledStore) => {\n    editor.on('mouseup touchend', _e => {\n      throttledStore.throttle();\n    });\n  };\n\n  const registerEditorEvents = (editor, throttledStore) => {\n    registerMouseUp(editor, throttledStore);\n    editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n      if (!isManualNodeChange(e)) {\n        store(editor);\n      }\n    });\n  };\n\n  const register$6 = editor => {\n    const throttledStore = first$1(() => {\n      store(editor);\n    }, 0);\n    editor.on('init', () => {\n      if (editor.inline) {\n        registerPageMouseUp(editor, throttledStore);\n      }\n\n      registerEditorEvents(editor, throttledStore);\n    });\n    editor.on('remove', () => {\n      throttledStore.cancel();\n    });\n  };\n\n  let documentFocusInHandler;\n  const DOM$9 = DOMUtils.DOM;\n\n  const isEditorUIElement = elm => {\n    return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n  };\n\n  const isEditorContentAreaElement = elm => {\n    const classList = elm.classList;\n\n    if (classList !== undefined) {\n      return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n    } else {\n      return false;\n    }\n  };\n\n  const isUIElement = (editor, elm) => {\n    const customSelector = getCustomUiSelector(editor);\n    const parent = DOM$9.getParent(elm, elm => {\n      return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n    });\n    return parent !== null;\n  };\n\n  const getActiveElement = editor => {\n    try {\n      const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(root).fold(() => document.body, x => x.dom);\n    } catch (ex) {\n      return document.body;\n    }\n  };\n\n  const registerEvents$1 = (editorManager, e) => {\n    const editor = e.editor;\n    register$6(editor);\n\n    const toggleContentAreaOnFocus = (editor, fn) => {\n      if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n        const contentArea = SugarElement.fromDom(editor.getContainer());\n        fn(contentArea, 'tox-edit-focus');\n      }\n    };\n\n    editor.on('focusin', () => {\n      const focusedEditor = editorManager.focusedEditor;\n\n      if (isEditorContentAreaElement(getActiveElement(editor))) {\n        toggleContentAreaOnFocus(editor, add$2);\n      }\n\n      if (focusedEditor !== editor) {\n        if (focusedEditor) {\n          focusedEditor.dispatch('blur', {\n            focusedEditor: editor\n          });\n        }\n\n        editorManager.setActive(editor);\n        editorManager.focusedEditor = editor;\n        editor.dispatch('focus', {\n          blurredEditor: focusedEditor\n        });\n        editor.focus(true);\n      }\n    });\n    editor.on('focusout', () => {\n      Delay.setEditorTimeout(editor, () => {\n        const focusedEditor = editorManager.focusedEditor;\n\n        if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n          toggleContentAreaOnFocus(editor, remove$7);\n        }\n\n        if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n          editor.dispatch('blur', {\n            focusedEditor: null\n          });\n          editorManager.focusedEditor = null;\n        }\n      });\n    });\n\n    if (!documentFocusInHandler) {\n      documentFocusInHandler = e => {\n        const activeEditor = editorManager.activeEditor;\n\n        if (activeEditor) {\n          getOriginalEventTarget(e).each(target => {\n            const elem = target;\n\n            if (elem.ownerDocument === document) {\n              if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                activeEditor.dispatch('blur', {\n                  focusedEditor: null\n                });\n                editorManager.focusedEditor = null;\n              }\n            }\n          });\n        }\n      };\n\n      DOM$9.bind(document, 'focusin', documentFocusInHandler);\n    }\n  };\n\n  const unregisterDocumentEvents = (editorManager, e) => {\n    if (editorManager.focusedEditor === e.editor) {\n      editorManager.focusedEditor = null;\n    }\n\n    if (!editorManager.activeEditor && documentFocusInHandler) {\n      DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n      documentFocusInHandler = null;\n    }\n  };\n\n  const setup$w = editorManager => {\n    editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n    editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n  };\n\n  const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n\n  const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n\n  const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n    if (isTableSection(node)) {\n      return Optional.some(node);\n    } else if (!contains(root, node)) {\n      return Optional.some(root);\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const normalizeSelection = (editor, rng) => {\n    getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n      return firstPositionIn(elm.dom);\n    }).fold(() => {\n      editor.selection.normalize();\n    }, caretPos => editor.selection.setRng(caretPos.toRange()));\n  };\n\n  const focusBody = body => {\n    if (body.setActive) {\n      try {\n        body.setActive();\n      } catch (ex) {\n        body.focus();\n      }\n    } else {\n      body.focus();\n    }\n  };\n\n  const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n\n  const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n\n  const hasInlineFocus = editor => {\n    const rawBody = editor.getBody();\n    return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n  };\n\n  const hasUiFocus = editor => {\n    const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n    return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n  };\n\n  const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n\n  const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n\n  const focusEditor = editor => {\n    const selection = editor.selection;\n    const body = editor.getBody();\n    let rng = selection.getRng();\n    editor.quirks.refreshContentEditable();\n\n    if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n      getRng(editor).each(bookmarkRng => {\n        editor.selection.setRng(bookmarkRng);\n        rng = bookmarkRng;\n      });\n    }\n\n    const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n\n    if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n      focusBody(contentEditableHost);\n      normalizeSelection(editor, rng);\n      activateEditor(editor);\n      return;\n    }\n\n    if (!editor.inline) {\n      if (!Env.browser.isOpera()) {\n        focusBody(body);\n      }\n\n      editor.getWin().focus();\n    }\n\n    if (Env.browser.isFirefox() || editor.inline) {\n      focusBody(body);\n      normalizeSelection(editor, rng);\n    }\n\n    activateEditor(editor);\n  };\n\n  const activateEditor = editor => editor.editorManager.setActive(editor);\n\n  const focus = (editor, skipFocus) => {\n    if (editor.removed) {\n      return;\n    }\n\n    if (skipFocus) {\n      activateEditor(editor);\n    } else {\n      focusEditor(editor);\n    }\n  };\n\n  const isEditableRange = (dom, rng) => {\n    if (rng.collapsed) {\n      return dom.isEditable(rng.startContainer);\n    } else {\n      return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n    }\n  };\n\n  const getEndpointElement = (root, rng, start, real, resolve) => {\n    const container = start ? rng.startContainer : rng.endContainer;\n    const offset = start ? rng.startOffset : rng.endOffset;\n    return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n  };\n\n  const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n\n  const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n\n  const skipEmptyTextNodes = (node, forwards) => {\n    const orig = node;\n\n    while (node && isText$a(node) && node.length === 0) {\n      node = forwards ? node.nextSibling : node.previousSibling;\n    }\n\n    return node || orig;\n  };\n\n  const getNode = (root, rng) => {\n    if (!rng) {\n      return root;\n    }\n\n    let startContainer = rng.startContainer;\n    let endContainer = rng.endContainer;\n    const startOffset = rng.startOffset;\n    const endOffset = rng.endOffset;\n    let node = rng.commonAncestorContainer;\n\n    if (!rng.collapsed) {\n      if (startContainer === endContainer) {\n        if (endOffset - startOffset < 2) {\n          if (startContainer.hasChildNodes()) {\n            node = startContainer.childNodes[startOffset];\n          }\n        }\n      }\n\n      if (isText$a(startContainer) && isText$a(endContainer)) {\n        if (startContainer.length === startOffset) {\n          startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n        } else {\n          startContainer = startContainer.parentNode;\n        }\n\n        if (endOffset === 0) {\n          endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n        } else {\n          endContainer = endContainer.parentNode;\n        }\n\n        if (startContainer && startContainer === endContainer) {\n          node = startContainer;\n        }\n      }\n    }\n\n    const elm = isText$a(node) ? node.parentNode : node;\n    return isHTMLElement(elm) ? elm : root;\n  };\n\n  const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n    const selectedBlocks = [];\n    const root = dom.getRoot();\n    const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n    const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n\n    if (start && start !== root) {\n      selectedBlocks.push(start);\n    }\n\n    if (start && end && start !== end) {\n      let node;\n      const walker = new DomTreeWalker(start, root);\n\n      while ((node = walker.next()) && node !== end) {\n        if (dom.isBlock(node)) {\n          selectedBlocks.push(node);\n        }\n      }\n    }\n\n    if (end && start !== end && end !== root) {\n      selectedBlocks.push(end);\n    }\n\n    return selectedBlocks;\n  };\n\n  const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n    const idx = dom.nodeIndex(node);\n    const rng = dom.createRng();\n    rng.setStart(parent, idx);\n    rng.setEnd(parent, idx + 1);\n\n    if (content) {\n      moveEndPoint(dom, rng, node, true);\n      moveEndPoint(dom, rng, node, false);\n    }\n\n    return rng;\n  }));\n\n  const processRanges = (editor, ranges) => map$3(ranges, range => {\n    const evt = editor.dispatch('GetSelectionRange', {\n      range\n    });\n    return evt.range !== range ? evt.range : range;\n  });\n\n  const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);\n\n  const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n\n  const isContentEditableFalse$5 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n\n  const elementsWithCursorPosition = ['img', 'br'];\n\n  const isCursorPosition = elem => {\n    const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n    return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);\n  };\n\n  const first = element => descendant$2(element, isCursorPosition);\n\n  const last = element => descendantRtl(element, isCursorPosition);\n\n  const descendantRtl = (scope, predicate) => {\n    const descend = element => {\n      const children = children$1(element);\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        if (predicate(child)) {\n          return Optional.some(child);\n        }\n\n        const res = descend(child);\n\n        if (res.isSome()) {\n          return res;\n        }\n      }\n\n      return Optional.none();\n    };\n\n    return descend(scope);\n  };\n\n  const autocompleteSelector = '[data-mce-autocompleter]';\n\n  const create$9 = (editor, range) => {\n    if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n      const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n      append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n      range.insertNode(wrapper.dom);\n      parent(wrapper).each(elm => elm.dom.normalize());\n      last(wrapper).map(last => {\n        editor.selection.setCursorLocation(last.dom, getEnd(last));\n      });\n    }\n  };\n\n  const detect$1 = elm => closest$3(elm, autocompleteSelector);\n\n  const findIn = elm => descendant$1(elm, autocompleteSelector);\n\n  const remove$2 = (editor, elm) => findIn(elm).each(wrapper => {\n    const bookmark = editor.selection.getBookmark();\n    unwrap(wrapper);\n    editor.selection.moveToBookmark(bookmark);\n  });\n\n  const typeLookup = {\n    '#text': 3,\n    '#comment': 8,\n    '#cdata': 4,\n    '#pi': 7,\n    '#doctype': 10,\n    '#document-fragment': 11\n  };\n\n  const walk$2 = (node, root, prev) => {\n    const startName = prev ? 'lastChild' : 'firstChild';\n    const siblingName = prev ? 'prev' : 'next';\n\n    if (node[startName]) {\n      return node[startName];\n    }\n\n    if (node !== root) {\n      let sibling = node[siblingName];\n\n      if (sibling) {\n        return sibling;\n      }\n\n      for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n        sibling = parent[siblingName];\n\n        if (sibling) {\n          return sibling;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  const isEmptyTextNode = node => {\n    var _a;\n\n    const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n\n    if (!isWhitespaceText(text)) {\n      return false;\n    }\n\n    const parentNode = node.parent;\n\n    if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  const isNonEmptyElement = node => {\n    const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n    return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n  };\n\n  class AstNode {\n    static create(name, attrs) {\n      const node = new AstNode(name, typeLookup[name] || 1);\n\n      if (attrs) {\n        each$d(attrs, (value, attrName) => {\n          node.attr(attrName, value);\n        });\n      }\n\n      return node;\n    }\n\n    constructor(name, type) {\n      this.name = name;\n      this.type = type;\n\n      if (type === 1) {\n        this.attributes = [];\n        this.attributes.map = {};\n      }\n    }\n\n    replace(node) {\n      const self = this;\n\n      if (node.parent) {\n        node.remove();\n      }\n\n      self.insert(node, self);\n      self.remove();\n      return self;\n    }\n\n    attr(name, value) {\n      const self = this;\n\n      if (!isString(name)) {\n        if (isNonNullable(name)) {\n          each$d(name, (value, key) => {\n            self.attr(key, value);\n          });\n        }\n\n        return self;\n      }\n\n      const attrs = self.attributes;\n\n      if (attrs) {\n        if (value !== undefined) {\n          if (value === null) {\n            if (name in attrs.map) {\n              delete attrs.map[name];\n              let i = attrs.length;\n\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs.splice(i, 1);\n                  return self;\n                }\n              }\n            }\n\n            return self;\n          }\n\n          if (name in attrs.map) {\n            let i = attrs.length;\n\n            while (i--) {\n              if (attrs[i].name === name) {\n                attrs[i].value = value;\n                break;\n              }\n            }\n          } else {\n            attrs.push({\n              name,\n              value\n            });\n          }\n\n          attrs.map[name] = value;\n          return self;\n        }\n\n        return attrs.map[name];\n      }\n\n      return undefined;\n    }\n\n    clone() {\n      const self = this;\n      const clone = new AstNode(self.name, self.type);\n      const selfAttrs = self.attributes;\n\n      if (selfAttrs) {\n        const cloneAttrs = [];\n        cloneAttrs.map = {};\n\n        for (let i = 0, l = selfAttrs.length; i < l; i++) {\n          const selfAttr = selfAttrs[i];\n\n          if (selfAttr.name !== 'id') {\n            cloneAttrs[cloneAttrs.length] = {\n              name: selfAttr.name,\n              value: selfAttr.value\n            };\n            cloneAttrs.map[selfAttr.name] = selfAttr.value;\n          }\n        }\n\n        clone.attributes = cloneAttrs;\n      }\n\n      clone.value = self.value;\n      return clone;\n    }\n\n    wrap(wrapper) {\n      const self = this;\n\n      if (self.parent) {\n        self.parent.insert(wrapper, self);\n        wrapper.append(self);\n      }\n\n      return self;\n    }\n\n    unwrap() {\n      const self = this;\n\n      for (let node = self.firstChild; node;) {\n        const next = node.next;\n        self.insert(node, self, true);\n        node = next;\n      }\n\n      self.remove();\n    }\n\n    remove() {\n      const self = this,\n            parent = self.parent,\n            next = self.next,\n            prev = self.prev;\n\n      if (parent) {\n        if (parent.firstChild === self) {\n          parent.firstChild = next;\n\n          if (next) {\n            next.prev = null;\n          }\n        } else if (prev) {\n          prev.next = next;\n        }\n\n        if (parent.lastChild === self) {\n          parent.lastChild = prev;\n\n          if (prev) {\n            prev.next = null;\n          }\n        } else if (next) {\n          next.prev = prev;\n        }\n\n        self.parent = self.next = self.prev = null;\n      }\n\n      return self;\n    }\n\n    append(node) {\n      const self = this;\n\n      if (node.parent) {\n        node.remove();\n      }\n\n      const last = self.lastChild;\n\n      if (last) {\n        last.next = node;\n        node.prev = last;\n        self.lastChild = node;\n      } else {\n        self.lastChild = self.firstChild = node;\n      }\n\n      node.parent = self;\n      return node;\n    }\n\n    insert(node, refNode, before) {\n      if (node.parent) {\n        node.remove();\n      }\n\n      const parent = refNode.parent || this;\n\n      if (before) {\n        if (refNode === parent.firstChild) {\n          parent.firstChild = node;\n        } else if (refNode.prev) {\n          refNode.prev.next = node;\n        }\n\n        node.prev = refNode.prev;\n        node.next = refNode;\n        refNode.prev = node;\n      } else {\n        if (refNode === parent.lastChild) {\n          parent.lastChild = node;\n        } else if (refNode.next) {\n          refNode.next.prev = node;\n        }\n\n        node.next = refNode.next;\n        node.prev = refNode;\n        refNode.next = node;\n      }\n\n      node.parent = parent;\n      return node;\n    }\n\n    getAll(name) {\n      const self = this;\n      const collection = [];\n\n      for (let node = self.firstChild; node; node = walk$2(node, self)) {\n        if (node.name === name) {\n          collection.push(node);\n        }\n      }\n\n      return collection;\n    }\n\n    children() {\n      const self = this;\n      const collection = [];\n\n      for (let node = self.firstChild; node; node = node.next) {\n        collection.push(node);\n      }\n\n      return collection;\n    }\n\n    empty() {\n      const self = this;\n\n      if (self.firstChild) {\n        const nodes = [];\n\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          nodes.push(node);\n        }\n\n        let i = nodes.length;\n\n        while (i--) {\n          const node = nodes[i];\n          node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n        }\n      }\n\n      self.firstChild = self.lastChild = null;\n      return self;\n    }\n\n    isEmpty(elements, whitespace = {}, predicate) {\n      var _a;\n\n      const self = this;\n      let node = self.firstChild;\n\n      if (isNonEmptyElement(self)) {\n        return false;\n      }\n\n      if (node) {\n        do {\n          if (node.type === 1) {\n            if (node.attr('data-mce-bogus')) {\n              continue;\n            }\n\n            if (elements[node.name]) {\n              return false;\n            }\n\n            if (isNonEmptyElement(node)) {\n              return false;\n            }\n          }\n\n          if (node.type === 8) {\n            return false;\n          }\n\n          if (node.type === 3 && !isEmptyTextNode(node)) {\n            return false;\n          }\n\n          if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n            return false;\n          }\n\n          if (predicate && predicate(node)) {\n            return false;\n          }\n        } while (node = walk$2(node, self));\n      }\n\n      return true;\n    }\n\n    walk(prev) {\n      return walk$2(this, null, prev);\n    }\n\n  }\n\n  const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n\n  const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n\n  const getTemporaryNodeSelector = tempAttrs => `${tempAttrs.length === 0 ? '' : `${map$3(tempAttrs, attr => `[${attr}]`).join(',')},`}[data-mce-bogus=\"all\"]`;\n\n  const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n\n  const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n\n  const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n    if (containsZwsp(node)) {\n      const parent = node.parentNode;\n      return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    } else {\n      return NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n\n  const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n\n  const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n\n  const trimTemporaryNodes = (tempAttrs, body) => {\n    each$e(getTemporaryNodes(tempAttrs, body), elm => {\n      const element = SugarElement.fromDom(elm);\n\n      if (get$9(element, 'data-mce-bogus') === 'all') {\n        remove$5(element);\n      } else {\n        each$e(tempAttrs, attr => {\n          if (has$1(element, attr)) {\n            remove$a(element, attr);\n          }\n        });\n      }\n    });\n  };\n\n  const emptyAllNodeValuesInWalker = walker => {\n    let curr = walker.nextNode();\n\n    while (curr !== null) {\n      curr.nodeValue = null;\n      curr = walker.nextNode();\n    }\n  };\n\n  const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n  const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n\n  const trim$1 = (body, tempAttrs) => {\n    const conditionalTrims = [{\n      condition: curry(hasTemporaryNode, tempAttrs),\n      action: curry(trimTemporaryNodes, tempAttrs)\n    }, {\n      condition: hasZwspComment,\n      action: emptyZwspComments\n    }, {\n      condition: hasUnescapedZwspText,\n      action: emptyUnescapedZwspTexts\n    }];\n    let trimmed = body;\n    let cloned = false;\n    each$e(conditionalTrims, ({\n      condition,\n      action\n    }) => {\n      if (condition(trimmed)) {\n        if (!cloned) {\n          trimmed = body.cloneNode(true);\n          cloned = true;\n        }\n\n        action(trimmed);\n      }\n    });\n    return trimmed;\n  };\n\n  const cleanupBogusElements = parent => {\n    const bogusElements = descendants(parent, '[data-mce-bogus]');\n    each$e(bogusElements, elem => {\n      const bogusValue = get$9(elem, 'data-mce-bogus');\n\n      if (bogusValue === 'all') {\n        remove$5(elem);\n      } else if (isBr$5(elem)) {\n        before$3(elem, SugarElement.fromText(zeroWidth));\n        remove$5(elem);\n      } else {\n        unwrap(elem);\n      }\n    });\n  };\n\n  const cleanupInputNames = parent => {\n    const inputs = descendants(parent, 'input');\n    each$e(inputs, input => {\n      remove$a(input, 'name');\n    });\n  };\n\n  const trimEmptyContents = (editor, html) => {\n    const blockName = getForcedRootBlock(editor);\n    const emptyRegExp = new RegExp(`^(<${blockName}[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${blockName}>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n    return html.replace(emptyRegExp, '');\n  };\n\n  const getPlainTextContent = (editor, body) => {\n    const doc = editor.getDoc();\n    const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n    const offscreenDiv = SugarElement.fromTag('div', doc);\n    set$3(offscreenDiv, 'data-mce-bogus', 'all');\n    setAll(offscreenDiv, {\n      position: 'fixed',\n      left: '-9999999px',\n      top: '0'\n    });\n    set$1(offscreenDiv, body.innerHTML);\n    cleanupBogusElements(offscreenDiv);\n    cleanupInputNames(offscreenDiv);\n    const root = getContentContainer(dos);\n    append$1(root, offscreenDiv);\n    const content = trim$2(offscreenDiv.dom.innerText);\n    remove$5(offscreenDiv);\n    return content;\n  };\n\n  const getContentFromBody = (editor, args, body) => {\n    let content;\n\n    if (args.format === 'raw') {\n      content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n    } else if (args.format === 'text') {\n      content = getPlainTextContent(editor, body);\n    } else if (args.format === 'tree') {\n      content = editor.serializer.serialize(body, args);\n    } else {\n      content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n    }\n\n    const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n    return shouldTrim && isString(content) ? Tools.trim(content) : content;\n  };\n\n  const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n  const makeMap$1 = Tools.makeMap;\n\n  const Writer = settings => {\n    const html = [];\n    settings = settings || {};\n    const indent = settings.indent;\n    const indentBefore = makeMap$1(settings.indent_before || '');\n    const indentAfter = makeMap$1(settings.indent_after || '');\n    const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n    const htmlOutput = settings.element_format !== 'xhtml';\n    return {\n      start: (name, attrs, empty) => {\n        if (indent && indentBefore[name] && html.length > 0) {\n          const value = html[html.length - 1];\n\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n\n        html.push('<', name);\n\n        if (attrs) {\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            const attr = attrs[i];\n            html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n          }\n        }\n\n        if (!empty || htmlOutput) {\n          html[html.length] = '>';\n        } else {\n          html[html.length] = ' />';\n        }\n\n        if (empty && indent && indentAfter[name] && html.length > 0) {\n          const value = html[html.length - 1];\n\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n      },\n      end: name => {\n        let value;\n        html.push('</', name, '>');\n\n        if (indent && indentAfter[name] && html.length > 0) {\n          value = html[html.length - 1];\n\n          if (value.length > 0 && value !== '\\n') {\n            html.push('\\n');\n          }\n        }\n      },\n      text: (text, raw) => {\n        if (text.length > 0) {\n          html[html.length] = raw ? text : encode(text);\n        }\n      },\n      cdata: text => {\n        html.push('<![CDATA[', text, ']]>');\n      },\n      comment: text => {\n        html.push('<!--', text, '-->');\n      },\n      pi: (name, text) => {\n        if (text) {\n          html.push('<?', name, ' ', encode(text), '?>');\n        } else {\n          html.push('<?', name, '?>');\n        }\n\n        if (indent) {\n          html.push('\\n');\n        }\n      },\n      doctype: text => {\n        html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n      },\n      reset: () => {\n        html.length = 0;\n      },\n      getContent: () => {\n        return html.join('').replace(/\\n$/, '');\n      }\n    };\n  };\n\n  const HtmlSerializer = (settings = {}, schema = Schema()) => {\n    const writer = Writer(settings);\n    settings.validate = 'validate' in settings ? settings.validate : true;\n\n    const serialize = node => {\n      const validate = settings.validate;\n      const handlers = {\n        3: node => {\n          var _a;\n\n          writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n        },\n        8: node => {\n          var _a;\n\n          writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        },\n        7: node => {\n          writer.pi(node.name, node.value);\n        },\n        10: node => {\n          var _a;\n\n          writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        },\n        4: node => {\n          var _a;\n\n          writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        },\n        11: node => {\n          let tempNode = node;\n\n          if (tempNode = tempNode.firstChild) {\n            do {\n              walk(tempNode);\n            } while (tempNode = tempNode.next);\n          }\n        }\n      };\n      writer.reset();\n\n      const walk = node => {\n        var _a;\n\n        const handler = handlers[node.type];\n\n        if (!handler) {\n          const name = node.name;\n          const isEmpty = (name in schema.getVoidElements());\n          let attrs = node.attributes;\n\n          if (validate && attrs && attrs.length > 1) {\n            const sortedAttrs = [];\n            sortedAttrs.map = {};\n            const elementRule = schema.getElementRule(node.name);\n\n            if (elementRule) {\n              for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                const attrName = elementRule.attributesOrder[i];\n\n                if (attrName in attrs.map) {\n                  const attrValue = attrs.map[attrName];\n                  sortedAttrs.map[attrName] = attrValue;\n                  sortedAttrs.push({\n                    name: attrName,\n                    value: attrValue\n                  });\n                }\n              }\n\n              for (let i = 0, l = attrs.length; i < l; i++) {\n                const attrName = attrs[i].name;\n\n                if (!(attrName in sortedAttrs.map)) {\n                  const attrValue = attrs.map[attrName];\n                  sortedAttrs.map[attrName] = attrValue;\n                  sortedAttrs.push({\n                    name: attrName,\n                    value: attrValue\n                  });\n                }\n              }\n\n              attrs = sortedAttrs;\n            }\n          }\n\n          writer.start(name, attrs, isEmpty);\n\n          if (isNonHtmlElementRootName(name)) {\n            if (isString(node.value)) {\n              writer.text(node.value, true);\n            }\n\n            writer.end(name);\n          } else {\n            if (!isEmpty) {\n              let child = node.firstChild;\n\n              if (child) {\n                if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                  writer.text('\\n', true);\n                }\n\n                do {\n                  walk(child);\n                } while (child = child.next);\n              }\n\n              writer.end(name);\n            }\n          }\n        } else {\n          handler(node);\n        }\n      };\n\n      if (node.type === 1 && !settings.inner) {\n        walk(node);\n      } else if (node.type === 3) {\n        handlers[3](node);\n      } else {\n        handlers[11](node);\n      }\n\n      return writer.getContent();\n    };\n\n    return {\n      serialize\n    };\n  };\n\n  const nonInheritableStyles = new Set();\n\n  (() => {\n    const nonInheritableStylesArr = ['margin', 'margin-left', 'margin-right', 'margin-top', 'margin-bottom', 'padding', 'padding-left', 'padding-right', 'padding-top', 'padding-bottom', 'border', 'border-width', 'border-style', 'border-color', 'background', 'background-attachment', 'background-clip', 'background-color', 'background-image', 'background-origin', 'background-position', 'background-repeat', 'background-size', 'float', 'position', 'left', 'right', 'top', 'bottom', 'z-index', 'display', 'transform', 'width', 'max-width', 'min-width', 'height', 'max-height', 'min-height', 'overflow', 'overflow-x', 'overflow-y', 'text-overflow', 'vertical-align', 'transition', 'transition-delay', 'transition-duration', 'transition-property', 'transition-timing-function'];\n    each$e(nonInheritableStylesArr, style => {\n      nonInheritableStyles.add(style);\n    });\n  })();\n\n  const shorthandStyleProps = ['font', 'text-decoration', 'text-emphasis'];\n\n  const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n\n  const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n\n  const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n\n  const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n\n  const hasStyleConflict = (dom, node, parentNode) => {\n    const nodeStyleProps = getStyleProps(dom, node);\n    const parentNodeStyleProps = getStyleProps(dom, parentNode);\n\n    const valueMismatch = prop => {\n      var _a, _b;\n\n      const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n      const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n      return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n    };\n\n    return exists(nodeStyleProps, nodeStyleProp => {\n      const propExists = props => exists(props, prop => prop === nodeStyleProp);\n\n      if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n        const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n        return exists(longhandProps, valueMismatch);\n      } else {\n        return valueMismatch(nodeStyleProp);\n      }\n    });\n  };\n\n  const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {\n    const delta = forward ? 0 : -1;\n    return predicate(text.data.charAt(pos.offset() + delta));\n  });\n\n  const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n  const isAfterSpace = curry(isChar, false, isWhiteSpace);\n\n  const isEmptyText = pos => {\n    const container = pos.container();\n    return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n  };\n\n  const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n\n  const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n\n  const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);\n\n  const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n  const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n  const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n  const isAfterMedia = matchesElementPosition(false, isMedia$2);\n  const isBeforeTable = matchesElementPosition(true, isTable$2);\n  const isAfterTable = matchesElementPosition(false, isTable$2);\n  const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n  const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n  const dropLast = xs => xs.slice(0, -1);\n\n  const parentsUntil = (start, root, predicate) => {\n    if (contains(root, start)) {\n      return dropLast(parents$1(start, elm => {\n        return predicate(elm) || eq(elm, root);\n      }));\n    } else {\n      return [];\n    }\n  };\n\n  const parents = (start, root) => parentsUntil(start, root, never);\n\n  const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n  const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n\n  const isBlock$1 = schema => el => schema.isBlock(name(el));\n\n  const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n\n  const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n\n  const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n\n  const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n  const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n  const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n  const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n  const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n\n  const findBr = (forward, root, pos, schema) => {\n    const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n    const scope = head(parentBlocks).getOr(root);\n    return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n  };\n\n  const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n\n  const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n\n  const findPreviousBr = curry(findBr, false);\n  const findNextBr = curry(findBr, true);\n\n  const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n\n  const getClosestBlock = (root, pos, schema) => {\n    const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n    return head(parentBlocks).getOr(root);\n  };\n\n  const hasSpaceBefore = (root, pos, schema) => {\n    if (isInMiddleOfText(pos)) {\n      return isAfterSpace(pos);\n    } else {\n      return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n    }\n  };\n\n  const hasSpaceAfter = (root, pos, schema) => {\n    if (isInMiddleOfText(pos)) {\n      return isBeforeSpace(pos);\n    } else {\n      return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n    }\n  };\n\n  const isPreValue = value => contains$2(['pre', 'pre-wrap'], value);\n\n  const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n\n  const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n\n  const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n\n  const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n\n  const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n\n  const isSiblingCefBlock = (root, direction) => container => {\n    return isCefBlock(new DomTreeWalker(container, root)[direction]());\n  };\n\n  const isBeforeCefBlock = (root, pos) => {\n    const nextPos = nextPosition(root.dom, pos).getOr(pos);\n    const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n    return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n  };\n\n  const isAfterCefBlock = (root, pos) => {\n    const prevPos = prevPosition(root.dom, pos).getOr(pos);\n    const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n    return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n  };\n\n  const needsToHaveNbsp = (root, pos, schema) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n    }\n  };\n\n  const needsToBeNbspLeft = (root, pos, schema) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n    }\n  };\n\n  const leanRight = pos => {\n    const container = pos.container();\n    const offset = pos.offset();\n\n    if (isText$a(container) && offset < container.data.length) {\n      return CaretPosition(container, offset + 1);\n    } else {\n      return pos;\n    }\n  };\n\n  const needsToBeNbspRight = (root, pos, schema) => {\n    if (isInPre(pos)) {\n      return false;\n    } else {\n      return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n    }\n  };\n\n  const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n\n  const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n\n  const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n\n  const hasNbsp = pos => {\n    const container = pos.container();\n    return isText$a(container) && contains$1(container.data, nbsp);\n  };\n\n  const normalizeNbspMiddle = text => {\n    const chars = text.split('');\n    return map$3(chars, (chr, i) => {\n      if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n        return ' ';\n      } else {\n        return chr;\n      }\n    }).join('');\n  };\n\n  const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n    const text = node.data;\n    const firstPos = CaretPosition(node, 0);\n\n    if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n      node.data = ' ' + text.slice(1);\n      return true;\n    } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n      node.data = nbsp + text.slice(1);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const normalizeNbspInMiddleOfTextNode = node => {\n    const text = node.data;\n    const newText = normalizeNbspMiddle(text);\n\n    if (newText !== text) {\n      node.data = newText;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n    const text = node.data;\n    const lastPos = CaretPosition(node, text.length - 1);\n\n    if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n      node.data = text.slice(0, -1) + ' ';\n      return true;\n    } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n      node.data = text.slice(0, -1) + nbsp;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const normalizeNbsps = (root, pos, schema) => {\n    const container = pos.container();\n\n    if (!isText$a(container)) {\n      return Optional.none();\n    }\n\n    if (hasNbsp(pos)) {\n      const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n      return someIf(normalized, pos);\n    } else if (needsToBeNbsp(root, pos, schema)) {\n      const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n      return someIf(normalized, pos);\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const normalizeNbspsInEditor = editor => {\n    const root = SugarElement.fromDom(editor.getBody());\n\n    if (editor.selection.isCollapsed()) {\n      normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n        editor.selection.setRng(pos.toRange());\n      });\n    }\n  };\n\n  const normalize$1 = (node, offset, count, schema) => {\n    if (count === 0) {\n      return;\n    }\n\n    const elm = SugarElement.fromDom(node);\n    const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n    const whitespace = node.data.slice(offset, offset + count);\n    const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n    const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n    node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n  };\n\n  const normalizeWhitespaceAfter = (node, offset, schema) => {\n    const content = node.data.slice(offset);\n    const whitespaceCount = content.length - lTrim(content).length;\n    normalize$1(node, offset, whitespaceCount, schema);\n  };\n\n  const normalizeWhitespaceBefore = (node, offset, schema) => {\n    const content = node.data.slice(0, offset);\n    const whitespaceCount = content.length - rTrim(content).length;\n    normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n  };\n\n  const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n    const whitespaceOffset = rTrim(prevNode.data).length;\n    const newNode = mergeToPrev ? prevNode : nextNode;\n    const removeNode = mergeToPrev ? nextNode : prevNode;\n\n    if (mergeToPrev) {\n      newNode.appendData(removeNode.data);\n    } else {\n      newNode.insertData(0, removeNode.data);\n    }\n\n    remove$5(SugarElement.fromDom(removeNode));\n\n    if (normalizeWhitespace) {\n      normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n    }\n\n    return newNode;\n  };\n\n  const needsReposition = (pos, elm) => {\n    const container = pos.container();\n    const offset = pos.offset();\n    return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n  };\n\n  const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n\n  const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n\n  const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n\n  const getPreviousSiblingCaretPosition = elm => {\n    if (isCaretCandidate$3(elm.previousSibling)) {\n      return Optional.some(afterOrEndOf(elm.previousSibling));\n    } else {\n      return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n    }\n  };\n\n  const getNextSiblingCaretPosition = elm => {\n    if (isCaretCandidate$3(elm.nextSibling)) {\n      return Optional.some(beforeOrStartOf(elm.nextSibling));\n    } else {\n      return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n    }\n  };\n\n  const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n    return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n  };\n\n  const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n\n  const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n\n  const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n\n  const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n\n  const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n\n  const setSelection$1 = (editor, forward, pos) => {\n    pos.fold(() => {\n      editor.focus();\n    }, pos => {\n      editor.selection.setRng(pos.toRange(), forward);\n    });\n  };\n\n  const eqRawNode = rawNode => elm => elm.dom === rawNode;\n\n  const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n\n  const paddEmptyBlock = (elm, preserveEmptyCaret) => {\n    if (isEmpty$2(elm)) {\n      const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n\n      if (preserveEmptyCaret) {\n        each$e(children$1(elm), node => {\n          if (!isEmptyCaretFormatElement(node)) {\n            remove$5(node);\n          }\n        });\n      } else {\n        empty(elm);\n      }\n\n      append$1(elm, br);\n      return Optional.some(CaretPosition.before(br.dom));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n    const prevTextOpt = prevSibling(elm).filter(isText$b);\n    const nextTextOpt = nextSibling(elm).filter(isText$b);\n    remove$5(elm);\n    return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n      const prevNode = prev.dom,\n            nextNode = next.dom;\n      const offset = prevNode.data.length;\n      mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n      return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n    }).orThunk(() => {\n      if (normalizeWhitespace) {\n        prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n        nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n      }\n\n      return afterDeletePosOpt;\n    });\n  };\n\n  const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n\n  const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n    const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n    const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n    const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n\n    if (editor.dom.isEmpty(editor.getBody())) {\n      editor.setContent('');\n      editor.selection.setCursorLocation();\n    } else {\n      parentBlock.bind(elm => paddEmptyBlock(elm, preserveEmptyCaret)).fold(() => {\n        if (moveCaret) {\n          setSelection$1(editor, forward, normalizedAfterDeletePos);\n        }\n      }, paddPos => {\n        if (moveCaret) {\n          setSelection$1(editor, forward, Optional.some(paddPos));\n        }\n      });\n    }\n  };\n\n  const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n\n  const hasStrongRtl = text => strongRtl.test(text);\n\n  const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n\n  const isRtl = element => {\n    var _a;\n\n    return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n  };\n\n  const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n\n  const findRootInline = (isInlineTarget, rootNode, pos) => {\n    const parents = findInlineParents(isInlineTarget, rootNode, pos);\n    return Optional.from(parents[parents.length - 1]);\n  };\n\n  const hasSameParentBlock = (rootNode, node1, node2) => {\n    const block1 = getParentBlock$3(node1, rootNode);\n    const block2 = getParentBlock$3(node2, rootNode);\n    return isNonNullable(block1) && block1 === block2;\n  };\n\n  const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n\n  const normalizePosition = (forward, pos) => {\n    const container = pos.container(),\n          offset = pos.offset();\n\n    if (forward) {\n      if (isCaretContainerInline(container)) {\n        if (isText$a(container.nextSibling)) {\n          return CaretPosition(container.nextSibling, 0);\n        } else {\n          return CaretPosition.after(container);\n        }\n      } else {\n        return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n      }\n    } else {\n      if (isCaretContainerInline(container)) {\n        if (isText$a(container.previousSibling)) {\n          return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n        } else {\n          return CaretPosition.before(container);\n        }\n      } else {\n        return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n      }\n    }\n  };\n\n  const normalizeForwards = curry(normalizePosition, true);\n  const normalizeBackwards = curry(normalizePosition, false);\n\n  const execCommandIgnoreInputEvents = (editor, command) => {\n    const inputBlocker = e => e.stopImmediatePropagation();\n\n    editor.on('beforeinput input', inputBlocker, true);\n    editor.getDoc().execCommand(command);\n    editor.off('beforeinput input', inputBlocker);\n  };\n\n  const execEditorDeleteCommand = editor => {\n    editor.execCommand('delete');\n  };\n\n  const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n\n  const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n\n  const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n\n  const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n\n  const getParentBlock$2 = (rootNode, elm) => {\n    if (contains(rootNode, elm)) {\n      return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const paddEmptyBody = (editor, moveSelection = true) => {\n    if (editor.dom.isEmpty(editor.getBody())) {\n      editor.setContent('', {\n        no_selection: !moveSelection\n      });\n    }\n  };\n\n  const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n    const normalizedFirstPos = normalizePosition(true, firstPos);\n    const normalizedLastPos = normalizePosition(false, lastPos);\n    const normalizedFromPos = normalizePosition(false, fromPos);\n\n    if (forward) {\n      return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n    } else {\n      return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n    }\n  }).getOr(true);\n\n  const freefallRtl = root => {\n    const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n    return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n  };\n\n  const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n    var _a;\n\n    rng.deleteContents();\n    const lastNode = freefallRtl(root).getOr(root);\n    const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n\n    if (lastBlock.dom === editor.getBody()) {\n      paddEmptyBody(editor, moveSelection);\n    } else if (isEmpty$2(lastBlock)) {\n      fillWithPaddingBr(lastBlock);\n\n      if (moveSelection) {\n        editor.selection.setCursorLocation(lastBlock.dom, 0);\n      }\n    }\n\n    if (!eq(root, lastBlock)) {\n      const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n      each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n        if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n          remove$5(node);\n        }\n      });\n    }\n  };\n\n  const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n\n  const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n\n  const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n\n  const isRootFromElement = root => cur => eq(root, cur);\n\n  const getTableCells = table => descendants(table, 'td,th');\n\n  const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n\n  const selectionInTableWithNestedTable = details => {\n    return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n      const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n      const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n      return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : { ...details,\n        startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n        endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n        isSameTable: false,\n        isMultiTable: false\n      };\n    }).getOr(details);\n  };\n\n  const adjustQuirksInDetails = details => {\n    return selectionInTableWithNestedTable(details);\n  };\n\n  const getTableDetailsFromRange = (rng, isRoot) => {\n    const startTable = getTable$1(rng.startContainer, isRoot);\n    const endTable = getTable$1(rng.endContainer, isRoot);\n    const isStartInTable = startTable.isSome();\n    const isEndInTable = endTable.isSome();\n    const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n    const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n    return adjustQuirksInDetails({\n      startTable,\n      endTable,\n      isStartInTable,\n      isEndInTable,\n      isSameTable,\n      isMultiTable\n    });\n  };\n\n  const tableCellRng = (start, end) => ({\n    start,\n    end\n  });\n\n  const tableSelection = (rng, table, cells) => ({\n    rng,\n    table,\n    cells\n  });\n\n  const deleteAction = Adt.generate([{\n    singleCellTable: ['rng', 'cell']\n  }, {\n    fullTable: ['table']\n  }, {\n    partialTable: ['cells', 'outsideDetails']\n  }, {\n    multiTable: ['startTableCells', 'endTableCells', 'betweenRng']\n  }]);\n\n  const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n\n  const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n\n  const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n\n  const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n    const rows = table.dom.rows;\n    return rows.length === 1 && rows[0].cells.length === 1;\n  });\n\n  const getCellRng = (rng, isRoot) => {\n    const startCell = getClosestCell$1(rng.startContainer, isRoot);\n    const endCell = getClosestCell$1(rng.endContainer, isRoot);\n    return lift2(startCell, endCell, tableCellRng);\n  };\n\n  const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n\n  const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n\n  const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n\n  const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n    if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n      return Optional.none();\n    } else if (selectionDetails.isSameTable) {\n      const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n      return Optional.some({\n        start: sameTableSelection,\n        end: sameTableSelection\n      });\n    } else {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n      const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n      return Optional.some({\n        start: startTableSelection,\n        end: endTableSelection\n      });\n    }\n  };\n\n  const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n\n  const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n\n  const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n\n  const unselectCells = (rng, selectionDetails) => {\n    const {\n      startTable,\n      endTable\n    } = selectionDetails;\n    const otherContentRng = rng.cloneRange();\n    startTable.each(table => otherContentRng.setStartAfter(table.dom));\n    endTable.each(table => otherContentRng.setEndBefore(table.dom));\n    return otherContentRng;\n  };\n\n  const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({\n    start,\n    end\n  }) => start.or(end)).bind(tableSelection => {\n    const {\n      isSameTable\n    } = selectionDetails;\n    const selectedCells = getSelectedCells(tableSelection).getOr([]);\n\n    if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n      return Optional.some(deleteAction.fullTable(tableSelection.table));\n    } else if (selectedCells.length > 0) {\n      if (isSameTable) {\n        return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n      } else {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({ ...selectionDetails,\n          rng: otherContentRng\n        })));\n      }\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({\n    start,\n    end\n  }) => {\n    const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n    const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n\n    if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n      const otherContentRng = unselectCells(rng, selectionDetails);\n      return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const getActionFromRange = (root, rng) => {\n    const isRoot = isRootFromElement(root);\n    const optCellRng = getCellRng(rng, isRoot);\n    const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n\n    if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n      return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n    } else if (selectionDetails.isMultiTable) {\n      return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n    } else {\n      return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n    }\n  };\n\n  const cleanCells = cells => each$e(cells, cell => {\n    remove$a(cell, 'contenteditable');\n    fillWithPaddingBr(cell);\n  });\n\n  const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n\n  const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n    emptyBlock.each(block => {\n      if (startInTable) {\n        remove$5(block);\n      } else {\n        fillWithPaddingBr(block);\n        editor.selection.setCursorLocation(block.dom, 0);\n      }\n    });\n  };\n\n  const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n    const insideTableRng = rng.cloneRange();\n\n    if (isFirstCellInSelection) {\n      insideTableRng.setStart(rng.startContainer, rng.startOffset);\n      insideTableRng.setEndAfter(cell.dom.lastChild);\n    } else {\n      insideTableRng.setStartBefore(cell.dom.firstChild);\n      insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n    }\n\n    deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n  };\n\n  const collapseAndRestoreCellSelection = editor => {\n    const selectedCells = getCellsFromEditor(editor);\n    const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n\n    if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {\n      editor.selection.setCursorLocation(selectedNode.dom, 0);\n    } else {\n      editor.selection.collapse(true);\n    }\n\n    if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n      set$3(selectedNode, 'data-mce-selected', '1');\n    }\n  };\n\n  const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n    const editorRng = editor.selection.getRng();\n    const cellsToClean = outsideDetails.bind(({\n      rng,\n      isStartInTable\n    }) => {\n      const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n      rng.deleteContents();\n      handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n      const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n      deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n\n      if (!isEmpty$2(endPointCell)) {\n        return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n      } else {\n        return Optional.none();\n      }\n    }).getOr(cells);\n    cleanCells(cellsToClean);\n    collapseAndRestoreCellSelection(editor);\n  });\n\n  const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n    const rng = editor.selection.getRng();\n    const startCell = startTableCells[0];\n    const endCell = endTableCells[endTableCells.length - 1];\n    deleteContentInsideCell(editor, startCell, rng, true);\n    deleteContentInsideCell(editor, endCell, rng, false);\n    const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n    const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n    cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n    betweenRng.deleteContents();\n    collapseAndRestoreCellSelection(editor);\n  });\n\n  const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n    deleteRangeContents(editor, rng, cell, moveSelection);\n  });\n\n  const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n\n  const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n\n  const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n\n  const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n\n  const deleteRange$3 = (editor, startElm, selectedCells) => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const rng = editor.selection.getRng();\n    return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n  };\n\n  const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n\n  const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n\n  const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n\n  const emptyElement = (editor, elm) => Optional.some(() => {\n    fillWithPaddingBr(elm);\n    editor.selection.setCursorLocation(elm.dom, 0);\n  });\n\n  const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n\n  const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n\n  const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n\n  const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n\n  const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n  };\n\n  const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n    const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n  };\n\n  const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n\n  const isBeforeOrAfterTable = (editor, forward) => {\n    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n  };\n\n  const deleteCaret$3 = (editor, forward, startElm) => {\n    const rootElm = SugarElement.fromDom(editor.getBody());\n    return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n  };\n\n  const backspaceDelete$a = (editor, forward) => {\n    const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n    const cells = getCellsFromEditor(editor);\n    return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n  };\n\n  const getContentEditableRoot$1 = (root, node) => {\n    let tempNode = node;\n\n    while (tempNode && tempNode !== root) {\n      if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n        return tempNode;\n      }\n\n      tempNode = tempNode.parentNode;\n    }\n\n    return null;\n  };\n\n  const internalAttributesPrefixes = ['data-ephox-', 'data-mce-', 'data-alloy-', 'data-snooker-', '_'];\n  const each$9 = Tools.each;\n\n  const ElementUtils = editor => {\n    const dom = editor.dom;\n    const internalAttributes = new Set(editor.serializer.getTempAttrs());\n\n    const compare = (node1, node2) => {\n      if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n        return false;\n      }\n\n      const getAttribs = node => {\n        const attribs = {};\n        each$9(dom.getAttribs(node), attr => {\n          const name = attr.nodeName.toLowerCase();\n\n          if (name !== 'style' && !isAttributeInternal(name)) {\n            attribs[name] = dom.getAttrib(node, name);\n          }\n        });\n        return attribs;\n      };\n\n      const compareObjects = (obj1, obj2) => {\n        for (const name in obj1) {\n          if (has$2(obj1, name)) {\n            const value = obj2[name];\n\n            if (isUndefined(value)) {\n              return false;\n            }\n\n            if (obj1[name] !== value) {\n              return false;\n            }\n\n            delete obj2[name];\n          }\n        }\n\n        for (const name in obj2) {\n          if (has$2(obj2, name)) {\n            return false;\n          }\n        }\n\n        return true;\n      };\n\n      if (isElement$6(node1) && isElement$6(node2)) {\n        if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n          return false;\n        }\n\n        if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n          return false;\n        }\n      }\n\n      return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n    };\n\n    const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n\n    return {\n      compare,\n      isAttributeInternal\n    };\n  };\n\n  const isHeading = node => ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(node.name);\n\n  const isSummary = node => node.name === 'summary';\n\n  const traverse = (root, fn) => {\n    let node = root;\n\n    while (node = node.walk()) {\n      fn(node);\n    }\n  };\n\n  const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n    const name = node.name;\n\n    for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n      const filter = nodeFilters[ni];\n\n      if (filter.name === name) {\n        const match = matches.nodes[name];\n\n        if (match) {\n          match.nodes.push(node);\n        } else {\n          matches.nodes[name] = {\n            filter,\n            nodes: [node]\n          };\n        }\n      }\n    }\n\n    if (node.attributes) {\n      for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n        const filter = attributeFilters[ai];\n        const attrName = filter.name;\n\n        if (attrName in node.attributes.map) {\n          const match = matches.attributes[attrName];\n\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.attributes[attrName] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n    }\n  };\n\n  const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n    const matches = {\n      nodes: {},\n      attributes: {}\n    };\n\n    if (node.firstChild) {\n      traverse(node, childNode => {\n        matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n      });\n    }\n\n    return matches;\n  };\n\n  const runFilters = (matches, args) => {\n    const run = (matchRecord, filteringAttributes) => {\n      each$d(matchRecord, match => {\n        const nodes = from(match.nodes);\n        each$e(match.filter.callbacks, callback => {\n          for (let i = nodes.length - 1; i >= 0; i--) {\n            const node = nodes[i];\n            const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n\n            if (!valueMatches || isNullable(node.parent)) {\n              nodes.splice(i, 1);\n            }\n          }\n\n          if (nodes.length > 0) {\n            callback(nodes, match.filter.name, args);\n          }\n        });\n      });\n    };\n\n    run(matches.nodes, false);\n    run(matches.attributes, true);\n  };\n\n  const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n    const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n    runFilters(matches, args);\n  };\n\n  const paddEmptyNode = (settings, args, isBlock, node) => {\n    const brPreferred = settings.pad_empty_with_br || args.insert;\n\n    if (brPreferred && isBlock(node)) {\n      const astNode = new AstNode('br', 1);\n\n      if (args.insert) {\n        astNode.attr('data-mce-bogus', '1');\n      }\n\n      node.empty().append(astNode);\n    } else {\n      node.empty().append(new AstNode('#text', 3)).value = nbsp;\n    }\n  };\n\n  const isPaddedWithNbsp = node => {\n    var _a;\n\n    return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n  };\n\n  const hasOnlyChild = (node, name) => {\n    const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n    return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n  };\n\n  const isPadded = (schema, node) => {\n    const rule = schema.getElementRule(node.name);\n    return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n  };\n\n  const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n\n  const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n\n  const findClosestEditingHost = scope => {\n    let editableNode;\n\n    for (let node = scope; node; node = node.parent) {\n      const contentEditable = node.attr('contenteditable');\n\n      if (contentEditable === 'false') {\n        break;\n      } else if (contentEditable === 'true') {\n        editableNode = node;\n      }\n    }\n\n    return Optional.from(editableNode);\n  };\n\n  const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n    if (schema.getSpecialElements()[node.name]) {\n      node.empty().remove();\n    } else {\n      const children = node.children();\n\n      for (const childNode of children) {\n        if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n          removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n        }\n      }\n\n      node.unwrap();\n    }\n  };\n\n  const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n    const textBlockElements = schema.getTextBlockElements();\n    const nonEmptyElements = schema.getNonEmptyElements();\n    const whitespaceElements = schema.getWhitespaceElements();\n    const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n    const fixed = new Set();\n\n    const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n\n    for (let ni = 0; ni < nodes.length; ni++) {\n      const node = nodes[ni];\n      let parent;\n      let newParent;\n      let tempNode;\n\n      if (!node.parent || fixed.has(node)) {\n        continue;\n      }\n\n      if (textBlockElements[node.name] && node.parent.name === 'li') {\n        let sibling = node.next;\n\n        while (sibling) {\n          if (textBlockElements[sibling.name]) {\n            sibling.name = 'li';\n            fixed.add(sibling);\n            node.parent.insert(sibling, node.parent);\n          } else {\n            break;\n          }\n\n          sibling = sibling.next;\n        }\n\n        node.unwrap();\n        continue;\n      }\n\n      const parents = [node];\n\n      for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n        parents.push(parent);\n      }\n\n      if (parent && parents.length > 1) {\n        if (!isInvalid(schema, node, parent)) {\n          parents.reverse();\n          newParent = parents[0].clone();\n          onCreate(newParent);\n          let currentNode = newParent;\n\n          for (let i = 0; i < parents.length - 1; i++) {\n            if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n              tempNode = parents[i].clone();\n              onCreate(tempNode);\n              currentNode.append(tempNode);\n            } else {\n              tempNode = currentNode;\n            }\n\n            for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n              const nextNode = childNode.next;\n              tempNode.append(childNode);\n              childNode = nextNode;\n            }\n\n            currentNode = tempNode;\n          }\n\n          if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n            parent.insert(newParent, parents[0], true);\n            parent.insert(node, newParent);\n          } else {\n            parent.insert(node, parents[0], true);\n          }\n\n          parent = parents[0];\n\n          if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n            parent.empty().remove();\n          }\n        } else {\n          removeOrUnwrapInvalidNode(node, schema);\n        }\n      } else if (node.parent) {\n        if (node.name === 'li') {\n          let sibling = node.prev;\n\n          if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n            sibling.append(node);\n            continue;\n          }\n\n          sibling = node.next;\n\n          if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n            sibling.insert(node, sibling.firstChild, true);\n            continue;\n          }\n\n          const wrapper = new AstNode('ul', 1);\n          onCreate(wrapper);\n          node.wrap(wrapper);\n          continue;\n        }\n\n        if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n          const wrapper = new AstNode('div', 1);\n          onCreate(wrapper);\n          node.wrap(wrapper);\n        } else {\n          removeOrUnwrapInvalidNode(node, schema);\n        }\n      }\n    }\n  };\n\n  const hasClosest = (node, parentName) => {\n    let tempNode = node;\n\n    while (tempNode) {\n      if (tempNode.name === parentName) {\n        return true;\n      }\n\n      tempNode = tempNode.parent;\n    }\n\n    return false;\n  };\n\n  const isInvalid = (schema, node, parent = node.parent) => {\n    if (!parent) {\n      return false;\n    }\n\n    if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n      return true;\n    }\n\n    if (node.name === 'a' && hasClosest(parent, 'a')) {\n      return true;\n    }\n\n    if (isSummary(parent) && isHeading(node)) {\n      return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n    }\n\n    return false;\n  };\n\n  const createRange = (sc, so, ec, eo) => {\n    const rng = document.createRange();\n    rng.setStart(sc, so);\n    rng.setEnd(ec, eo);\n    return rng;\n  };\n\n  const normalizeBlockSelectionRange = rng => {\n    const startPos = CaretPosition.fromRangeStart(rng);\n    const endPos = CaretPosition.fromRangeEnd(rng);\n    const rootNode = rng.commonAncestorContainer;\n    return fromPosition(false, rootNode, endPos).map(newEndPos => {\n      if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n        return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n      } else {\n        return rng;\n      }\n    }).getOr(rng);\n  };\n\n  const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n  const hasOnlyOneChild$1 = node => {\n    return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n  };\n\n  const isPaddingNode = node => {\n    return node.name === 'br' || node.value === nbsp;\n  };\n\n  const isPaddedEmptyBlock = (schema, node) => {\n    const blockElements = schema.getBlockElements();\n    return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n  };\n\n  const isEmptyFragmentElement = (schema, node) => {\n    const nonEmptyElements = schema.getNonEmptyElements();\n    return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n  };\n\n  const isListFragment = (schema, fragment) => {\n    let firstChild = fragment.firstChild;\n    let lastChild = fragment.lastChild;\n\n    if (firstChild && firstChild.name === 'meta') {\n      firstChild = firstChild.next;\n    }\n\n    if (lastChild && lastChild.attr('id') === 'mce_marker') {\n      lastChild = lastChild.prev;\n    }\n\n    if (isEmptyFragmentElement(schema, lastChild)) {\n      lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n    }\n\n    if (!firstChild || firstChild !== lastChild) {\n      return false;\n    }\n\n    return firstChild.name === 'ul' || firstChild.name === 'ol';\n  };\n\n  const cleanupDomFragment = domFragment => {\n    var _a, _b;\n\n    const firstChild = domFragment.firstChild;\n    const lastChild = domFragment.lastChild;\n\n    if (firstChild && firstChild.nodeName === 'META') {\n      (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n    }\n\n    if (lastChild && lastChild.id === 'mce_marker') {\n      (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n    }\n\n    return domFragment;\n  };\n\n  const toDomFragment = (dom, serializer, fragment) => {\n    const html = serializer.serialize(fragment);\n    const domFragment = dom.createFragment(html);\n    return cleanupDomFragment(domFragment);\n  };\n\n  const listItems = elm => {\n    var _a;\n\n    return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n      return child.nodeName === 'LI';\n    });\n  };\n\n  const isPadding = node => {\n    return node.data === nbsp || isBr$6(node);\n  };\n\n  const isListItemPadded = node => {\n    return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n  };\n\n  const isEmptyOrPadded = elm => {\n    return !elm.firstChild || isListItemPadded(elm);\n  };\n\n  const trimListItems = elms => {\n    return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n  };\n\n  const getParentLi = (dom, node) => {\n    const parentBlock = dom.getParent(node, dom.isBlock);\n    return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n  };\n\n  const isParentBlockLi = (dom, node) => {\n    return !!getParentLi(dom, node);\n  };\n\n  const getSplit = (parentNode, rng) => {\n    const beforeRng = rng.cloneRange();\n    const afterRng = rng.cloneRange();\n    beforeRng.setStartBefore(parentNode);\n    afterRng.setEndAfter(parentNode);\n    return [beforeRng.cloneContents(), afterRng.cloneContents()];\n  };\n\n  const findFirstIn = (node, rootNode) => {\n    const caretPos = CaretPosition.before(node);\n    const caretWalker = CaretWalker(rootNode);\n    const newCaretPos = caretWalker.next(caretPos);\n    return newCaretPos ? newCaretPos.toRange() : null;\n  };\n\n  const findLastOf = (node, rootNode) => {\n    const caretPos = CaretPosition.after(node);\n    const caretWalker = CaretWalker(rootNode);\n    const newCaretPos = caretWalker.prev(caretPos);\n    return newCaretPos ? newCaretPos.toRange() : null;\n  };\n\n  const insertMiddle = (target, elms, rootNode, rng) => {\n    const parts = getSplit(target, rng);\n    const parentElm = target.parentNode;\n\n    if (parentElm) {\n      parentElm.insertBefore(parts[0], target);\n      Tools.each(elms, li => {\n        parentElm.insertBefore(li, target);\n      });\n      parentElm.insertBefore(parts[1], target);\n      parentElm.removeChild(target);\n    }\n\n    return findLastOf(elms[elms.length - 1], rootNode);\n  };\n\n  const insertBefore$2 = (target, elms, rootNode) => {\n    const parentElm = target.parentNode;\n\n    if (parentElm) {\n      Tools.each(elms, elm => {\n        parentElm.insertBefore(elm, target);\n      });\n    }\n\n    return findFirstIn(target, rootNode);\n  };\n\n  const insertAfter$2 = (target, elms, rootNode, dom) => {\n    dom.insertAfter(elms.reverse(), target);\n    return findLastOf(elms[0], rootNode);\n  };\n\n  const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n    const domFragment = toDomFragment(dom, serializer, fragment);\n    const liTarget = getParentLi(dom, rng.startContainer);\n    const liElms = trimListItems(listItems(domFragment.firstChild));\n    const BEGINNING = 1,\n          END = 2;\n    const rootNode = dom.getRoot();\n\n    const isAt = location => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const caretWalker = CaretWalker(dom.getRoot());\n      const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n      const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n      return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n    };\n\n    if (!liTarget) {\n      return null;\n    } else if (isAt(BEGINNING)) {\n      return insertBefore$2(liTarget, liElms, rootNode);\n    } else if (isAt(END)) {\n      return insertAfter$2(liTarget, liElms, rootNode, dom);\n    } else {\n      return insertMiddle(liTarget, liElms, rootNode, rng);\n    }\n  };\n\n  const mergeableWrappedElements = ['pre'];\n\n  const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n    var _a;\n\n    const firstNode = fragment.firstChild;\n    const lastNode = fragment.lastChild;\n    const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n    const isPastingSingleElement = firstNode === last;\n    const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n\n    if (isPastingSingleElement && isWrappedElement) {\n      const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n      const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n      const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n      return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n    } else {\n      return false;\n    }\n  };\n\n  const isTableCell = isTableCell$3;\n\n  const isTableCellContentSelected = (dom, rng, cell) => {\n    if (isNonNullable(cell)) {\n      const endCell = dom.getParent(rng.endContainer, isTableCell);\n      return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n    } else {\n      return false;\n    }\n  };\n\n  const validInsertion = (editor, value, parentNode) => {\n    var _a;\n\n    if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n      (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n    } else {\n      const node = parentNode.firstChild;\n      const node2 = parentNode.lastChild;\n\n      if (!node || node === node2 && node.nodeName === 'BR') {\n        editor.dom.setHTML(parentNode, value);\n      } else {\n        editor.selection.setContent(value, {\n          no_events: true\n        });\n      }\n    }\n  };\n\n  const trimBrsFromTableCell = (dom, elm, schema) => {\n    Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n  };\n\n  const reduceInlineTextElements = (editor, merge) => {\n    const textInlineElements = editor.schema.getTextInlineElements();\n    const dom = editor.dom;\n\n    if (merge) {\n      const root = editor.getBody();\n      const elementUtils = ElementUtils(editor);\n      Tools.each(dom.select('*[data-mce-fragment]'), node => {\n        const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n\n        if (isInline && hasInheritableStyles(dom, node)) {\n          for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {\n            const styleConflict = hasStyleConflict(dom, node, parentNode);\n\n            if (styleConflict) {\n              break;\n            }\n\n            if (elementUtils.compare(parentNode, node)) {\n              dom.remove(node, true);\n              break;\n            }\n          }\n        }\n      });\n    }\n  };\n\n  const markFragmentElements = fragment => {\n    let node = fragment;\n\n    while (node = node.walk()) {\n      if (node.type === 1) {\n        node.attr('data-mce-fragment', '1');\n      }\n    }\n  };\n\n  const unmarkFragmentElements = elm => {\n    Tools.each(elm.getElementsByTagName('*'), elm => {\n      elm.removeAttribute('data-mce-fragment');\n    });\n  };\n\n  const isPartOfFragment = node => {\n    return !!node.getAttribute('data-mce-fragment');\n  };\n\n  const canHaveChildren = (editor, node) => {\n    return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n  };\n\n  const moveSelectionToMarker = (editor, marker) => {\n    var _a, _b, _c;\n\n    let nextRng;\n    const dom = editor.dom;\n    const selection = editor.selection;\n\n    if (!marker) {\n      return;\n    }\n\n    selection.scrollIntoView(marker);\n    const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n\n    if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n      dom.remove(marker);\n      selection.select(parentEditableElm);\n      return;\n    }\n\n    let rng = dom.createRng();\n    const node = marker.previousSibling;\n\n    if (isText$a(node)) {\n      rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n      const node2 = marker.nextSibling;\n\n      if (isText$a(node2)) {\n        node.appendData(node2.data);\n        (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n      }\n    } else {\n      rng.setStartBefore(marker);\n      rng.setEndBefore(marker);\n    }\n\n    const findNextCaretRng = rng => {\n      let caretPos = CaretPosition.fromRangeStart(rng);\n      const caretWalker = CaretWalker(editor.getBody());\n      caretPos = caretWalker.next(caretPos);\n      return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n    };\n\n    const parentBlock = dom.getParent(marker, dom.isBlock);\n    dom.remove(marker);\n\n    if (parentBlock && dom.isEmpty(parentBlock)) {\n      const isCell = isTableCell(parentBlock);\n      empty(SugarElement.fromDom(parentBlock));\n      rng.setStart(parentBlock, 0);\n      rng.setEnd(parentBlock, 0);\n\n      if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n        rng = nextRng;\n        dom.remove(parentBlock);\n      } else {\n        dom.add(parentBlock, dom.create('br', isCell ? {} : {\n          'data-mce-bogus': '1'\n        }));\n      }\n    }\n\n    selection.setRng(rng);\n  };\n\n  const deleteSelectedContent = editor => {\n    const dom = editor.dom;\n    const rng = normalize(editor.selection.getRng());\n    editor.selection.setRng(rng);\n    const startCell = dom.getParent(rng.startContainer, isTableCell);\n\n    if (isTableCellContentSelected(dom, rng, startCell)) {\n      deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n    } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {\n      rng.deleteContents();\n    } else {\n      editor.getDoc().execCommand('Delete', false);\n    }\n  };\n\n  const findMarkerNode = scope => {\n    for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n      if (markerNode.attr('id') === 'mce_marker') {\n        return Optional.some(markerNode);\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const notHeadingsInSummary = (dom, node, fragment) => {\n    var _a;\n\n    return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n  };\n\n  const insertHtmlAtCaret = (editor, value, details) => {\n    var _a, _b;\n\n    const selection = editor.selection;\n    const dom = editor.dom;\n    const parser = editor.parser;\n    const merge = details.merge;\n    const serializer = HtmlSerializer({\n      validate: true\n    }, editor.schema);\n    const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n\n    if (!details.preserve_zwsp) {\n      value = trim$2(value);\n    }\n\n    if (value.indexOf('{$caret}') === -1) {\n      value += '{$caret}';\n    }\n\n    value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n    let rng = selection.getRng();\n    const caretElement = rng.startContainer;\n    const body = editor.getBody();\n\n    if (caretElement === body && selection.isCollapsed()) {\n      if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n        rng = dom.createRng();\n        rng.setStart(body.firstChild, 0);\n        rng.setEnd(body.firstChild, 0);\n        selection.setRng(rng);\n      }\n    }\n\n    if (!selection.isCollapsed()) {\n      deleteSelectedContent(editor);\n    }\n\n    const parentNode = selection.getNode();\n    const parserArgs = {\n      context: parentNode.nodeName.toLowerCase(),\n      data: details.data,\n      insert: true\n    };\n    const fragment = parser.parse(value, parserArgs);\n\n    if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n      rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n\n      if (rng) {\n        selection.setRng(rng);\n      }\n\n      return value;\n    }\n\n    if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n      (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n    }\n\n    markFragmentElements(fragment);\n    let node = fragment.lastChild;\n\n    if (node && node.attr('id') === 'mce_marker') {\n      const marker = node;\n\n      for (node = node.prev; node; node = node.walk(true)) {\n        if (node.type === 3 || !dom.isBlock(node.name)) {\n          if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n            node.parent.insert(marker, node, node.name === 'br');\n          }\n\n          break;\n        }\n      }\n    }\n\n    editor._selectionOverrides.showBlockCaretContainer(parentNode);\n\n    if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n      value = serializer.serialize(fragment);\n      validInsertion(editor, value, parentNode);\n    } else {\n      editor.selection.setContent(bookmarkHtml);\n      let parentNode = selection.getNode();\n      let tempNode;\n      const rootNode = editor.getBody();\n\n      if (isDocument$1(parentNode)) {\n        parentNode = tempNode = rootNode;\n      } else {\n        tempNode = parentNode;\n      }\n\n      while (tempNode && tempNode !== rootNode) {\n        parentNode = tempNode;\n        tempNode = tempNode.parentNode;\n      }\n\n      value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n      const root = parser.parse(value);\n      const markerNode = findMarkerNode(root);\n      const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n      markerNode.each(marker => marker.replace(fragment));\n      const toExtract = fragment.children();\n      const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n      fragment.unwrap();\n      const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n      cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n      filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n      value = serializer.serialize(root);\n\n      if (parentNode === rootNode) {\n        dom.setHTML(rootNode, value);\n      } else {\n        dom.setOuterHTML(parentNode, value);\n      }\n    }\n\n    reduceInlineTextElements(editor, merge);\n    moveSelectionToMarker(editor, dom.get('mce_marker'));\n    unmarkFragmentElements(editor.getBody());\n    trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n    updateCaret(editor.schema, editor.getBody(), selection.getStart());\n    return value;\n  };\n\n  const isTreeNode = content => content instanceof AstNode;\n\n  const moveSelection = editor => {\n    if (hasFocus(editor)) {\n      firstPositionIn(editor.getBody()).each(pos => {\n        const node = pos.getNode();\n        const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n        editor.selection.setRng(caretPos.toRange());\n      });\n    }\n  };\n\n  const setEditorHtml = (editor, html, noSelection) => {\n    editor.dom.setHTML(editor.getBody(), html);\n\n    if (noSelection !== true) {\n      moveSelection(editor);\n    }\n  };\n\n  const setContentString = (editor, body, content, args) => {\n    content = trim$2(content);\n\n    if (content.length === 0 || /^\\s+$/.test(content)) {\n      const padd = '<br data-mce-bogus=\"1\">';\n\n      if (body.nodeName === 'TABLE') {\n        content = '<tr><td>' + padd + '</td></tr>';\n      } else if (/^(UL|OL)$/.test(body.nodeName)) {\n        content = '<li>' + padd + '</li>';\n      }\n\n      const forcedRootBlockName = getForcedRootBlock(editor);\n\n      if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n        content = padd;\n        content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n      } else if (!content) {\n        content = padd;\n      }\n\n      setEditorHtml(editor, content, args.no_selection);\n      return {\n        content,\n        html: content\n      };\n    } else {\n      if (args.format !== 'raw') {\n        content = HtmlSerializer({\n          validate: false\n        }, editor.schema).serialize(editor.parser.parse(content, {\n          isRootContent: true,\n          insert: true\n        }));\n      }\n\n      const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content: trimmedHtml,\n        html: trimmedHtml\n      };\n    }\n  };\n\n  const setContentTree = (editor, body, content, args) => {\n    filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n    const html = HtmlSerializer({\n      validate: false\n    }, editor.schema).serialize(content);\n    const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n    setEditorHtml(editor, trimmedHtml, args.no_selection);\n    return {\n      content,\n      html: trimmedHtml\n    };\n  };\n\n  const setContentInternal = (editor, content, args) => {\n    return Optional.from(editor.getBody()).map(body => {\n      if (isTreeNode(content)) {\n        return setContentTree(editor, body, content, args);\n      } else {\n        return setContentString(editor, body, content, args);\n      }\n    }).getOr({\n      content,\n      html: isTreeNode(args.content) ? '' : args.content\n    });\n  };\n\n  const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n\n  const ancestor = (scope, transform, isRoot) => {\n    let element = scope.dom;\n    const stop = ensureIsRoot(isRoot);\n\n    while (element.parentNode) {\n      element = element.parentNode;\n      const el = SugarElement.fromDom(element);\n      const transformed = transform(el);\n\n      if (transformed.isSome()) {\n        return transformed;\n      } else if (stop(el)) {\n        break;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const closest$1 = (scope, transform, isRoot) => {\n    const current = transform(scope);\n    const stop = ensureIsRoot(isRoot);\n    return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n  };\n\n  const isEq$3 = isEq$5;\n\n  const matchesUnInheritedFormatSelector = (ed, node, name) => {\n    const formatList = ed.formatter.get(name);\n\n    if (formatList) {\n      for (let i = 0; i < formatList.length; i++) {\n        const format = formatList[i];\n\n        if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  const matchParents = (editor, node, name, vars, similar) => {\n    const root = editor.dom.getRoot();\n\n    if (node === root) {\n      return false;\n    }\n\n    const matchedNode = editor.dom.getParent(node, elm => {\n      if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n        return true;\n      }\n\n      return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n    });\n    return !!matchNode(editor, matchedNode, name, vars, similar);\n  };\n\n  const matchName = (dom, node, format) => {\n    if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n      return true;\n    }\n\n    if (isBlockFormat(format) && isEq$3(node, format.block)) {\n      return true;\n    }\n\n    if (isSelectorFormat(format)) {\n      return isElement$6(node) && dom.is(node, format.selector);\n    }\n\n    return false;\n  };\n\n  const matchItems = (dom, node, format, itemName, similar, vars) => {\n    const items = format[itemName];\n    const matchAttributes = itemName === 'attributes';\n\n    if (isFunction(format.onmatch)) {\n      return format.onmatch(node, format, itemName);\n    }\n\n    if (items) {\n      if (!isArrayLike(items)) {\n        for (const key in items) {\n          if (has$2(items, key)) {\n            const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n            const expectedValue = replaceVars(items[key], vars);\n            const isEmptyValue = isNullable(value) || isEmpty$3(value);\n\n            if (isEmptyValue && isNullable(expectedValue)) {\n              continue;\n            }\n\n            if (similar && isEmptyValue && !format.exact) {\n              return false;\n            }\n\n            if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n              return false;\n            }\n          }\n        }\n      } else {\n        for (let i = 0; i < items.length; i++) {\n          if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  const matchNode = (ed, node, name, vars, similar) => {\n    const formatList = ed.formatter.get(name);\n    const dom = ed.dom;\n\n    if (formatList && isElement$6(node)) {\n      for (let i = 0; i < formatList.length; i++) {\n        const format = formatList[i];\n\n        if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n          const classes = format.classes;\n\n          if (classes) {\n            for (let x = 0; x < classes.length; x++) {\n              if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                return;\n              }\n            }\n          }\n\n          return format;\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  const match$2 = (editor, name, vars, node, similar) => {\n    if (node) {\n      return matchParents(editor, node, name, vars, similar);\n    }\n\n    node = editor.selection.getNode();\n\n    if (matchParents(editor, node, name, vars, similar)) {\n      return true;\n    }\n\n    const startNode = editor.selection.getStart();\n\n    if (startNode !== node) {\n      if (matchParents(editor, startNode, name, vars, similar)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const matchAll = (editor, names, vars) => {\n    const matchedFormatNames = [];\n    const checkedMap = {};\n    const startElement = editor.selection.getStart();\n    editor.dom.getParent(startElement, node => {\n      for (let i = 0; i < names.length; i++) {\n        const name = names[i];\n\n        if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n          checkedMap[name] = true;\n          matchedFormatNames.push(name);\n        }\n      }\n    }, editor.dom.getRoot());\n    return matchedFormatNames;\n  };\n\n  const closest = (editor, names) => {\n    const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n\n    const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n\n    return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n  };\n\n  const canApply = (editor, name) => {\n    const formatList = editor.formatter.get(name);\n    const dom = editor.dom;\n\n    if (formatList && editor.selection.isEditable()) {\n      const startNode = editor.selection.getStart();\n      const parents = getParents$2(dom, startNode);\n\n      for (let x = formatList.length - 1; x >= 0; x--) {\n        const format = formatList[x];\n\n        if (!isSelectorFormat(format)) {\n          return true;\n        }\n\n        for (let i = parents.length - 1; i >= 0; i--) {\n          if (dom.is(parents[i], format.selector)) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n    const matchSimilar = isVariableFormatName(editor, name);\n\n    if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n      return acc.concat([name]);\n    } else {\n      return acc;\n    }\n  }, []);\n\n  const ZWSP = ZWSP$1;\n\n  const importNode = (ownerDocument, node) => {\n    return ownerDocument.importNode(node, true);\n  };\n\n  const findFirstTextNode = node => {\n    if (node) {\n      const walker = new DomTreeWalker(node, node);\n\n      for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n        if (isText$a(tempNode)) {\n          return tempNode;\n        }\n      }\n    }\n\n    return null;\n  };\n\n  const createCaretContainer = fill => {\n    const caretContainer = SugarElement.fromTag('span');\n    setAll$1(caretContainer, {\n      'id': CARET_ID,\n      'data-mce-bogus': '1',\n      'data-mce-type': 'format-caret'\n    });\n\n    if (fill) {\n      append$1(caretContainer, SugarElement.fromText(ZWSP));\n    }\n\n    return caretContainer;\n  };\n\n  const trimZwspFromCaretContainer = caretContainerNode => {\n    const textNode = findFirstTextNode(caretContainerNode);\n\n    if (textNode && textNode.data.charAt(0) === ZWSP) {\n      textNode.deleteData(0, 1);\n    }\n\n    return textNode;\n  };\n\n  const removeCaretContainerNode = (editor, node, moveCaret) => {\n    const dom = editor.dom,\n          selection = editor.selection;\n\n    if (isCaretContainerEmpty(node)) {\n      deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n    } else {\n      const rng = selection.getRng();\n      const block = dom.getParent(node, dom.isBlock);\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n      const textNode = trimZwspFromCaretContainer(node);\n      dom.remove(node, true);\n\n      if (startContainer === textNode && startOffset > 0) {\n        rng.setStart(textNode, startOffset - 1);\n      }\n\n      if (endContainer === textNode && endOffset > 0) {\n        rng.setEnd(textNode, endOffset - 1);\n      }\n\n      if (block && dom.isEmpty(block)) {\n        fillWithPaddingBr(SugarElement.fromDom(block));\n      }\n\n      selection.setRng(rng);\n    }\n  };\n\n  const removeCaretContainer = (editor, node, moveCaret) => {\n    const dom = editor.dom,\n          selection = editor.selection;\n\n    if (!node) {\n      node = getParentCaretContainer(editor.getBody(), selection.getStart());\n\n      if (!node) {\n        while (node = dom.get(CARET_ID)) {\n          removeCaretContainerNode(editor, node, moveCaret);\n        }\n      }\n    } else {\n      removeCaretContainerNode(editor, node, moveCaret);\n    }\n  };\n\n  const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n    var _a, _b;\n\n    const dom = editor.dom;\n    const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n\n    if (block && dom.isEmpty(block)) {\n      (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n    } else {\n      removeTrailingBr(SugarElement.fromDom(formatNode));\n\n      if (dom.isEmpty(formatNode)) {\n        (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n      } else {\n        dom.insertAfter(caretContainer, formatNode);\n      }\n    }\n  };\n\n  const appendNode = (parentNode, node) => {\n    parentNode.appendChild(node);\n    return node;\n  };\n\n  const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n    var _a;\n\n    const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n      return appendNode(parentNode, formatNode.cloneNode(false));\n    }, caretContainer);\n    const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n  };\n\n  const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n    const formatter = editor.formatter;\n    const dom = editor.dom;\n    const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n    const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n    const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n\n    if (uniqueFormats.length > 0) {\n      const clonedFormatNode = formatNode.cloneNode(false);\n      dom.add(caretContainer, clonedFormatNode);\n      formatter.remove(name, vars, clonedFormatNode, similar);\n      dom.remove(clonedFormatNode);\n      return Optional.some(clonedFormatNode);\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const applyCaretFormat = (editor, name, vars) => {\n    let caretContainer;\n    const selection = editor.selection;\n    const formatList = editor.formatter.get(name);\n\n    if (!formatList) {\n      return;\n    }\n\n    const selectionRng = selection.getRng();\n    let offset = selectionRng.startOffset;\n    const container = selectionRng.startContainer;\n    const text = container.nodeValue;\n    caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n    const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n\n    if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n      const bookmark = selection.getBookmark();\n      selectionRng.collapse(true);\n      let rng = expandRng(editor.dom, selectionRng, formatList);\n      rng = split(rng);\n      editor.formatter.apply(name, vars, rng);\n      selection.moveToBookmark(bookmark);\n    } else {\n      let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n\n      if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n        caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n        textNode = caretContainer.firstChild;\n        selectionRng.insertNode(caretContainer);\n        offset = 1;\n        editor.formatter.apply(name, vars, caretContainer);\n      } else {\n        editor.formatter.apply(name, vars, caretContainer);\n      }\n\n      selection.setCursorLocation(textNode, offset);\n    }\n  };\n\n  const removeCaretFormat = (editor, name, vars, similar) => {\n    const dom = editor.dom;\n    const selection = editor.selection;\n    let hasContentAfter = false;\n    const formatList = editor.formatter.get(name);\n\n    if (!formatList) {\n      return;\n    }\n\n    const rng = selection.getRng();\n    const container = rng.startContainer;\n    const offset = rng.startOffset;\n    let node = container;\n\n    if (isText$a(container)) {\n      if (offset !== container.data.length) {\n        hasContentAfter = true;\n      }\n\n      node = node.parentNode;\n    }\n\n    const parents = [];\n    let formatNode;\n\n    while (node) {\n      if (matchNode(editor, node, name, vars, similar)) {\n        formatNode = node;\n        break;\n      }\n\n      if (node.nextSibling) {\n        hasContentAfter = true;\n      }\n\n      parents.push(node);\n      node = node.parentNode;\n    }\n\n    if (!formatNode) {\n      return;\n    }\n\n    if (hasContentAfter) {\n      const bookmark = selection.getBookmark();\n      rng.collapse(true);\n      let expandedRng = expandRng(dom, rng, formatList, true);\n      expandedRng = split(expandedRng);\n      editor.formatter.remove(name, vars, expandedRng, similar);\n      selection.moveToBookmark(bookmark);\n    } else {\n      const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n      const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n      const newCaretContainer = createCaretContainer(false).dom;\n      insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n      const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n      const caretTextNode = insertFormatNodesIntoCaretContainer([...parents, ...cleanedFormatNode.toArray(), ...parentsAfter], newCaretContainer);\n\n      if (caretContainer) {\n        removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n      }\n\n      selection.setCursorLocation(caretTextNode, 1);\n\n      if (dom.isEmpty(formatNode)) {\n        dom.remove(formatNode);\n      }\n    }\n  };\n\n  const disableCaretContainer = (editor, keyCode, moveCaret) => {\n    const selection = editor.selection,\n          body = editor.getBody();\n    removeCaretContainer(editor, null, moveCaret);\n\n    if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n    }\n\n    if (keyCode === 37 || keyCode === 39) {\n      removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n    }\n  };\n\n  const endsWithNbsp = element => isText$a(element) && endsWith(element.data, nbsp);\n\n  const setup$v = editor => {\n    editor.on('mouseup keydown', e => {\n      disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n    });\n  };\n\n  const createCaretFormat = formatNodes => {\n    const caretContainer = createCaretContainer(false);\n    const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n    return {\n      caretContainer,\n      caretPosition: CaretPosition(innerMost, 0)\n    };\n  };\n\n  const replaceWithCaretFormat = (targetNode, formatNodes) => {\n    const {\n      caretContainer,\n      caretPosition\n    } = createCaretFormat(formatNodes);\n    before$3(SugarElement.fromDom(targetNode), caretContainer);\n    remove$5(SugarElement.fromDom(targetNode));\n    return caretPosition;\n  };\n\n  const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n    const {\n      caretContainer,\n      caretPosition\n    } = createCaretFormat(formatNodes);\n    rng.insertNode(caretContainer.dom);\n    return caretPosition;\n  };\n\n  const isFormatElement = (editor, element) => {\n    if (isCaretNode(element.dom)) {\n      return false;\n    }\n\n    const inlineElements = editor.schema.getTextInlineElements();\n    return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n  };\n\n  const postProcessHooks = {};\n  const isPre = matchNodeNames(['pre']);\n\n  const addPostProcessHook = (name, hook) => {\n    const hooks = postProcessHooks[name];\n\n    if (!hooks) {\n      postProcessHooks[name] = [];\n    }\n\n    postProcessHooks[name].push(hook);\n  };\n\n  const postProcess$1 = (name, editor) => {\n    if (has$2(postProcessHooks, name)) {\n      each$e(postProcessHooks[name], hook => {\n        hook(editor);\n      });\n    }\n  };\n\n  addPostProcessHook('pre', editor => {\n    const rng = editor.selection.getRng();\n\n    const hasPreSibling = blocks => pre => {\n      const prev = pre.previousSibling;\n      return isPre(prev) && contains$2(blocks, prev);\n    };\n\n    const joinPre = (pre1, pre2) => {\n      const sPre2 = SugarElement.fromDom(pre2);\n      const doc = documentOrOwner(sPre2).dom;\n      remove$5(sPre2);\n      append(SugarElement.fromDom(pre1), [SugarElement.fromTag('br', doc), SugarElement.fromTag('br', doc), ...children$1(sPre2)]);\n    };\n\n    if (!rng.collapsed) {\n      const blocks = editor.selection.getSelectedBlocks();\n      const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n      each$e(preBlocks, pre => {\n        joinPre(pre.previousSibling, pre);\n      });\n    }\n  });\n  const listItemStyles = ['fontWeight', 'fontStyle', 'color', 'fontSize', 'fontFamily'];\n\n  const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n\n  const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n\n  const getExpandedListItemFormat = (formatter, format) => {\n    const formatList = formatter.get(format);\n    return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n  };\n\n  const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n\n  const isRngEndAtEndOfElement = (rng, elm) => {\n    return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n  };\n\n  const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n\n  const getFullySelectedBlocks = selection => {\n    const blocks = selection.getSelectedBlocks();\n    const rng = selection.getRng();\n\n    if (selection.isCollapsed()) {\n      return [];\n    }\n\n    if (blocks.length === 1) {\n      return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n    } else {\n      const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n      const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n      const middle = blocks.slice(1, -1);\n      return first.concat(middle).concat(last);\n    }\n  };\n\n  const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n\n  const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n\n  const each$8 = Tools.each;\n\n  const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n\n  const findElementSibling = (node, siblingName) => {\n    for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n      if (isText$a(sibling) && isNotEmpty(sibling.data)) {\n        return node;\n      }\n\n      if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n        return sibling;\n      }\n    }\n\n    return node;\n  };\n\n  const mergeSiblingsNodes = (editor, prev, next) => {\n    const elementUtils = ElementUtils(editor);\n    const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n    const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n\n    if (isPrevEditable && isNextEditable) {\n      const prevSibling = findElementSibling(prev, 'previousSibling');\n      const nextSibling = findElementSibling(next, 'nextSibling');\n\n      if (elementUtils.compare(prevSibling, nextSibling)) {\n        for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n          const tmpSibling = sibling;\n          sibling = sibling.nextSibling;\n          prevSibling.appendChild(tmpSibling);\n        }\n\n        editor.dom.remove(nextSibling);\n        Tools.each(Tools.grep(nextSibling.childNodes), node => {\n          prevSibling.appendChild(node);\n        });\n        return prevSibling;\n      }\n    }\n\n    return next;\n  };\n\n  const mergeSiblings = (editor, format, vars, node) => {\n    var _a;\n\n    if (node && format.merge_siblings !== false) {\n      const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n      mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n    }\n  };\n\n  const clearChildStyles = (dom, format, node) => {\n    if (format.clear_child_styles) {\n      const selector = format.links ? '*:not(a)' : '*';\n      each$8(dom.select(selector, node), childNode => {\n        if (isElementNode(childNode) && dom.isEditable(childNode)) {\n          each$8(format.styles, (_value, name) => {\n            dom.setStyle(childNode, name, '');\n          });\n        }\n      });\n    }\n  };\n\n  const processChildElements = (node, filter, process) => {\n    each$8(node.childNodes, node => {\n      if (isElementNode(node)) {\n        if (filter(node)) {\n          process(node);\n        }\n\n        if (node.hasChildNodes()) {\n          processChildElements(node, filter, process);\n        }\n      }\n    });\n  };\n\n  const unwrapEmptySpan = (dom, node) => {\n    if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n      dom.remove(node, true);\n    }\n  };\n\n  const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n\n  const applyStyle = (dom, name, value) => node => {\n    dom.setStyle(node, name, value);\n\n    if (node.getAttribute('style') === '') {\n      node.removeAttribute('style');\n    }\n\n    unwrapEmptySpan(dom, node);\n  };\n\n  const removeResult = Adt.generate([{\n    keep: []\n  }, {\n    rename: ['name']\n  }, {\n    removed: []\n  }]);\n  const MCE_ATTR_RE = /^(src|href|style)$/;\n  const each$7 = Tools.each;\n  const isEq$2 = isEq$5;\n\n  const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n\n  const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n\n  const getContainer = (ed, rng, start) => {\n    let container = rng[start ? 'startContainer' : 'endContainer'];\n    let offset = rng[start ? 'startOffset' : 'endOffset'];\n\n    if (isElement$6(container)) {\n      const lastIdx = container.childNodes.length - 1;\n\n      if (!start && offset) {\n        offset--;\n      }\n\n      container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n    }\n\n    if (isText$a(container) && start && offset >= container.data.length) {\n      container = new DomTreeWalker(container, ed.getBody()).next() || container;\n    }\n\n    if (isText$a(container) && !start && offset === 0) {\n      container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n    }\n\n    return container;\n  };\n\n  const normalizeTableSelection = (node, start) => {\n    const prop = start ? 'firstChild' : 'lastChild';\n    const childNode = node[prop];\n\n    if (isTableCellOrRow(node) && childNode) {\n      if (node.nodeName === 'TR') {\n        return childNode[prop] || childNode;\n      } else {\n        return childNode;\n      }\n    }\n\n    return node;\n  };\n\n  const wrap$1 = (dom, node, name, attrs) => {\n    var _a;\n\n    const wrapper = dom.create(name, attrs);\n    (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n    wrapper.appendChild(node);\n    return wrapper;\n  };\n\n  const wrapWithSiblings = (dom, node, next, name, attrs) => {\n    const start = SugarElement.fromDom(node);\n    const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n    const siblings = next ? nextSiblings(start) : prevSiblings(start);\n    append(wrapper, siblings);\n\n    if (next) {\n      before$3(start, wrapper);\n      prepend(wrapper, start);\n    } else {\n      after$4(start, wrapper);\n      append$1(wrapper, start);\n    }\n\n    return wrapper.dom;\n  };\n\n  const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n\n  const removeNode = (ed, node, format) => {\n    const parentNode = node.parentNode;\n    let rootBlockElm;\n    const dom = ed.dom;\n    const forcedRootBlock = getForcedRootBlock(ed);\n\n    if (isBlockFormat(format)) {\n      if (parentNode === dom.getRoot()) {\n        if (!format.list_block || !isEq$2(node, format.list_block)) {\n          each$e(from(node.childNodes), node => {\n            if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n              if (!rootBlockElm) {\n                rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n              } else {\n                rootBlockElm.appendChild(node);\n              }\n            } else {\n              rootBlockElm = null;\n            }\n          });\n        }\n      }\n    }\n\n    if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n      return;\n    }\n\n    dom.remove(node, true);\n  };\n\n  const processFormatAttrOrStyle = (name, value, vars) => {\n    if (isNumber(name)) {\n      return {\n        name: value,\n        value: null\n      };\n    } else {\n      return {\n        name,\n        value: replaceVars(value, vars)\n      };\n    }\n  };\n\n  const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n    if (dom.getAttrib(elm, 'style') === '') {\n      elm.removeAttribute('style');\n      elm.removeAttribute('data-mce-style');\n    }\n  };\n\n  const removeStyles = (dom, elm, format, vars, compareNode) => {\n    let stylesModified = false;\n    each$7(format.styles, (value, name) => {\n      const {\n        name: styleName,\n        value: styleValue\n      } = processFormatAttrOrStyle(name, value, vars);\n      const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n\n      if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n        dom.setStyle(elm, styleName, '');\n      }\n\n      stylesModified = true;\n    });\n\n    if (stylesModified) {\n      removeEmptyStyleAttributeIfNeeded(dom, elm);\n    }\n  };\n\n  const removeListStyleFormats = (editor, name, vars) => {\n    if (name === 'removeformat') {\n      each$e(getPartiallySelectedListItems(editor.selection), li => {\n        each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n        removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n      });\n    } else {\n      getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n        each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n      });\n    }\n  };\n\n  const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n    const dom = ed.dom;\n    const elementUtils = ElementUtils(ed);\n    const schema = ed.schema;\n\n    if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n      removeNode(ed, node, format);\n      return removeResult.removed();\n    }\n\n    if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n      return removeResult.keep();\n    }\n\n    if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n      return removeResult.keep();\n    }\n\n    const elm = node;\n    const preserveAttributes = format.preserve_attributes;\n\n    if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n      const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n      dom.removeAllAttribs(elm);\n      each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n\n      if (attrsToPreserve.length > 0) {\n        return removeResult.rename('span');\n      }\n    }\n\n    if (format.remove !== 'all') {\n      removeStyles(dom, elm, format, vars, compareNode);\n      each$7(format.attributes, (value, name) => {\n        const {\n          name: attrName,\n          value: attrValue\n        } = processFormatAttrOrStyle(name, value, vars);\n\n        if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n          if (attrName === 'class') {\n            const currentValue = dom.getAttrib(elm, attrName);\n\n            if (currentValue) {\n              let valueOut = '';\n              each$e(currentValue.split(/\\s+/), cls => {\n                if (/mce\\-\\w+/.test(cls)) {\n                  valueOut += (valueOut ? ' ' : '') + cls;\n                }\n              });\n\n              if (valueOut) {\n                dom.setAttrib(elm, attrName, valueOut);\n                return;\n              }\n            }\n          }\n\n          if (MCE_ATTR_RE.test(attrName)) {\n            elm.removeAttribute('data-mce-' + attrName);\n          }\n\n          if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n            elm.removeAttribute(attrName);\n            dom.setStyle(elm, 'list-style-type', 'none');\n            return;\n          }\n\n          if (attrName === 'class') {\n            elm.removeAttribute('className');\n          }\n\n          elm.removeAttribute(attrName);\n        }\n      });\n      each$7(format.classes, value => {\n        value = replaceVars(value, vars);\n\n        if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n          dom.removeClass(elm, value);\n        }\n      });\n      const attrs = dom.getAttribs(elm);\n\n      for (let i = 0; i < attrs.length; i++) {\n        const attrName = attrs[i].nodeName;\n\n        if (!elementUtils.isAttributeInternal(attrName)) {\n          return removeResult.keep();\n        }\n      }\n    }\n\n    if (format.remove !== 'none') {\n      removeNode(ed, elm, format);\n      return removeResult.removed();\n    }\n\n    return removeResult.keep();\n  };\n\n  const findFormatRoot = (editor, container, name, vars, similar) => {\n    let formatRoot;\n\n    if (container.parentNode) {\n      each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n        if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n          const format = matchNode(editor, parent, name, vars, similar);\n\n          if (format && format.split !== false) {\n            formatRoot = parent;\n          }\n        }\n      });\n    }\n\n    return formatRoot;\n  };\n\n  const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n    const fragment = editor.dom.createFragment();\n    fragment.appendChild(clone);\n    return editor.dom.rename(clone, newName);\n  }, constant(null));\n\n  const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n    var _a, _b;\n\n    let lastClone;\n    let firstClone;\n    const dom = editor.dom;\n\n    if (formatRoot) {\n      const formatRootParent = formatRoot.parentNode;\n\n      for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n        let clone = dom.clone(parent, false);\n\n        for (let i = 0; i < formatList.length; i++) {\n          clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n\n          if (clone === null) {\n            break;\n          }\n        }\n\n        if (clone) {\n          if (lastClone) {\n            clone.appendChild(lastClone);\n          }\n\n          if (!firstClone) {\n            firstClone = clone;\n          }\n\n          lastClone = clone;\n        }\n      }\n\n      if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n        container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n      }\n\n      if (lastClone && firstClone) {\n        (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n        firstClone.appendChild(target);\n\n        if (isInlineFormat(format)) {\n          mergeSiblings(editor, format, vars, lastClone);\n        }\n      }\n    }\n\n    return container;\n  };\n\n  const removeFormatInternal = (ed, name, vars, node, similar) => {\n    const formatList = ed.formatter.get(name);\n    const format = formatList[0];\n    const dom = ed.dom;\n    const selection = ed.selection;\n\n    const splitToFormatRoot = container => {\n      const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n      return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n    };\n\n    const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n\n    const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n\n    const process = node => {\n      const children = from(node.childNodes);\n      const removed = removeFormatOnNode(node);\n      const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n      const parentNode = node.parentNode;\n\n      if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n        removeFormatOnNode(parentNode);\n      }\n\n      if (format.deep) {\n        if (children.length) {\n          for (let i = 0; i < children.length; i++) {\n            process(children[i]);\n          }\n        }\n      }\n\n      const textDecorations = ['underline', 'line-through', 'overline'];\n      each$e(textDecorations, decoration => {\n        if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n          removeNodeFormat(ed, {\n            deep: false,\n            exact: true,\n            inline: 'span',\n            styles: {\n              textDecoration: decoration\n            }\n          }, undefined, node);\n        }\n      });\n    };\n\n    const unwrap = start => {\n      const node = dom.get(start ? '_start' : '_end');\n\n      if (node) {\n        let out = node[start ? 'firstChild' : 'lastChild'];\n\n        if (isRemoveBookmarkNode(out)) {\n          out = out[start ? 'firstChild' : 'lastChild'];\n        }\n\n        if (isText$a(out) && out.data.length === 0) {\n          out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n        }\n\n        dom.remove(node, true);\n        return out;\n      } else {\n        return null;\n      }\n    };\n\n    const removeRngStyle = rng => {\n      let startContainer;\n      let endContainer;\n      let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n\n      if (format.split) {\n        expandedRng = split(expandedRng);\n        startContainer = getContainer(ed, expandedRng, true);\n        endContainer = getContainer(ed, expandedRng);\n\n        if (startContainer !== endContainer) {\n          startContainer = normalizeTableSelection(startContainer, true);\n          endContainer = normalizeTableSelection(endContainer, false);\n\n          if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n            const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n            splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            }));\n            unwrap(true);\n            return;\n          }\n\n          if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n            const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n            splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            }));\n            unwrap(false);\n            return;\n          }\n\n          startContainer = wrap$1(dom, startContainer, 'span', {\n            'id': '_start',\n            'data-mce-type': 'bookmark'\n          });\n          endContainer = wrap$1(dom, endContainer, 'span', {\n            'id': '_end',\n            'data-mce-type': 'bookmark'\n          });\n          const newRng = dom.createRng();\n          newRng.setStartAfter(startContainer);\n          newRng.setEndBefore(endContainer);\n          walk$3(dom, newRng, nodes => {\n            each$e(nodes, n => {\n              if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                splitToFormatRoot(n);\n              }\n            });\n          });\n          splitToFormatRoot(startContainer);\n          splitToFormatRoot(endContainer);\n          startContainer = unwrap(true);\n          endContainer = unwrap();\n        } else {\n          startContainer = endContainer = splitToFormatRoot(startContainer);\n        }\n\n        expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n        expandedRng.startOffset = dom.nodeIndex(startContainer);\n        expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n        expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n      }\n\n      walk$3(dom, expandedRng, nodes => {\n        each$e(nodes, process);\n      });\n    };\n\n    if (node) {\n      if (isNode(node)) {\n        const rng = dom.createRng();\n        rng.setStartBefore(node);\n        rng.setEndAfter(node);\n        removeRngStyle(rng);\n      } else {\n        removeRngStyle(node);\n      }\n\n      fireFormatRemove(ed, name, node, vars);\n      return;\n    }\n\n    if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n      preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n      ed.nodeChanged();\n    } else {\n      removeCaretFormat(ed, name, vars, similar);\n    }\n\n    removeListStyleFormats(ed, name, vars);\n    fireFormatRemove(ed, name, node, vars);\n  };\n\n  const removeFormat$1 = (ed, name, vars, node, similar) => {\n    if (node || ed.selection.isEditable()) {\n      removeFormatInternal(ed, name, vars, node, similar);\n    }\n  };\n\n  const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n    return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n      editor.dom.rename(node, newName);\n      return true;\n    }, always);\n  };\n\n  const each$6 = Tools.each;\n\n  const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n    const processTextDecorationsAndColor = n => {\n      if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n        const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n\n        if (dom.getStyle(n, 'color') && parentTextDecoration) {\n          dom.setStyle(n, 'text-decoration', parentTextDecoration);\n        } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n          dom.setStyle(n, 'text-decoration', null);\n        }\n      }\n    };\n\n    if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n      Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n      processTextDecorationsAndColor(node);\n    }\n  };\n\n  const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n    if (format.styles && format.styles.backgroundColor) {\n      const hasFontSize = hasStyle(dom, 'fontSize');\n      processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n    }\n  };\n\n  const mergeSubSup = (dom, format, vars, node) => {\n    if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n      const hasFontSize = hasStyle(dom, 'fontSize');\n      processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n      const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n      dom.remove(inverseTagDescendants, true);\n    }\n  };\n\n  const mergeWithChildren = (editor, formatList, vars, node) => {\n    each$6(formatList, format => {\n      if (isInlineFormat(format)) {\n        each$6(editor.dom.select(format.inline, node), child => {\n          if (isElementNode(child)) {\n            removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n          }\n        });\n      }\n\n      clearChildStyles(editor.dom, format, node);\n    });\n  };\n\n  const mergeWithParents = (editor, format, name, vars, node) => {\n    const parentNode = node.parentNode;\n\n    if (matchNode(editor, parentNode, name, vars)) {\n      if (removeNodeFormat(editor, format, vars, node)) {\n        return;\n      }\n    }\n\n    if (format.merge_with_parents && parentNode) {\n      editor.dom.getParent(parentNode, parent => {\n        if (matchNode(editor, parent, name, vars)) {\n          removeNodeFormat(editor, format, vars, node);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    }\n  };\n\n  const each$5 = Tools.each;\n\n  const canFormatBR = (editor, format, node, parentName) => {\n    if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n      const validBRParentElements = getTextRootBlockElements(editor.schema);\n      const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n      return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n    } else {\n      return false;\n    }\n  };\n\n  const applyStyles = (dom, elm, format, vars) => {\n    each$5(format.styles, (value, name) => {\n      dom.setStyle(elm, name, replaceVars(value, vars));\n    });\n\n    if (format.styles) {\n      const styleVal = dom.getAttrib(elm, 'style');\n\n      if (styleVal) {\n        dom.setAttrib(elm, 'data-mce-style', styleVal);\n      }\n    }\n  };\n\n  const applyFormatAction = (ed, name, vars, node) => {\n    const formatList = ed.formatter.get(name);\n    const format = formatList[0];\n    const isCollapsed = !node && ed.selection.isCollapsed();\n    const dom = ed.dom;\n    const selection = ed.selection;\n\n    const setElementFormat = (elm, fmt = format) => {\n      if (isFunction(fmt.onformat)) {\n        fmt.onformat(elm, fmt, vars, node);\n      }\n\n      applyStyles(dom, elm, fmt, vars);\n      each$5(fmt.attributes, (value, name) => {\n        dom.setAttrib(elm, name, replaceVars(value, vars));\n      });\n      each$5(fmt.classes, value => {\n        const newValue = replaceVars(value, vars);\n\n        if (!dom.hasClass(elm, newValue)) {\n          dom.addClass(elm, newValue);\n        }\n      });\n    };\n\n    const applyNodeStyle = (formatList, node) => {\n      let found = false;\n      each$5(formatList, format => {\n        if (!isSelectorFormat(format)) {\n          return false;\n        }\n\n        if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n          return true;\n        }\n\n        if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n          return true;\n        }\n\n        if (dom.is(node, format.selector) && !isCaretNode(node)) {\n          setElementFormat(node, format);\n          found = true;\n          return false;\n        }\n\n        return true;\n      });\n      return found;\n    };\n\n    const createWrapElement = wrapName => {\n      if (isString(wrapName)) {\n        const wrapElm = dom.create(wrapName);\n        setElementFormat(wrapElm);\n        return wrapElm;\n      } else {\n        return null;\n      }\n    };\n\n    const applyRngStyle = (dom, rng, nodeSpecific) => {\n      const newWrappers = [];\n      let contentEditable = true;\n      const wrapName = format.inline || format.block;\n      const wrapElm = createWrapElement(wrapName);\n\n      const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n\n      const canRenameBlock = (node, parentName, isEditableDescendant) => {\n        const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n        return isEditableDescendant && isValidBlockFormatForNode;\n      };\n\n      const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n        const nodeName = node.nodeName.toLowerCase();\n        const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n        const isZwsp = !nodeSpecific && isText$a(node) && isZwsp$1(node.data);\n        const isCaret = isCaretNode(node);\n        const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n        return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp && !isCaret && isCorrectFormatForNode;\n      };\n\n      walk$3(dom, rng, nodes => {\n        let currentWrapElm;\n\n        const process = node => {\n          let hasContentEditableState = false;\n          let lastContentEditable = contentEditable;\n          let isWrappableNoneditableElm = false;\n          const parentNode = node.parentNode;\n          const parentName = parentNode.nodeName.toLowerCase();\n          const contentEditableValue = dom.getContentEditable(node);\n\n          if (isNonNullable(contentEditableValue)) {\n            lastContentEditable = contentEditable;\n            contentEditable = contentEditableValue === 'true';\n            hasContentEditableState = true;\n            isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n          }\n\n          const isEditableDescendant = contentEditable && !hasContentEditableState;\n\n          if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n            currentWrapElm = null;\n\n            if (isBlockFormat(format)) {\n              dom.remove(node);\n            }\n\n            return;\n          }\n\n          if (isMatchingWrappingBlock(node)) {\n            currentWrapElm = null;\n            return;\n          }\n\n          if (canRenameBlock(node, parentName, isEditableDescendant)) {\n            const elm = dom.rename(node, wrapName);\n            setElementFormat(elm);\n            newWrappers.push(elm);\n            currentWrapElm = null;\n            return;\n          }\n\n          if (isSelectorFormat(format)) {\n            let found = applyNodeStyle(formatList, node);\n\n            if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n              found = applyNodeStyle(formatList, parentNode);\n            }\n\n            if (!isInlineFormat(format) || found) {\n              currentWrapElm = null;\n              return;\n            }\n          }\n\n          if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n            if (!currentWrapElm) {\n              currentWrapElm = dom.clone(wrapElm, false);\n              parentNode.insertBefore(currentWrapElm, node);\n              newWrappers.push(currentWrapElm);\n            }\n\n            if (isWrappableNoneditableElm && hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n\n            currentWrapElm.appendChild(node);\n          } else {\n            currentWrapElm = null;\n            each$e(from(node.childNodes), process);\n\n            if (hasContentEditableState) {\n              contentEditable = lastContentEditable;\n            }\n\n            currentWrapElm = null;\n          }\n        };\n\n        each$e(nodes, process);\n      });\n\n      if (format.links === true) {\n        each$e(newWrappers, node => {\n          const process = node => {\n            if (node.nodeName === 'A') {\n              setElementFormat(node, format);\n            }\n\n            each$e(from(node.childNodes), process);\n          };\n\n          process(node);\n        });\n      }\n\n      each$e(newWrappers, node => {\n        const getChildCount = node => {\n          let count = 0;\n          each$e(node.childNodes, node => {\n            if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n              count++;\n            }\n          });\n          return count;\n        };\n\n        const mergeStyles = node => {\n          const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n          return childElement.map(child => {\n            const clone = dom.clone(child, false);\n            setElementFormat(clone);\n            dom.replace(clone, node, true);\n            dom.remove(child, true);\n            return clone;\n          }).getOr(node);\n        };\n\n        const childCount = getChildCount(node);\n\n        if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n          dom.remove(node, true);\n          return;\n        }\n\n        if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n          if (!format.exact && childCount === 1) {\n            node = mergeStyles(node);\n          }\n\n          mergeWithChildren(ed, formatList, vars, node);\n          mergeWithParents(ed, format, name, vars, node);\n          mergeBackgroundColorAndFontSize(dom, format, vars, node);\n          mergeTextDecorationsAndColor(dom, format, vars, node);\n          mergeSubSup(dom, format, vars, node);\n          mergeSiblings(ed, format, vars, node);\n        }\n      });\n    };\n\n    const targetNode = isNode(node) ? node : selection.getNode();\n\n    if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n      node = targetNode;\n      applyNodeStyle(formatList, node);\n      fireFormatApply(ed, name, node, vars);\n      return;\n    }\n\n    if (format) {\n      if (node) {\n        if (isNode(node)) {\n          if (!applyNodeStyle(formatList, node)) {\n            const rng = dom.createRng();\n            rng.setStartBefore(node);\n            rng.setEndAfter(node);\n            applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n          }\n        } else {\n          applyRngStyle(dom, node, true);\n        }\n      } else {\n        if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n          selection.setRng(normalize(selection.getRng()));\n          preserveSelection(ed, () => {\n            runOnRanges(ed, (selectionRng, fake) => {\n              const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n              applyRngStyle(dom, expandedRng, false);\n            });\n          }, always);\n          ed.nodeChanged();\n        } else {\n          applyCaretFormat(ed, name, vars);\n        }\n\n        getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n          each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n        });\n      }\n\n      postProcess$1(name, ed);\n    }\n\n    fireFormatApply(ed, name, node, vars);\n  };\n\n  const applyFormat$1 = (editor, name, vars, node) => {\n    if (node || editor.selection.isEditable()) {\n      applyFormatAction(editor, name, vars, node);\n    }\n  };\n\n  const hasVars = value => has$2(value, 'vars');\n\n  const setup$u = (registeredFormatListeners, editor) => {\n    registeredFormatListeners.set({});\n    editor.on('NodeChange', e => {\n      updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n    });\n    editor.on('FormatApply FormatRemove', e => {\n      const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n      updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n    });\n  };\n\n  const fallbackElement = editor => editor.selection.getStart();\n\n  const matchingNode = (editor, parents, format, similar, vars) => {\n    const isMatchingNode = node => {\n      const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n      return !isUndefined(matchingFormat);\n    };\n\n    const isUnableToMatch = node => {\n      if (matchesUnInheritedFormatSelector(editor, node, format)) {\n        return true;\n      } else {\n        if (!similar) {\n          return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n        } else {\n          return false;\n        }\n      }\n    };\n\n    return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n  };\n\n  const getParents = (editor, elm) => {\n    const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n    return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n  };\n\n  const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n    const parents = getParents(editor, elm);\n    each$d(registeredCallbacks, (data, format) => {\n      const runIfChanged = spec => {\n        const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n        const isSet = match.isSome();\n\n        if (spec.state.get() !== isSet) {\n          spec.state.set(isSet);\n          const node = match.getOr(elm);\n\n          if (hasVars(spec)) {\n            spec.callback(isSet, {\n              node,\n              format,\n              parents\n            });\n          } else {\n            each$e(spec.callbacks, callback => callback(isSet, {\n              node,\n              format,\n              parents\n            }));\n          }\n        }\n      };\n\n      each$e([data.withSimilar, data.withoutSimilar], runIfChanged);\n      each$e(data.withVars, runIfChanged);\n    });\n  };\n\n  const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n    const formatChangeItems = registeredFormatListeners.get();\n    each$e(formats.split(','), format => {\n      const group = get$a(formatChangeItems, format).getOrThunk(() => {\n        const base = {\n          withSimilar: {\n            state: Cell(false),\n            similar: true,\n            callbacks: []\n          },\n          withoutSimilar: {\n            state: Cell(false),\n            similar: false,\n            callbacks: []\n          },\n          withVars: []\n        };\n        formatChangeItems[format] = base;\n        return base;\n      });\n\n      const getCurrent = () => {\n        const parents = getParents(editor);\n        return matchingNode(editor, parents, format, similar, vars).isSome();\n      };\n\n      if (isUndefined(vars)) {\n        const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n        toAppendTo.callbacks.push(callback);\n\n        if (toAppendTo.callbacks.length === 1) {\n          toAppendTo.state.set(getCurrent());\n        }\n      } else {\n        group.withVars.push({\n          state: Cell(getCurrent()),\n          similar,\n          vars,\n          callback\n        });\n      }\n    });\n    registeredFormatListeners.set(formatChangeItems);\n  };\n\n  const removeListeners = (registeredFormatListeners, formats, callback) => {\n    const formatChangeItems = registeredFormatListeners.get();\n    each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n      formatChangeItems[format] = {\n        withSimilar: { ...group.withSimilar,\n          callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n        },\n        withoutSimilar: { ...group.withoutSimilar,\n          callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n        },\n        withVars: filter$5(group.withVars, item => item.callback !== callback)\n      };\n    }));\n    registeredFormatListeners.set(formatChangeItems);\n  };\n\n  const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n    addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n    return {\n      unbind: () => removeListeners(registeredFormatListeners, formats, callback)\n    };\n  };\n\n  const toggle = (editor, name, vars, node) => {\n    const fmt = editor.formatter.get(name);\n\n    if (fmt) {\n      if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n        removeFormat$1(editor, name, vars, node);\n      } else {\n        applyFormat$1(editor, name, vars, node);\n      }\n    }\n  };\n\n  const explode$1 = Tools.explode;\n\n  const create$8 = () => {\n    const filters = {};\n\n    const addFilter = (name, callback) => {\n      each$e(explode$1(name), name => {\n        if (!has$2(filters, name)) {\n          filters[name] = {\n            name,\n            callbacks: []\n          };\n        }\n\n        filters[name].callbacks.push(callback);\n      });\n    };\n\n    const getFilters = () => values(filters);\n\n    const removeFilter = (name, callback) => {\n      each$e(explode$1(name), name => {\n        if (has$2(filters, name)) {\n          if (isNonNullable(callback)) {\n            const filter = filters[name];\n            const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n\n            if (newCallbacks.length > 0) {\n              filter.callbacks = newCallbacks;\n            } else {\n              delete filters[name];\n            }\n          } else {\n            delete filters[name];\n          }\n        }\n      });\n    };\n\n    return {\n      addFilter,\n      getFilters,\n      removeFilter\n    };\n  };\n\n  const removeAttrs = (node, names) => {\n    each$e(names, name => {\n      node.attr(name, null);\n    });\n  };\n\n  const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n    domParser.addNodeFilter('font', nodes => {\n      each$e(nodes, node => {\n        const props = styles.parse(node.attr('style'));\n        const color = node.attr('color');\n        const face = node.attr('face');\n        const size = node.attr('size');\n\n        if (color) {\n          props.color = color;\n        }\n\n        if (face) {\n          props['font-family'] = face;\n        }\n\n        if (size) {\n          toInt(size).each(num => {\n            props['font-size'] = fontSizes[num - 1];\n          });\n        }\n\n        node.name = 'span';\n        node.attr('style', styles.serialize(props));\n        removeAttrs(node, ['color', 'face', 'size']);\n      });\n    });\n  };\n\n  const addStrikeFilter = (domParser, schema, styles) => {\n    domParser.addNodeFilter('strike', nodes => {\n      const convertToSTag = schema.type !== 'html4';\n      each$e(nodes, node => {\n        if (convertToSTag) {\n          node.name = 's';\n        } else {\n          const props = styles.parse(node.attr('style'));\n          props['text-decoration'] = 'line-through';\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n        }\n      });\n    });\n  };\n\n  const addFilters = (domParser, settings, schema) => {\n    var _a;\n\n    const styles = Styles();\n\n    if (settings.convert_fonts_to_spans) {\n      addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n    }\n\n    addStrikeFilter(domParser, schema, styles);\n  };\n\n  const register$5 = (domParser, settings, schema) => {\n    if (settings.inline_styles) {\n      addFilters(domParser, settings, schema);\n    }\n  };\n\n  const addNodeFilter = (settings, htmlParser, schema) => {\n    htmlParser.addNodeFilter('br', (nodes, _, args) => {\n      const blockElements = Tools.extend({}, schema.getBlockElements());\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      blockElements.body = 1;\n\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        let node = nodes[i];\n        let parent = node.parent;\n\n        if (parent && isBlock(parent) && node === parent.lastChild) {\n          let prev = node.prev;\n\n          while (prev) {\n            const prevName = prev.name;\n\n            if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n              if (prevName === 'br') {\n                node = null;\n              }\n\n              break;\n            }\n\n            prev = prev.prev;\n          }\n\n          if (node) {\n            node.remove();\n\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n              const elementRule = schema.getElementRule(parent.name);\n\n              if (elementRule) {\n                if (elementRule.removeEmpty) {\n                  parent.remove();\n                } else if (elementRule.paddEmpty) {\n                  paddEmptyNode(settings, args, isBlock, parent);\n                }\n              }\n            }\n          }\n        } else {\n          let lastParent = node;\n\n          while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n            lastParent = parent;\n\n            if (blockElements[parent.name]) {\n              break;\n            }\n\n            parent = parent.parent;\n          }\n\n          if (lastParent === parent) {\n            const textNode = new AstNode('#text', 3);\n            textNode.value = nbsp;\n            node.replace(textNode);\n          }\n        }\n      }\n    });\n  };\n\n  const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n    message: `Cannot convert ${url} to Blob. Resource might not exist or is inaccessible.`,\n    uriType: 'blob'\n  }));\n\n  const extractBase64Data = data => {\n    const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n    return matches ? matches[1] : '';\n  };\n\n  const parseDataUri = uri => {\n    const [type, ...rest] = uri.split(',');\n    const data = rest.join(',');\n    const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n\n    if (matches) {\n      const base64Encoded = matches[2] === ';base64';\n      const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n      return Optional.some({\n        type: matches[1],\n        data: extractedData,\n        base64Encoded\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const buildBlob = (type, data, base64Encoded = true) => {\n    let str = data;\n\n    if (base64Encoded) {\n      try {\n        str = atob(data);\n      } catch (e) {\n        return Optional.none();\n      }\n    }\n\n    const arr = new Uint8Array(str.length);\n\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = str.charCodeAt(i);\n    }\n\n    return Optional.some(new Blob([arr], {\n      type\n    }));\n  };\n\n  const dataUriToBlob = uri => {\n    return new Promise((resolve, reject) => {\n      parseDataUri(uri).bind(({\n        type,\n        data,\n        base64Encoded\n      }) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n    });\n  };\n\n  const uriToBlob = url => {\n    if (startsWith(url, 'blob:')) {\n      return blobUriToBlob(url);\n    } else if (startsWith(url, 'data:')) {\n      return dataUriToBlob(url);\n    } else {\n      return Promise.reject('Unknown URI format');\n    }\n  };\n\n  const blobToDataUri = blob => {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n\n      reader.onloadend = () => {\n        resolve(reader.result);\n      };\n\n      reader.onerror = () => {\n        var _a;\n\n        reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n      };\n\n      reader.readAsDataURL(blob);\n    });\n  };\n\n  let count$1 = 0;\n\n  const uniqueId$1 = prefix => {\n    return (prefix || 'blobid') + count$1++;\n  };\n\n  const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n    return parseDataUri(dataUri).bind(({\n      data,\n      type,\n      base64Encoded\n    }) => {\n      if (base64Only && !base64Encoded) {\n        return Optional.none();\n      } else {\n        const base64 = base64Encoded ? data : btoa(data);\n        return generateBlobInfo(base64, type);\n      }\n    });\n  };\n\n  const createBlobInfo$1 = (blobCache, blob, base64) => {\n    const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n    blobCache.add(blobInfo);\n    return blobInfo;\n  };\n\n  const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n    return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n  };\n\n  const imageToBlobInfo = (blobCache, imageSrc) => {\n    const invalidDataUri = () => Promise.reject('Invalid data URI');\n\n    if (startsWith(imageSrc, 'blob:')) {\n      const blobInfo = blobCache.getByUri(imageSrc);\n\n      if (isNonNullable(blobInfo)) {\n        return Promise.resolve(blobInfo);\n      } else {\n        return uriToBlob(imageSrc).then(blob => {\n          return blobToDataUri(blob).then(dataUri => {\n            return processDataUri(dataUri, false, base64 => {\n              return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n            }).getOrThunk(invalidDataUri);\n          });\n        });\n      }\n    } else if (startsWith(imageSrc, 'data:')) {\n      return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n    } else {\n      return Promise.reject('Unknown image data format');\n    }\n  };\n\n  const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n\n  const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n\n  const registerBase64ImageFilter = (parser, settings) => {\n    const {\n      blob_cache: blobCache\n    } = settings;\n\n    if (blobCache) {\n      const processImage = img => {\n        const inputSrc = img.attr('src');\n\n        if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n          return;\n        }\n\n        dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n          img.attr('src', blobInfo.blobUri());\n        });\n      };\n\n      parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n    }\n  };\n\n  const isMimeType = (mime, type) => startsWith(mime, `${type}/`);\n\n  const createSafeEmbed = (mime, src, width, height, sandboxIframes) => {\n    let name;\n\n    if (isUndefined(mime)) {\n      name = 'iframe';\n    } else if (isMimeType(mime, 'image')) {\n      name = 'img';\n    } else if (isMimeType(mime, 'video')) {\n      name = 'video';\n    } else if (isMimeType(mime, 'audio')) {\n      name = 'audio';\n    } else {\n      name = 'iframe';\n    }\n\n    const embed = new AstNode(name, 1);\n    embed.attr(name === 'audio' ? {\n      src\n    } : {\n      src,\n      width,\n      height\n    });\n\n    if (name === 'audio' || name === 'video') {\n      embed.attr('controls', '');\n    }\n\n    if (name === 'iframe' && sandboxIframes) {\n      embed.attr('sandbox', '');\n    }\n\n    return embed;\n  };\n\n  const register$4 = (parser, settings) => {\n    const schema = parser.schema;\n\n    if (settings.remove_trailing_brs) {\n      addNodeFilter(settings, parser, schema);\n    }\n\n    parser.addAttributeFilter('href', nodes => {\n      let i = nodes.length;\n\n      const appendRel = rel => {\n        const parts = rel.split(' ').filter(p => p.length > 0);\n        return parts.concat(['noopener']).sort().join(' ');\n      };\n\n      const addNoOpener = rel => {\n        const newRel = rel ? Tools.trim(rel) : '';\n\n        if (!/\\b(noopener)\\b/g.test(newRel)) {\n          return appendRel(newRel);\n        } else {\n          return newRel;\n        }\n      };\n\n      if (!settings.allow_unsafe_link_target) {\n        while (i--) {\n          const node = nodes[i];\n\n          if (node.name === 'a' && node.attr('target') === '_blank') {\n            node.attr('rel', addNoOpener(node.attr('rel')));\n          }\n        }\n      }\n    });\n\n    if (!settings.allow_html_in_named_anchor) {\n      parser.addAttributeFilter('id,name', nodes => {\n        let i = nodes.length,\n            sibling,\n            prevSibling,\n            parent,\n            node;\n\n        while (i--) {\n          node = nodes[i];\n\n          if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n            parent = node.parent;\n            sibling = node.lastChild;\n\n            while (sibling && parent) {\n              prevSibling = sibling.prev;\n              parent.insert(sibling, node);\n              sibling = prevSibling;\n            }\n          }\n        }\n      });\n    }\n\n    if (settings.fix_list_elements) {\n      parser.addNodeFilter('ul,ol', nodes => {\n        let i = nodes.length,\n            node,\n            parentNode;\n\n        while (i--) {\n          node = nodes[i];\n          parentNode = node.parent;\n\n          if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n            if (node.prev && node.prev.name === 'li') {\n              node.prev.append(node);\n            } else {\n              const li = new AstNode('li', 1);\n              li.attr('style', 'list-style-type: none');\n              node.wrap(li);\n            }\n          }\n        }\n      });\n    }\n\n    const validClasses = schema.getValidClasses();\n\n    if (settings.validate && validClasses) {\n      parser.addAttributeFilter('class', nodes => {\n        var _a;\n\n        let i = nodes.length;\n\n        while (i--) {\n          const node = nodes[i];\n          const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n          const classList = Tools.explode(clazz, ' ');\n          let classValue = '';\n\n          for (let ci = 0; ci < classList.length; ci++) {\n            const className = classList[ci];\n            let valid = false;\n            let validClassesMap = validClasses['*'];\n\n            if (validClassesMap && validClassesMap[className]) {\n              valid = true;\n            }\n\n            validClassesMap = validClasses[node.name];\n\n            if (!valid && validClassesMap && validClassesMap[className]) {\n              valid = true;\n            }\n\n            if (valid) {\n              if (classValue) {\n                classValue += ' ';\n              }\n\n              classValue += className;\n            }\n          }\n\n          if (!classValue.length) {\n            classValue = null;\n          }\n\n          node.attr('class', classValue);\n        }\n      });\n    }\n\n    registerBase64ImageFilter(parser, settings);\n\n    if (settings.convert_unsafe_embeds) {\n      parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n        node.replace(createSafeEmbed(node.attr('type'), node.name === 'object' ? node.attr('data') : node.attr('src'), node.attr('width'), node.attr('height'), settings.sandbox_iframes));\n      }));\n    }\n\n    if (settings.sandbox_iframes) {\n      parser.addNodeFilter('iframe', nodes => each$e(nodes, node => node.attr('sandbox', '')));\n    }\n  };\n\n  const {\n    entries,\n    setPrototypeOf,\n    isFrozen,\n    getPrototypeOf,\n    getOwnPropertyDescriptor\n  } = Object;\n  let {\n    freeze,\n    seal,\n    create: create$7\n  } = Object;\n  let {\n    apply,\n    construct\n  } = typeof Reflect !== 'undefined' && Reflect;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new Func(...args);\n    };\n  }\n\n  const arrayForEach = unapply(Array.prototype.forEach);\n  const arrayPop = unapply(Array.prototype.pop);\n  const arrayPush = unapply(Array.prototype.push);\n  const stringToLowerCase = unapply(String.prototype.toLowerCase);\n  const stringToString = unapply(String.prototype.toString);\n  const stringMatch = unapply(String.prototype.match);\n  const stringReplace = unapply(String.prototype.replace);\n  const stringIndexOf = unapply(String.prototype.indexOf);\n  const stringTrim = unapply(String.prototype.trim);\n  const regExpTest = unapply(RegExp.prototype.test);\n  const typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  function addToSet(set, array, transformCaseFunc) {\n    var _transformCaseFunc;\n\n    transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n\n    if (setPrototypeOf) {\n      setPrototypeOf(set, null);\n    }\n\n    let l = array.length;\n\n    while (l--) {\n      let element = array[l];\n\n      if (typeof element === 'string') {\n        const lcElement = transformCaseFunc(element);\n\n        if (lcElement !== element) {\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  function clone(object) {\n    const newObject = create$7(null);\n\n    for (const [property, value] of entries(object)) {\n      newObject[property] = value;\n    }\n\n    return newObject;\n  }\n\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      const desc = getOwnPropertyDescriptor(object, prop);\n\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    function fallbackValue(element) {\n      console.warn('fallback value for', element);\n      return null;\n    }\n\n    return fallbackValue;\n  }\n\n  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  const text = freeze(['#text']);\n  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);\n  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n  const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n  const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n  const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n  const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n  const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n  const DOCTYPE_NAME = seal(/^html$/i);\n  var EXPRESSIONS = Object.freeze({\n    __proto__: null,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    ERB_EXPR: ERB_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR,\n    DATA_ATTR: DATA_ATTR,\n    ARIA_ATTR: ARIA_ATTR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    DOCTYPE_NAME: DOCTYPE_NAME\n  });\n\n  const getGlobal = () => typeof window === 'undefined' ? null : window;\n\n  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    let suffix = null;\n    const ATTR_NAME = 'data-tt-policy-suffix';\n\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n\n    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML(html) {\n          return html;\n        },\n\n        createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n\n      });\n    } catch (_) {\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    const DOMPurify = root => createDOMPurify(root);\n\n    DOMPurify.version = '3.0.5';\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n\n    const originalDocument = window.document;\n    const currentScript = originalDocument.currentScript;\n    let {\n      document\n    } = window;\n    const {\n      DocumentFragment,\n      HTMLTemplateElement,\n      Node,\n      Element,\n      NodeFilter,\n      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n      HTMLFormElement,\n      DOMParser,\n      trustedTypes\n    } = window;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    if (typeof HTMLTemplateElement === 'function') {\n      const template = document.createElement('template');\n\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    let trustedTypesPolicy;\n    let emptyHTML = '';\n    const {\n      implementation,\n      createNodeIterator,\n      createDocumentFragment,\n      getElementsByTagName\n    } = document;\n    const {\n      importNode\n    } = originalDocument;\n    let hooks = {};\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    const {\n      MUSTACHE_EXPR,\n      ERB_EXPR,\n      TMPLIT_EXPR,\n      DATA_ATTR,\n      ARIA_ATTR,\n      IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE\n    } = EXPRESSIONS;\n    let {\n      IS_ALLOWED_URI: IS_ALLOWED_URI$1\n    } = EXPRESSIONS;\n    let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n    let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n    let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    let FORBID_TAGS = null;\n    let FORBID_ATTR = null;\n    let ALLOW_ARIA_ATTR = true;\n    let ALLOW_DATA_ATTR = true;\n    let ALLOW_UNKNOWN_PROTOCOLS = false;\n    let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    let SAFE_FOR_TEMPLATES = false;\n    let WHOLE_DOCUMENT = false;\n    let SET_CONFIG = false;\n    let FORCE_BODY = false;\n    let RETURN_DOM = false;\n    let RETURN_DOM_FRAGMENT = false;\n    let RETURN_TRUSTED_TYPE = false;\n    let SANITIZE_DOM = true;\n    let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n    let KEEP_CONTENT = true;\n    let IN_PLACE = false;\n    let USE_PROFILES = {};\n    let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n    let PARSER_MEDIA_TYPE;\n    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    let transformCaseFunc;\n    let CONFIG = null;\n    const formElement = document.createElement('form');\n\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n\n    const _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n      RETURN_DOM = cfg.RETURN_DOM || false;\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n      FORCE_BODY = cfg.FORCE_BODY || false;\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n      IN_PLACE = cfg.IN_PLACE || false;\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [...text]);\n        ALLOWED_ATTR = [];\n\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        }\n\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        }\n\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      }\n\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    const HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    const ALL_SVG_TAGS = addToSet({}, svg$1);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n    const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    const _checkValidNamespace = function _checkValidNamespace(element) {\n      let parent = getParentNode(element);\n\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      const tagName = stringToLowerCase(element.tagName);\n      const parentTagName = stringToLowerCase(parent.tagName);\n\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      }\n\n      return false;\n    };\n\n    const _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n\n      try {\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        node.remove();\n      }\n    };\n\n    const _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n\n      if (name === 'is' && !ALLOWED_ATTR[name]) {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(node);\n          } catch (_) {}\n        } else {\n          try {\n            node.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n\n    const _initDocument = function _initDocument(dirty) {\n      let doc;\n      let leadingWhitespace;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n\n      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {}\n      }\n\n      const body = doc.body || doc.documentElement;\n\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n\n    const _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n    };\n\n    const _isClobbered = function _isClobbered(elm) {\n      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n    };\n\n    const _isNode = function _isNode(object) {\n      return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], hook => {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    const _sanitizeElements = function _sanitizeElements(currentNode) {\n      let content;\n\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      const tagName = transformCaseFunc(currentNode.nodeName);\n\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n        }\n\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n          if (childNodes && parentNode) {\n            const childCount = childNodes.length;\n\n            for (let i = childCount - 1; i >= 0; --i) {\n              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n            }\n          }\n        }\n\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n\n        return true;\n      }\n\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR, ' ');\n        content = stringReplace(content, ERB_EXPR, ' ');\n        content = stringReplace(content, TMPLIT_EXPR, ' ');\n\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;else {\n          return false;\n        }\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;else if (value) {\n        return false;\n      } else ;\n      return true;\n    };\n\n    const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n      return tagName.indexOf('-') > 0;\n    };\n\n    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      let attr;\n      let value;\n      let lcName;\n      let l;\n\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      const {\n        attributes\n      } = currentNode;\n\n      if (!attributes) {\n        return;\n      }\n\n      const hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      while (l--) {\n        attr = attributes[l];\n        const {\n          name,\n          namespaceURI\n        } = attr;\n        value = name === 'value' ? attr.value : stringTrim(attr.value);\n        const initValue = value;\n        lcName = transformCaseFunc(name);\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined;\n\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n\n        value = hookEvent.attrValue;\n\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        if (!hookEvent.keepAttr) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR, ' ');\n          value = stringReplace(value, ERB_EXPR, ' ');\n          value = stringReplace(value, TMPLIT_EXPR, ' ');\n        }\n\n        const lcTag = transformCaseFunc(currentNode.nodeName);\n\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          _removeAttribute(name, currentNode);\n\n          continue;\n        }\n\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          _removeAttribute(name, currentNode);\n\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ;else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n\n        if (value !== initValue) {\n          try {\n            if (namespaceURI) {\n              currentNode.setAttributeNS(namespaceURI, name, value);\n            } else {\n              currentNode.setAttribute(name, value);\n            }\n          } catch (_) {\n            _removeAttribute(name, currentNode);\n          }\n        }\n      }\n\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      let shadowNode;\n\n      const shadowIterator = _createIterator(fragment);\n\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        _sanitizeAttributes(shadowNode);\n      }\n\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    DOMPurify.sanitize = function (dirty) {\n      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let body;\n      let importedNode;\n      let currentNode;\n      let returnNode;\n      IS_EMPTY_INPUT = !dirty;\n\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      DOMPurify.removed = [];\n\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) {\n        if (dirty.nodeName) {\n          const tagName = transformCaseFunc(dirty.nodeName);\n\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          body.appendChild(importedNode);\n        }\n      } else {\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        body = _initDocument(dirty);\n\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      while (currentNode = nodeIterator.nextNode()) {\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        _sanitizeAttributes(currentNode);\n      }\n\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n\n      SET_CONFIG = true;\n    };\n\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      const lcTag = transformCaseFunc(tag);\n      const lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        return arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n  const each$4 = Tools.each,\n        trim = Tools.trim;\n  const queryParts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n  const DEFAULT_PORTS = {\n    ftp: 21,\n    http: 80,\n    https: 443,\n    mailto: 25\n  };\n  const safeSvgDataUrlElements = ['img', 'video'];\n\n  const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n    if (isNonNullable(allowSvgDataUrls)) {\n      return !allowSvgDataUrls;\n    } else {\n      return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n    }\n  };\n\n  const decodeUri = encodedUri => {\n    try {\n      return decodeURIComponent(encodedUri);\n    } catch (ex) {\n      return unescape(encodedUri);\n    }\n  };\n\n  const isInvalidUri = (settings, uri, tagName) => {\n    const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n\n    if (settings.allow_script_urls) {\n      return false;\n    } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n      return true;\n    } else if (settings.allow_html_data_urls) {\n      return false;\n    } else if (/^data:image\\//i.test(decodedUri)) {\n      return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n    } else {\n      return /^data:/i.test(decodedUri);\n    }\n  };\n\n  class URI {\n    static parseDataUri(uri) {\n      let type;\n      const uriComponents = decodeURIComponent(uri).split(',');\n      const matches = /data:([^;]+)/.exec(uriComponents[0]);\n\n      if (matches) {\n        type = matches[1];\n      }\n\n      return {\n        type,\n        data: uriComponents[1]\n      };\n    }\n\n    static isDomSafe(uri, context, options = {}) {\n      if (options.allow_script_urls) {\n        return true;\n      } else {\n        const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n        return !isInvalidUri(options, decodedUri, context);\n      }\n    }\n\n    static getDocumentBaseUrl(loc) {\n      var _a;\n\n      let baseUrl;\n\n      if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n        baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n      } else {\n        baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n      }\n\n      if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n        baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n\n        if (!/[\\/\\\\]$/.test(baseUrl)) {\n          baseUrl += '/';\n        }\n      }\n\n      return baseUrl;\n    }\n\n    constructor(url, settings = {}) {\n      this.path = '';\n      this.directory = '';\n      url = trim(url);\n      this.settings = settings;\n      const baseUri = settings.base_uri;\n      const self = this;\n\n      if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n        self.source = url;\n        return;\n      }\n\n      const isProtocolRelative = url.indexOf('//') === 0;\n\n      if (url.indexOf('/') === 0 && !isProtocolRelative) {\n        url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n      }\n\n      if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n        const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n\n        if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n          url = '//mce_host' + self.toAbsPath(baseUrl, url);\n        } else {\n          const match = /([^#?]*)([#?]?.*)/.exec(url);\n\n          if (match) {\n            url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n          }\n        }\n      }\n\n      url = url.replace(/@@/g, '(mce_at)');\n      const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n\n      if (urlMatch) {\n        each$4(queryParts, (v, i) => {\n          let part = urlMatch[i];\n\n          if (part) {\n            part = part.replace(/\\(mce_at\\)/g, '@@');\n          }\n\n          self[v] = part;\n        });\n      }\n\n      if (baseUri) {\n        if (!self.protocol) {\n          self.protocol = baseUri.protocol;\n        }\n\n        if (!self.userInfo) {\n          self.userInfo = baseUri.userInfo;\n        }\n\n        if (!self.port && self.host === 'mce_host') {\n          self.port = baseUri.port;\n        }\n\n        if (!self.host || self.host === 'mce_host') {\n          self.host = baseUri.host;\n        }\n\n        self.source = '';\n      }\n\n      if (isProtocolRelative) {\n        self.protocol = '';\n      }\n    }\n\n    setPath(path) {\n      const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n\n      if (pathMatch) {\n        this.path = pathMatch[0];\n        this.directory = pathMatch[1];\n        this.file = pathMatch[2];\n      }\n\n      this.source = '';\n      this.getURI();\n    }\n\n    toRelative(uri) {\n      if (uri === './') {\n        return uri;\n      }\n\n      const relativeUri = new URI(uri, {\n        base_uri: this\n      });\n\n      if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n        return relativeUri.getURI();\n      }\n\n      const tu = this.getURI(),\n            uu = relativeUri.getURI();\n\n      if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n        return tu;\n      }\n\n      let output = this.toRelPath(this.path, relativeUri.path);\n\n      if (relativeUri.query) {\n        output += '?' + relativeUri.query;\n      }\n\n      if (relativeUri.anchor) {\n        output += '#' + relativeUri.anchor;\n      }\n\n      return output;\n    }\n\n    toAbsolute(uri, noHost) {\n      const absoluteUri = new URI(uri, {\n        base_uri: this\n      });\n      return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n    }\n\n    isSameOrigin(uri) {\n      if (this.host == uri.host && this.protocol == uri.protocol) {\n        if (this.port == uri.port) {\n          return true;\n        }\n\n        const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n\n        if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    toRelPath(base, path) {\n      let breakPoint = 0,\n          out = '',\n          i,\n          l;\n      const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n      const items = path.split('/');\n\n      if (normalizedBase.length >= items.length) {\n        for (i = 0, l = normalizedBase.length; i < l; i++) {\n          if (i >= items.length || normalizedBase[i] !== items[i]) {\n            breakPoint = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (normalizedBase.length < items.length) {\n        for (i = 0, l = items.length; i < l; i++) {\n          if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n            breakPoint = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (breakPoint === 1) {\n        return path;\n      }\n\n      for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n        out += '../';\n      }\n\n      for (i = breakPoint - 1, l = items.length; i < l; i++) {\n        if (i !== breakPoint - 1) {\n          out += '/' + items[i];\n        } else {\n          out += items[i];\n        }\n      }\n\n      return out;\n    }\n\n    toAbsPath(base, path) {\n      let nb = 0;\n      const tr = /\\/$/.test(path) ? '/' : '';\n      const normalizedBase = base.split('/');\n      const normalizedPath = path.split('/');\n      const baseParts = [];\n      each$4(normalizedBase, k => {\n        if (k) {\n          baseParts.push(k);\n        }\n      });\n      const pathParts = [];\n\n      for (let i = normalizedPath.length - 1; i >= 0; i--) {\n        if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n          continue;\n        }\n\n        if (normalizedPath[i] === '..') {\n          nb++;\n          continue;\n        }\n\n        if (nb > 0) {\n          nb--;\n          continue;\n        }\n\n        pathParts.push(normalizedPath[i]);\n      }\n\n      const i = baseParts.length - nb;\n      let outPath;\n\n      if (i <= 0) {\n        outPath = reverse(pathParts).join('/');\n      } else {\n        outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n      }\n\n      if (outPath.indexOf('/') !== 0) {\n        outPath = '/' + outPath;\n      }\n\n      if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n        outPath += tr;\n      }\n\n      return outPath;\n    }\n\n    getURI(noProtoHost = false) {\n      let s;\n\n      if (!this.source || noProtoHost) {\n        s = '';\n\n        if (!noProtoHost) {\n          if (this.protocol) {\n            s += this.protocol + '://';\n          } else {\n            s += '//';\n          }\n\n          if (this.userInfo) {\n            s += this.userInfo + '@';\n          }\n\n          if (this.host) {\n            s += this.host;\n          }\n\n          if (this.port) {\n            s += ':' + this.port;\n          }\n        }\n\n        if (this.path) {\n          s += this.path;\n        }\n\n        if (this.query) {\n          s += '?' + this.query;\n        }\n\n        if (this.anchor) {\n          s += '#' + this.anchor;\n        }\n\n        this.source = s;\n      }\n\n      return this.source;\n    }\n\n  }\n\n  const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n  const internalElementAttr = 'data-mce-type';\n  let uid = 0;\n\n  const processNode = (node, settings, schema, scope, evt) => {\n    var _a, _b, _c, _d;\n\n    const validate = settings.validate;\n    const specialElements = schema.getSpecialElements();\n\n    if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n      node.nodeValue = ' ' + node.nodeValue;\n    }\n\n    const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n\n    if (scope !== 'html' && schema.isValid(scope)) {\n      if (isNonNullable(evt)) {\n        evt.allowedTags[lcTagName] = true;\n      }\n\n      return;\n    }\n\n    if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n      return;\n    }\n\n    const element = SugarElement.fromDom(node);\n    const isInternalElement = has$1(element, internalElementAttr);\n    const bogus = get$9(element, 'data-mce-bogus');\n\n    if (!isInternalElement && isString(bogus)) {\n      if (bogus === 'all') {\n        remove$5(element);\n      } else {\n        unwrap(element);\n      }\n\n      return;\n    }\n\n    const rule = schema.getElementRule(lcTagName);\n\n    if (validate && !rule) {\n      if (has$2(specialElements, lcTagName)) {\n        remove$5(element);\n      } else {\n        unwrap(element);\n      }\n\n      return;\n    } else {\n      if (isNonNullable(evt)) {\n        evt.allowedTags[lcTagName] = true;\n      }\n    }\n\n    if (validate && rule && !isInternalElement) {\n      each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n        set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);\n      });\n      each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n        if (!has$1(element, attr.name)) {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${uid++}` : attr.value);\n        }\n      });\n\n      if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n        unwrap(element);\n        return;\n      }\n\n      if (rule.removeEmptyAttrs && hasNone(element)) {\n        unwrap(element);\n        return;\n      }\n\n      if (rule.outputName && rule.outputName !== lcTagName) {\n        mutate(element, rule.outputName);\n      }\n    }\n  };\n\n  const processAttr = (ele, settings, schema, scope, evt) => {\n    const tagName = ele.tagName.toLowerCase();\n    const {\n      attrName,\n      attrValue\n    } = evt;\n    evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n\n    if (evt.keepAttr) {\n      evt.allowedAttributes[attrName] = true;\n\n      if (isBooleanAttribute(attrName, schema)) {\n        evt.attrValue = attrName;\n      }\n\n      if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n        evt.forceKeepAttr = true;\n      }\n    } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n      evt.forceKeepAttr = true;\n    }\n  };\n\n  const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n    if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n      return true;\n    }\n\n    return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n  };\n\n  const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n\n  const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n\n  const filterAttributes = (ele, settings, schema, scope) => {\n    const {\n      attributes\n    } = ele;\n\n    for (let i = attributes.length - 1; i >= 0; i--) {\n      const attr = attributes[i];\n      const attrName = attr.name;\n      const attrValue = attr.value;\n\n      if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n        ele.removeAttribute(attrName);\n      } else if (isBooleanAttribute(attrName, schema)) {\n        ele.setAttribute(attrName, attrName);\n      }\n    }\n  };\n\n  const setupPurify = (settings, schema, namespaceTracker) => {\n    const purify$1 = purify();\n    purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n      processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n    });\n    purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n      processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n    });\n    return purify$1;\n  };\n\n  const getPurifyConfig = (settings, mimeType) => {\n    const basePurifyConfig = {\n      IN_PLACE: true,\n      ALLOW_UNKNOWN_PROTOCOLS: true,\n      ALLOWED_TAGS: ['#comment', '#cdata-section', 'body'],\n      ALLOWED_ATTR: []\n    };\n    const config = { ...basePurifyConfig\n    };\n    config.PARSER_MEDIA_TYPE = mimeType;\n\n    if (settings.allow_script_urls) {\n      config.ALLOWED_URI_REGEXP = /.*/;\n    } else if (settings.allow_html_data_urls) {\n      config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n    }\n\n    return config;\n  };\n\n  const sanitizeNamespaceElement = ele => {\n    const xlinkAttrs = ['type', 'href', 'role', 'arcrole', 'title', 'show', 'actuate', 'label', 'from', 'to'].map(name => `xlink:${name}`);\n    const config = {\n      IN_PLACE: true,\n      USE_PROFILES: {\n        html: true,\n        svg: true,\n        svgFilters: true\n      },\n      ALLOWED_ATTR: xlinkAttrs\n    };\n    purify().sanitize(ele, config);\n    return ele.innerHTML;\n  };\n\n  const getSanitizer = (settings, schema) => {\n    const namespaceTracker = createNamespaceTracker();\n\n    if (settings.sanitize) {\n      const purify = setupPurify(settings, schema, namespaceTracker);\n\n      const sanitizeHtmlElement = (body, mimeType) => {\n        purify.sanitize(body, getPurifyConfig(settings, mimeType));\n        purify.removed = [];\n        namespaceTracker.reset();\n      };\n\n      return {\n        sanitizeHtmlElement,\n        sanitizeNamespaceElement\n      };\n    } else {\n      const sanitizeHtmlElement = (body, _mimeType) => {\n        const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n        let node;\n\n        while (node = nodeIterator.nextNode()) {\n          const currentScope = namespaceTracker.track(node);\n          processNode(node, settings, schema, currentScope);\n\n          if (isElement$6(node)) {\n            filterAttributes(node, settings, schema, currentScope);\n          }\n        }\n\n        namespaceTracker.reset();\n      };\n\n      const sanitizeNamespaceElement = noop;\n      return {\n        sanitizeHtmlElement,\n        sanitizeNamespaceElement\n      };\n    }\n  };\n\n  const makeMap = Tools.makeMap,\n        extend$1 = Tools.extend;\n\n  const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n    const parentName = parent.name;\n    const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\n    const childNodes = nativeParent.childNodes;\n\n    for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n      const nativeChild = childNodes[ni];\n      const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n\n      if (isElement$6(nativeChild)) {\n        const attributes = nativeChild.attributes;\n\n        for (let ai = 0, al = attributes.length; ai < al; ai++) {\n          const attr = attributes[ai];\n          child.attr(attr.name, attr.value);\n        }\n\n        if (isNonHtmlElementRootName(child.name)) {\n          nsSanitizer(nativeChild);\n          child.value = nativeChild.innerHTML;\n        }\n      } else if (isText$a(nativeChild)) {\n        child.value = nativeChild.data;\n\n        if (isSpecial) {\n          child.raw = true;\n        }\n      } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n        child.value = nativeChild.data;\n      }\n\n      if (!isNonHtmlElementRootName(child.name)) {\n        transferChildren(child, nativeChild, specialElements, nsSanitizer);\n      }\n\n      parent.append(child);\n    }\n  };\n\n  const walkTree = (root, preprocessors, postprocessors) => {\n    const traverseOrder = [];\n\n    for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n      const tempNode = node;\n      each$e(preprocessors, preprocess => preprocess(tempNode));\n\n      if (isNullable(tempNode.parent) && tempNode !== root) {\n        node = lastNode;\n      } else {\n        traverseOrder.push(tempNode);\n      }\n    }\n\n    for (let i = traverseOrder.length - 1; i >= 0; i--) {\n      const node = traverseOrder[i];\n      each$e(postprocessors, postprocess => postprocess(node));\n    }\n  };\n\n  const whitespaceCleaner = (root, schema, settings, args) => {\n    const validate = settings.validate;\n    const nonEmptyElements = schema.getNonEmptyElements();\n    const whitespaceElements = schema.getWhitespaceElements();\n    const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n    const textRootBlockElements = getTextRootBlockElements(schema);\n    const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n    const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n    const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n\n    const hasWhitespaceParent = node => {\n      let tempNode = node.parent;\n\n      while (isNonNullable(tempNode)) {\n        if (tempNode.name in whitespaceElements) {\n          return true;\n        } else {\n          tempNode = tempNode.parent;\n        }\n      }\n\n      return false;\n    };\n\n    const isTextRootBlockEmpty = node => {\n      let tempNode = node;\n\n      while (isNonNullable(tempNode)) {\n        if (tempNode.name in textRootBlockElements) {\n          return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n        } else {\n          tempNode = tempNode.parent;\n        }\n      }\n\n      return false;\n    };\n\n    const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n\n    const isAtEdgeOfBlock = (node, start) => {\n      const neighbour = start ? node.prev : node.next;\n\n      if (isNonNullable(neighbour) || isNullable(node.parent)) {\n        return false;\n      }\n\n      return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n    };\n\n    const preprocess = node => {\n      var _a;\n\n      if (node.type === 3) {\n        if (!hasWhitespaceParent(node)) {\n          let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n          text = text.replace(allWhiteSpaceRegExp, ' ');\n\n          if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n            text = text.replace(startWhiteSpaceRegExp, '');\n          }\n\n          if (text.length === 0) {\n            node.remove();\n          } else {\n            node.value = text;\n          }\n        }\n      }\n    };\n\n    const postprocess = node => {\n      var _a;\n\n      if (node.type === 1) {\n        const elementRule = schema.getElementRule(node.name);\n\n        if (validate && elementRule) {\n          const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n\n          if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n            paddEmptyNode(settings, args, isBlock, node);\n          } else if (elementRule.removeEmpty && isNodeEmpty) {\n            if (isBlock(node)) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n            paddEmptyNode(settings, args, isBlock, node);\n          }\n        }\n      } else if (node.type === 3) {\n        if (!hasWhitespaceParent(node)) {\n          let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n\n          if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n            text = text.replace(endWhiteSpaceRegExp, '');\n          }\n\n          if (text.length === 0) {\n            node.remove();\n          } else {\n            node.value = text;\n          }\n        }\n      }\n    };\n\n    return [preprocess, postprocess];\n  };\n\n  const getRootBlockName = (settings, args) => {\n    var _a;\n\n    const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n\n    if (name === false) {\n      return '';\n    } else if (name === true) {\n      return 'p';\n    } else {\n      return name;\n    }\n  };\n\n  const DomParser = (settings = {}, schema = Schema()) => {\n    const nodeFilterRegistry = create$8();\n    const attributeFilterRegistry = create$8();\n    const defaultedSettings = {\n      validate: true,\n      root_name: 'body',\n      sanitize: true,\n      ...settings\n    };\n    const parser = new DOMParser();\n    const sanitizer = getSanitizer(defaultedSettings, schema);\n\n    const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n      const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n      const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n      const content = isSpecialRoot ? `<${rootName}>${html}</${rootName}>` : html;\n      const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${content}</body></html>` : `<body>${content}</body>`;\n      const body = parser.parseFromString(wrappedHtml, mimeType).body;\n      sanitizer.sanitizeHtmlElement(body, mimeType);\n      return isSpecialRoot ? body.firstChild : body;\n    };\n\n    const addNodeFilter = nodeFilterRegistry.addFilter;\n    const getNodeFilters = nodeFilterRegistry.getFilters;\n    const removeNodeFilter = nodeFilterRegistry.removeFilter;\n    const addAttributeFilter = attributeFilterRegistry.addFilter;\n    const getAttributeFilters = attributeFilterRegistry.getFilters;\n    const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n\n    const findInvalidChildren = (node, invalidChildren) => {\n      if (isInvalid(schema, node)) {\n        invalidChildren.push(node);\n      }\n    };\n\n    const isWrappableNode = (blockElements, node) => {\n      const isInternalElement = isString(node.attr(internalElementAttr));\n      const isInlineElement = node.type === 1 && !has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node) && !isNonHtmlElementRootName(node.name);\n      return node.type === 3 || isInlineElement && !isInternalElement;\n    };\n\n    const addRootBlocks = (rootNode, rootBlockName) => {\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      let node = rootNode.firstChild,\n          rootBlockNode = null;\n\n      const trim = rootBlock => {\n        var _a, _b;\n\n        if (rootBlock) {\n          node = rootBlock.firstChild;\n\n          if (node && node.type === 3) {\n            node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n          }\n\n          node = rootBlock.lastChild;\n\n          if (node && node.type === 3) {\n            node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n          }\n        }\n      };\n\n      if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n        return;\n      }\n\n      while (node) {\n        const next = node.next;\n\n        if (isWrappableNode(blockElements, node)) {\n          if (!rootBlockNode) {\n            rootBlockNode = new AstNode(rootBlockName, 1);\n            rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n            rootNode.insert(rootBlockNode, node);\n            rootBlockNode.append(node);\n          } else {\n            rootBlockNode.append(node);\n          }\n        } else {\n          trim(rootBlockNode);\n          rootBlockNode = null;\n        }\n\n        node = next;\n      }\n\n      trim(rootBlockNode);\n    };\n\n    const parse = (html, args = {}) => {\n      var _a;\n\n      const validate = defaultedSettings.validate;\n      const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n      const element = parseAndSanitizeWithContext(html, rootName, args.format);\n      updateChildren(schema, element);\n      const rootNode = new AstNode(rootName, 11);\n      transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n      element.innerHTML = '';\n      const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n      const invalidChildren = [];\n      const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n\n      const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n\n      walkTree(rootNode, [whitespacePre, matchFinder], [whitespacePost, invalidFinder]);\n      invalidChildren.reverse();\n\n      if (validate && invalidChildren.length > 0) {\n        if (args.context) {\n          const {\n            pass: topLevelChildren,\n            fail: otherChildren\n          } = partition$2(invalidChildren, child => child.parent === rootNode);\n          cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n          args.invalid = topLevelChildren.length > 0;\n        } else {\n          cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n        }\n      }\n\n      const rootBlockName = getRootBlockName(defaultedSettings, args);\n\n      if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n        addRootBlocks(rootNode, rootBlockName);\n      }\n\n      if (!args.invalid) {\n        runFilters(matches, args);\n      }\n\n      return rootNode;\n    };\n\n    const exports = {\n      schema,\n      addAttributeFilter,\n      getAttributeFilters,\n      removeAttributeFilter,\n      addNodeFilter,\n      getNodeFilters,\n      removeNodeFilter,\n      parse\n    };\n    register$4(exports, defaultedSettings);\n    register$5(exports, defaultedSettings, schema);\n    return exports;\n  };\n\n  const serializeContent = content => isTreeNode(content) ? HtmlSerializer({\n    validate: false\n  }).serialize(content) : content;\n\n  const withSerializedContent = (content, fireEvent, parserSettings) => {\n    const serializedContent = serializeContent(content);\n    const eventArgs = fireEvent(serializedContent);\n\n    if (eventArgs.isDefaultPrevented()) {\n      return eventArgs;\n    } else if (isTreeNode(content)) {\n      if (eventArgs.content !== serializedContent) {\n        const rootNode = DomParser({\n          validate: false,\n          forced_root_block: false,\n          ...parserSettings\n        }).parse(eventArgs.content, {\n          context: content.name\n        });\n        return { ...eventArgs,\n          content: rootNode\n        };\n      } else {\n        return { ...eventArgs,\n          content\n        };\n      }\n    } else {\n      return eventArgs;\n    }\n  };\n\n  const preProcessGetContent = (editor, args) => {\n    if (args.no_events) {\n      return Result.value(args);\n    } else {\n      const eventArgs = fireBeforeGetContent(editor, args);\n\n      if (eventArgs.isDefaultPrevented()) {\n        return Result.error(fireGetContent(editor, {\n          content: '',\n          ...eventArgs\n        }).content);\n      } else {\n        return Result.value(eventArgs);\n      }\n    }\n  };\n\n  const postProcessGetContent = (editor, content, args) => {\n    if (args.no_events) {\n      return content;\n    } else {\n      const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, { ...args,\n        content\n      }), {\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor)\n      });\n      return processedEventArgs.content;\n    }\n  };\n\n  const preProcessSetContent = (editor, args) => {\n    if (args.no_events) {\n      return Result.value(args);\n    } else {\n      const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, { ...args,\n        content\n      }), {\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor)\n      });\n\n      if (processedEventArgs.isDefaultPrevented()) {\n        fireSetContent(editor, processedEventArgs);\n        return Result.error(undefined);\n      } else {\n        return Result.value(processedEventArgs);\n      }\n    }\n  };\n\n  const postProcessSetContent = (editor, content, args) => {\n    if (!args.no_events) {\n      fireSetContent(editor, { ...args,\n        content\n      });\n    }\n  };\n\n  const tableModel = (element, width, rows) => ({\n    element,\n    width,\n    rows\n  });\n\n  const tableRow = (element, cells) => ({\n    element,\n    cells\n  });\n\n  const cellPosition = (x, y) => ({\n    x,\n    y\n  });\n\n  const getSpan = (td, key) => {\n    return getOpt(td, key).bind(toInt).getOr(1);\n  };\n\n  const fillout = (table, x, y, tr, td) => {\n    const rowspan = getSpan(td, 'rowspan');\n    const colspan = getSpan(td, 'colspan');\n    const rows = table.rows;\n\n    for (let y2 = y; y2 < y + rowspan; y2++) {\n      if (!rows[y2]) {\n        rows[y2] = tableRow(deep$1(tr), []);\n      }\n\n      for (let x2 = x; x2 < x + colspan; x2++) {\n        const cells = rows[y2].cells;\n        cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n      }\n    }\n  };\n\n  const cellExists = (table, x, y) => {\n    const rows = table.rows;\n    const cells = rows[y] ? rows[y].cells : [];\n    return !!cells[x];\n  };\n\n  const skipCellsX = (table, x, y) => {\n    while (cellExists(table, x, y)) {\n      x++;\n    }\n\n    return x;\n  };\n\n  const getWidth = rows => {\n    return foldl(rows, (acc, row) => {\n      return row.cells.length > acc ? row.cells.length : acc;\n    }, 0);\n  };\n\n  const findElementPos = (table, element) => {\n    const rows = table.rows;\n\n    for (let y = 0; y < rows.length; y++) {\n      const cells = rows[y].cells;\n\n      for (let x = 0; x < cells.length; x++) {\n        if (eq(cells[x], element)) {\n          return Optional.some(cellPosition(x, y));\n        }\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const extractRows = (table, sx, sy, ex, ey) => {\n    const newRows = [];\n    const rows = table.rows;\n\n    for (let y = sy; y <= ey; y++) {\n      const cells = rows[y].cells;\n      const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n      newRows.push(tableRow(rows[y].element, slice));\n    }\n\n    return newRows;\n  };\n\n  const subTable = (table, startPos, endPos) => {\n    const sx = startPos.x,\n          sy = startPos.y;\n    const ex = endPos.x,\n          ey = endPos.y;\n    const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n    return tableModel(table.element, getWidth(newRows), newRows);\n  };\n\n  const createDomTable = (table, rows) => {\n    const tableElement = shallow$1(table.element);\n    const tableBody = SugarElement.fromTag('tbody');\n    append(tableBody, rows);\n    append$1(tableElement, tableBody);\n    return tableElement;\n  };\n\n  const modelRowsToDomRows = table => {\n    return map$3(table.rows, row => {\n      const cells = map$3(row.cells, cell => {\n        const td = deep$1(cell);\n        remove$a(td, 'colspan');\n        remove$a(td, 'rowspan');\n        return td;\n      });\n      const tr = shallow$1(row.element);\n      append(tr, cells);\n      return tr;\n    });\n  };\n\n  const fromDom = tableElm => {\n    const table = tableModel(shallow$1(tableElm), 0, []);\n    each$e(descendants(tableElm, 'tr'), (tr, y) => {\n      each$e(descendants(tr, 'td,th'), (td, x) => {\n        fillout(table, skipCellsX(table, x, y), y, tr, td);\n      });\n    });\n    return tableModel(table.element, getWidth(table.rows), table.rows);\n  };\n\n  const toDom = table => {\n    return createDomTable(table, modelRowsToDomRows(table));\n  };\n\n  const subsection = (table, startElement, endElement) => {\n    return findElementPos(table, startElement).bind(startPos => {\n      return findElementPos(table, endElement).map(endPos => {\n        return subTable(table, startPos, endPos);\n      });\n    });\n  };\n\n  const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n\n  const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n    const listElm = SugarElement.fromTag(name(listCont));\n    const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n    setAll(listElm, listStyles);\n    return [SugarElement.fromTag('li'), listElm];\n  }).getOr([]));\n\n  const wrap = (innerElm, elms) => {\n    const wrapped = foldl(elms, (acc, elm) => {\n      append$1(elm, acc);\n      return elm;\n    }, innerElm);\n    return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n  };\n\n  const directListWrappers = commonAnchorContainer => {\n    if (isListItem$1(commonAnchorContainer)) {\n      return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [commonAnchorContainer, listElm]);\n    } else {\n      return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n    }\n  };\n\n  const getWrapElements = (rootNode, rng, schema) => {\n    const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n    const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n    const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n    const listWrappers = getFullySelectedListWrappers(parents, rng);\n    const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n    return map$3(allWrappers, shallow$1);\n  };\n\n  const emptyFragment = () => fromElements([]);\n\n  const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n\n  const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n\n  const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n    const firstCell = selectedTableCells[0];\n    const lastCell = selectedTableCells[selectedTableCells.length - 1];\n    const fullTableModel = fromDom(tableElm);\n    return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n  }).getOrThunk(emptyFragment);\n\n  const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n\n  const read$3 = (rootNode, ranges, schema) => {\n    const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n    return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n  };\n\n  const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n\n  const getInnerText = bin => {\n    return trim$2(bin.innerText);\n  };\n\n  const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n\n  const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n    var _a;\n\n    const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n    const body = editor.getBody();\n    const contextNodeName = getContextNodeName(parentBlockOpt);\n    const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n    cleanupBogusElements(rangeContentClone);\n    cleanupInputNames(rangeContentClone);\n    const bin = editor.dom.add(body, contextNodeName, {\n      'data-mce-bogus': 'all',\n      'style': 'overflow: hidden; opacity: 0;'\n    }, rangeContentClone.dom);\n    const text = getInnerText(bin);\n    const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n    editor.dom.remove(bin);\n\n    if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n      const parentBlock = parentBlockOpt.getOr(body);\n      const parentBlockText = getInnerText(parentBlock);\n      const textIndex = parentBlockText.indexOf(text);\n\n      if (textIndex === -1) {\n        return text;\n      } else {\n        const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n        const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n        return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n      }\n    } else {\n      return text;\n    }\n  }).getOr('');\n\n  const getSerializedContent = (editor, args) => {\n    const rng = editor.selection.getRng(),\n          tmpElm = editor.dom.create('body');\n    const sel = editor.selection.getSel();\n    const ranges = processRanges(editor, getRanges$1(sel));\n    const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n\n    if (fragment) {\n      tmpElm.appendChild(fragment);\n    }\n\n    return editor.selection.serializer.serialize(tmpElm, args);\n  };\n\n  const extractSelectedContent = (editor, args) => {\n    if (args.format === 'text') {\n      return getTextContent(editor);\n    } else {\n      const content = getSerializedContent(editor, args);\n\n      if (args.format === 'tree') {\n        return content;\n      } else {\n        return editor.selection.isCollapsed() ? '' : content;\n      }\n    }\n  };\n\n  const setupArgs$3 = (args, format) => ({ ...args,\n    format,\n    get: true,\n    selection: true,\n    getInner: true\n  });\n\n  const getSelectedContentInternal = (editor, format, args = {}) => {\n    const defaultedArgs = setupArgs$3(args, format);\n    return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n      const content = extractSelectedContent(editor, updatedArgs);\n      return postProcessGetContent(editor, content, updatedArgs);\n    });\n  };\n\n  const KEEP = 0,\n        INSERT = 1,\n        DELETE = 2;\n\n  const diff = (left, right) => {\n    const size = left.length + right.length + 2;\n    const vDown = new Array(size);\n    const vUp = new Array(size);\n\n    const snake = (start, end, diag) => {\n      return {\n        start,\n        end,\n        diag\n      };\n    };\n\n    const buildScript = (start1, end1, start2, end2, script) => {\n      const middle = getMiddleSnake(start1, end1, start2, end2);\n\n      if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n        let i = start1;\n        let j = start2;\n\n        while (i < end1 || j < end2) {\n          if (i < end1 && j < end2 && left[i] === right[j]) {\n            script.push([KEEP, left[i]]);\n            ++i;\n            ++j;\n          } else {\n            if (end1 - start1 > end2 - start2) {\n              script.push([DELETE, left[i]]);\n              ++i;\n            } else {\n              script.push([INSERT, right[j]]);\n              ++j;\n            }\n          }\n        }\n      } else {\n        buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n\n        for (let i2 = middle.start; i2 < middle.end; ++i2) {\n          script.push([KEEP, left[i2]]);\n        }\n\n        buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n      }\n    };\n\n    const buildSnake = (start, diag, end1, end2) => {\n      let end = start;\n\n      while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n        ++end;\n      }\n\n      return snake(start, end, diag);\n    };\n\n    const getMiddleSnake = (start1, end1, start2, end2) => {\n      const m = end1 - start1;\n      const n = end2 - start2;\n\n      if (m === 0 || n === 0) {\n        return null;\n      }\n\n      const delta = m - n;\n      const sum = n + m;\n      const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n      vDown[1 + offset] = start1;\n      vUp[1 + offset] = end1 + 1;\n      let d, k, i, x, y;\n\n      for (d = 0; d <= offset; ++d) {\n        for (k = -d; k <= d; k += 2) {\n          i = k + offset;\n\n          if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n            vDown[i] = vDown[i + 1];\n          } else {\n            vDown[i] = vDown[i - 1] + 1;\n          }\n\n          x = vDown[i];\n          y = x - start1 + start2 - k;\n\n          while (x < end1 && y < end2 && left[x] === right[y]) {\n            vDown[i] = ++x;\n            ++y;\n          }\n\n          if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n            if (vUp[i - delta] <= vDown[i]) {\n              return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n            }\n          }\n        }\n\n        for (k = delta - d; k <= delta + d; k += 2) {\n          i = k + offset - delta;\n\n          if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n            vUp[i] = vUp[i + 1] - 1;\n          } else {\n            vUp[i] = vUp[i - 1];\n          }\n\n          x = vUp[i] - 1;\n          y = x - start1 + start2 - k;\n\n          while (x >= start1 && y >= start2 && left[x] === right[y]) {\n            vUp[i] = x--;\n            y--;\n          }\n\n          if (delta % 2 === 0 && -d <= k && k <= d) {\n            if (vUp[i] <= vDown[i + delta]) {\n              return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n            }\n          }\n        }\n      }\n\n      return null;\n    };\n\n    const script = [];\n    buildScript(0, left.length, 0, right.length, script);\n    return script;\n  };\n\n  const getOuterHtml = elm => {\n    if (isElement$6(elm)) {\n      return elm.outerHTML;\n    } else if (isText$a(elm)) {\n      return Entities.encodeRaw(elm.data, false);\n    } else if (isComment(elm)) {\n      return '<!--' + elm.data + '-->';\n    }\n\n    return '';\n  };\n\n  const createFragment = html => {\n    let node;\n    const container = document.createElement('div');\n    const frag = document.createDocumentFragment();\n\n    if (html) {\n      container.innerHTML = html;\n    }\n\n    while (node = container.firstChild) {\n      frag.appendChild(node);\n    }\n\n    return frag;\n  };\n\n  const insertAt = (elm, html, index) => {\n    const fragment = createFragment(html);\n\n    if (elm.hasChildNodes() && index < elm.childNodes.length) {\n      const target = elm.childNodes[index];\n      elm.insertBefore(fragment, target);\n    } else {\n      elm.appendChild(fragment);\n    }\n  };\n\n  const removeAt = (elm, index) => {\n    if (elm.hasChildNodes() && index < elm.childNodes.length) {\n      const target = elm.childNodes[index];\n      elm.removeChild(target);\n    }\n  };\n\n  const applyDiff = (diff, elm) => {\n    let index = 0;\n    each$e(diff, action => {\n      if (action[0] === KEEP) {\n        index++;\n      } else if (action[0] === INSERT) {\n        insertAt(elm, action[1], index);\n        index++;\n      } else if (action[0] === DELETE) {\n        removeAt(elm, index);\n      }\n    });\n  };\n\n  const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n    return item.length > 0;\n  });\n\n  const write = (fragments, elm) => {\n    const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n    applyDiff(diff(currentFragments, fragments), elm);\n    return elm;\n  };\n\n  const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n\n  const hasIframes = body => body.querySelector('iframe') !== null;\n\n  const createFragmentedLevel = fragments => {\n    return {\n      type: 'fragmented',\n      fragments,\n      content: '',\n      bookmark: null,\n      beforeBookmark: null\n    };\n  };\n\n  const createCompleteLevel = content => {\n    return {\n      type: 'complete',\n      fragments: null,\n      content,\n      bookmark: null,\n      beforeBookmark: null\n    };\n  };\n\n  const createFromEditor = editor => {\n    const tempAttrs = editor.serializer.getTempAttrs();\n    const body = trim$1(editor.getBody(), tempAttrs);\n    return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n  };\n\n  const applyToEditor = (editor, level, before) => {\n    const bookmark = before ? level.beforeBookmark : level.bookmark;\n\n    if (level.type === 'fragmented') {\n      write(level.fragments, editor.getBody());\n    } else {\n      editor.setContent(level.content, {\n        format: 'raw',\n        no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n      });\n    }\n\n    if (bookmark) {\n      editor.selection.moveToBookmark(bookmark);\n      editor.selection.scrollIntoView();\n    }\n  };\n\n  const getLevelContent = level => {\n    return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n  };\n\n  const getCleanLevelContent = level => {\n    const elm = SugarElement.fromTag('body', lazyTempDocument());\n    set$1(elm, getLevelContent(level));\n    each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n    return get$6(elm);\n  };\n\n  const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n\n  const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n\n  const isEq$1 = (level1, level2) => {\n    if (!level1 || !level2) {\n      return false;\n    } else if (hasEqualContent(level1, level2)) {\n      return true;\n    } else {\n      return hasEqualCleanedContent(level1, level2);\n    }\n  };\n\n  const isUnlocked = locks => locks.get() === 0;\n\n  const setTyping = (undoManager, typing, locks) => {\n    if (isUnlocked(locks)) {\n      undoManager.typing = typing;\n    }\n  };\n\n  const endTyping = (undoManager, locks) => {\n    if (undoManager.typing) {\n      setTyping(undoManager, false, locks);\n      undoManager.add();\n    }\n  };\n\n  const endTypingLevelIgnoreLocks = undoManager => {\n    if (undoManager.typing) {\n      undoManager.typing = false;\n      undoManager.add();\n    }\n  };\n\n  const beforeChange$1 = (editor, locks, beforeBookmark) => {\n    if (isUnlocked(locks)) {\n      beforeBookmark.set(getUndoBookmark(editor.selection));\n    }\n  };\n\n  const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n    const currentLevel = createFromEditor(editor);\n    const newLevel = Tools.extend(level || {}, currentLevel);\n\n    if (!isUnlocked(locks) || editor.removed) {\n      return null;\n    }\n\n    const lastLevel = undoManager.data[index.get()];\n\n    if (editor.dispatch('BeforeAddUndo', {\n      level: newLevel,\n      lastLevel,\n      originalEvent: event\n    }).isDefaultPrevented()) {\n      return null;\n    }\n\n    if (lastLevel && isEq$1(lastLevel, newLevel)) {\n      return null;\n    }\n\n    if (undoManager.data[index.get()]) {\n      beforeBookmark.get().each(bm => {\n        undoManager.data[index.get()].beforeBookmark = bm;\n      });\n    }\n\n    const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n\n    if (customUndoRedoLevels) {\n      if (undoManager.data.length > customUndoRedoLevels) {\n        for (let i = 0; i < undoManager.data.length - 1; i++) {\n          undoManager.data[i] = undoManager.data[i + 1];\n        }\n\n        undoManager.data.length--;\n        index.set(undoManager.data.length);\n      }\n    }\n\n    newLevel.bookmark = getUndoBookmark(editor.selection);\n\n    if (index.get() < undoManager.data.length - 1) {\n      undoManager.data.length = index.get() + 1;\n    }\n\n    undoManager.data.push(newLevel);\n    index.set(undoManager.data.length - 1);\n    const args = {\n      level: newLevel,\n      lastLevel,\n      originalEvent: event\n    };\n\n    if (index.get() > 0) {\n      editor.setDirty(true);\n      editor.dispatch('AddUndo', args);\n      editor.dispatch('change', args);\n    } else {\n      editor.dispatch('AddUndo', args);\n    }\n\n    return newLevel;\n  };\n\n  const clear$1 = (editor, undoManager, index) => {\n    undoManager.data = [];\n    index.set(0);\n    undoManager.typing = false;\n    editor.dispatch('ClearUndos');\n  };\n\n  const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n    if (undoManager.transact(callback1)) {\n      const bookmark = undoManager.data[index.get()].bookmark;\n      const lastLevel = undoManager.data[index.get() - 1];\n      applyToEditor(editor, lastLevel, true);\n\n      if (undoManager.transact(callback2)) {\n        undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n      }\n    }\n  };\n\n  const redo$1 = (editor, index, data) => {\n    let level;\n\n    if (index.get() < data.length - 1) {\n      index.set(index.get() + 1);\n      level = data[index.get()];\n      applyToEditor(editor, level, false);\n      editor.setDirty(true);\n      editor.dispatch('Redo', {\n        level\n      });\n    }\n\n    return level;\n  };\n\n  const undo$1 = (editor, undoManager, locks, index) => {\n    let level;\n\n    if (undoManager.typing) {\n      undoManager.add();\n      undoManager.typing = false;\n      setTyping(undoManager, false, locks);\n    }\n\n    if (index.get() > 0) {\n      index.set(index.get() - 1);\n      level = undoManager.data[index.get()];\n      applyToEditor(editor, level, true);\n      editor.setDirty(true);\n      editor.dispatch('Undo', {\n        level\n      });\n    }\n\n    return level;\n  };\n\n  const reset$1 = undoManager => {\n    undoManager.clear();\n    undoManager.add();\n  };\n\n  const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n\n  const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n\n  const transact$1 = (undoManager, locks, callback) => {\n    endTyping(undoManager, locks);\n    undoManager.beforeChange();\n    undoManager.ignore(callback);\n    return undoManager.add();\n  };\n\n  const ignore$1 = (locks, callback) => {\n    try {\n      locks.set(locks.get() + 1);\n      callback();\n    } finally {\n      locks.set(locks.get() - 1);\n    }\n  };\n\n  const addVisualInternal = (editor, elm) => {\n    const dom = editor.dom;\n    const scope = isNonNullable(elm) ? elm : editor.getBody();\n    each$e(dom.select('table,a', scope), matchedElm => {\n      switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n\n          break;\n\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n\n          break;\n      }\n    });\n    editor.dispatch('VisualAid', {\n      element: elm,\n      hasVisual: editor.hasVisual\n    });\n  };\n\n  const makePlainAdaptor = editor => ({\n    init: {\n      bindEvents: noop\n    },\n    undoManager: {\n      beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n      add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n      undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n      redo: (index, data) => redo$1(editor, index, data),\n      clear: (undoManager, index) => clear$1(editor, undoManager, index),\n      reset: undoManager => reset$1(undoManager),\n      hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n      hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n      transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n      ignore: (locks, callback) => ignore$1(locks, callback),\n      extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n    },\n    formatter: {\n      match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n      matchAll: (names, vars) => matchAll(editor, names, vars),\n      matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n      canApply: name => canApply(editor, name),\n      closest: names => closest(editor, names),\n      apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n      remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n      toggle: (name, vars, node) => toggle(editor, name, vars, node),\n      formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n    },\n    editor: {\n      getContent: args => getContentInternal(editor, args),\n      setContent: (content, args) => setContentInternal(editor, content, args),\n      insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n      addVisual: elm => addVisualInternal(editor, elm)\n    },\n    selection: {\n      getContent: (format, args) => getSelectedContentInternal(editor, format, args)\n    },\n    autocompleter: {\n      addDecoration: range => create$9(editor, range),\n      removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))\n    },\n    raw: {\n      getModel: () => Optional.none()\n    }\n  });\n\n  const makeRtcAdaptor = rtcEditor => {\n    const defaultVars = vars => isObject(vars) ? vars : {};\n\n    const {\n      init,\n      undoManager,\n      formatter,\n      editor,\n      selection,\n      autocompleter,\n      raw\n    } = rtcEditor;\n    return {\n      init: {\n        bindEvents: init.bindEvents\n      },\n      undoManager: {\n        beforeChange: undoManager.beforeChange,\n        add: undoManager.add,\n        undo: undoManager.undo,\n        redo: undoManager.redo,\n        clear: undoManager.clear,\n        reset: undoManager.reset,\n        hasUndo: undoManager.hasUndo,\n        hasRedo: undoManager.hasRedo,\n        transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n        ignore: (_locks, callback) => undoManager.ignore(callback),\n        extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n        matchAll: formatter.matchAll,\n        matchNode: formatter.matchNode,\n        canApply: name => formatter.canApply(name),\n        closest: names => formatter.closest(names),\n        apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n        remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n        toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n        formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => editor.getContent(args),\n        setContent: (content, args) => {\n          return {\n            content: editor.setContent(content, args),\n            html: ''\n          };\n        },\n        insertContent: (content, _details) => {\n          editor.insertContent(content);\n          return '';\n        },\n        addVisual: editor.addVisual\n      },\n      selection: {\n        getContent: (_format, args) => selection.getContent(args)\n      },\n      autocompleter: {\n        addDecoration: autocompleter.addDecoration,\n        removeDecoration: autocompleter.removeDecoration\n      },\n      raw: {\n        getModel: () => Optional.some(raw.getRawModel())\n      }\n    };\n  };\n\n  const makeNoopAdaptor = () => {\n    const nul = constant(null);\n    const empty = constant('');\n    return {\n      init: {\n        bindEvents: noop\n      },\n      undoManager: {\n        beforeChange: noop,\n        add: nul,\n        undo: nul,\n        redo: nul,\n        clear: noop,\n        reset: noop,\n        hasUndo: never,\n        hasRedo: never,\n        transact: nul,\n        ignore: noop,\n        extra: noop\n      },\n      formatter: {\n        match: never,\n        matchAll: constant([]),\n        matchNode: constant(undefined),\n        canApply: never,\n        closest: empty,\n        apply: noop,\n        remove: noop,\n        toggle: noop,\n        formatChanged: constant({\n          unbind: noop\n        })\n      },\n      editor: {\n        getContent: empty,\n        setContent: constant({\n          content: '',\n          html: ''\n        }),\n        insertContent: constant(''),\n        addVisual: noop\n      },\n      selection: {\n        getContent: empty\n      },\n      autocompleter: {\n        addDecoration: noop,\n        removeDecoration: noop\n      },\n      raw: {\n        getModel: constant(Optional.none())\n      }\n    };\n  };\n\n  const isRtc = editor => has$2(editor.plugins, 'rtc');\n\n  const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n\n  const setup$t = editor => {\n    const editorCast = editor;\n    return getRtcSetup(editor).fold(() => {\n      editorCast.rtcInstance = makePlainAdaptor(editor);\n      return Optional.none();\n    }, setup => {\n      editorCast.rtcInstance = makeNoopAdaptor();\n      return Optional.some(() => setup().then(rtcEditor => {\n        editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n        return rtcEditor.rtc.isRemote;\n      }));\n    });\n  };\n\n  const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n\n  const getRtcInstanceWithError = editor => {\n    const rtcInstance = editor.rtcInstance;\n\n    if (!rtcInstance) {\n      throw new Error('Failed to get RTC instance not yet initialized.');\n    } else {\n      return rtcInstance;\n    }\n  };\n\n  const beforeChange = (editor, locks, beforeBookmark) => {\n    getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n  };\n\n  const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n\n  const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n\n  const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n\n  const clear = (editor, undoManager, index) => {\n    getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n  };\n\n  const reset = (editor, undoManager) => {\n    getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n  };\n\n  const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n\n  const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n\n  const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n\n  const ignore = (editor, locks, callback) => {\n    getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n  };\n\n  const extra = (editor, undoManager, index, callback1, callback2) => {\n    getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n  };\n\n  const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n\n  const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n\n  const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n\n  const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n\n  const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n\n  const applyFormat = (editor, name, vars, node) => {\n    getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n  };\n\n  const removeFormat = (editor, name, vars, node, similar) => {\n    getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n  };\n\n  const toggleFormat = (editor, name, vars, node) => {\n    getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n  };\n\n  const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n\n  const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n\n  const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n\n  const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n\n  const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n\n  const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n\n  const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n\n  const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n\n  const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n  const getContent$1 = (editor, args = {}) => {\n    const format = args.format ? args.format : 'html';\n    return getSelectedContent(editor, format, args);\n  };\n\n  const removeEmpty = text => {\n    if (text.dom.length === 0) {\n      remove$5(text);\n      return Optional.none();\n    } else {\n      return Optional.some(text);\n    }\n  };\n\n  const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n\n  const merge$1 = (outer, inner, rng, start, schema) => {\n    const outerElm = outer.dom;\n    const innerElm = inner.dom;\n    const oldLength = start ? outerElm.length : innerElm.length;\n\n    if (start) {\n      mergeTextNodes(outerElm, innerElm, schema, false, !start);\n      rng.setStart(innerElm, oldLength);\n    } else {\n      mergeTextNodes(innerElm, outerElm, schema, false, !start);\n      rng.setEnd(innerElm, oldLength);\n    }\n  };\n\n  const normalizeTextIfRequired = (inner, start, schema) => {\n    parent(inner).each(root => {\n      const text = inner.dom;\n\n      if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n        normalizeWhitespaceAfter(text, 0, schema);\n      } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n        normalizeWhitespaceBefore(text, text.length, schema);\n      }\n    });\n  };\n\n  const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n    outerNode.bind(outer => {\n      const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n      normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n      return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start, schema));\n    }).orThunk(() => {\n      const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);\n      return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n    });\n  };\n\n  const rngSetContent = (rng, fragment, schema) => {\n    const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n    const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n    rng.deleteContents();\n    rng.insertNode(fragment);\n    const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);\n    const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);\n    mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n    mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n    rng.collapse(false);\n  };\n\n  const setupArgs$2 = (args, content) => ({\n    format: 'html',\n    ...args,\n    set: true,\n    selection: true,\n    content\n  });\n\n  const cleanContent = (editor, args) => {\n    if (args.format !== 'raw') {\n      const rng = editor.selection.getRng();\n      const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n      const contextArgs = contextBlock ? {\n        context: contextBlock.nodeName.toLowerCase()\n      } : {};\n      const node = editor.parser.parse(args.content, {\n        forced_root_block: false,\n        ...contextArgs,\n        ...args\n      });\n      return HtmlSerializer({\n        validate: false\n      }, editor.schema).serialize(node);\n    } else {\n      return args.content;\n    }\n  };\n\n  const setContent$1 = (editor, content, args = {}) => {\n    const defaultedArgs = setupArgs$2(args, content);\n    preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n      const cleanedContent = cleanContent(editor, updatedArgs);\n      const rng = editor.selection.getRng();\n      rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n      postProcessSetContent(editor, cleanedContent, updatedArgs);\n    });\n  };\n\n  const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n    if (has$2(callbackMap, selector)) {\n      const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n\n      if (newCallbacks.length === 0) {\n        delete callbackMap[selector];\n      } else {\n        callbackMap[selector] = newCallbacks;\n      }\n    }\n  };\n\n  var SelectorChanged = (dom, editor) => {\n    let selectorChangedData;\n    let currentSelectors;\n\n    const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n\n    const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n\n    const setup = () => {\n      selectorChangedData = {};\n      currentSelectors = {};\n      editor.on('NodeChange', e => {\n        const node = e.element;\n        const parents = getParents(node);\n        const matchedSelectors = {};\n        each$d(selectorChangedData, (callbacks, selector) => {\n          findMatchingNode(selector, parents).each(node => {\n            if (!currentSelectors[selector]) {\n              each$e(callbacks, callback => {\n                callback(true, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n              currentSelectors[selector] = callbacks;\n            }\n\n            matchedSelectors[selector] = callbacks;\n          });\n        });\n        each$d(currentSelectors, (callbacks, selector) => {\n          if (!matchedSelectors[selector]) {\n            delete currentSelectors[selector];\n            each$e(callbacks, callback => {\n              callback(false, {\n                node,\n                selector,\n                parents\n              });\n            });\n          }\n        });\n      });\n    };\n\n    return {\n      selectorChangedWithUnbind: (selector, callback) => {\n        if (!selectorChangedData) {\n          setup();\n        }\n\n        if (!selectorChangedData[selector]) {\n          selectorChangedData[selector] = [];\n        }\n\n        selectorChangedData[selector].push(callback);\n        findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n          currentSelectors[selector] = selectorChangedData[selector];\n        });\n        return {\n          unbind: () => {\n            deleteFromCallbackMap(selectorChangedData, selector, callback);\n            deleteFromCallbackMap(currentSelectors, selector, callback);\n          }\n        };\n      }\n    };\n  };\n\n  const isAttachedToDom = node => {\n    return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n  };\n\n  const isValidRange = rng => {\n    if (!rng) {\n      return false;\n    } else {\n      return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n    }\n  };\n\n  const EditorSelection = (dom, win, serializer, editor) => {\n    let selectedRange;\n    let explicitRange;\n    const {\n      selectorChangedWithUnbind\n    } = SelectorChanged(dom, editor);\n\n    const setCursorLocation = (node, offset) => {\n      const rng = dom.createRng();\n\n      if (isNonNullable(node) && isNonNullable(offset)) {\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        setRng(rng);\n        collapse(false);\n      } else {\n        moveEndPoint(dom, rng, editor.getBody(), true);\n        setRng(rng);\n      }\n    };\n\n    const getContent = args => getContent$1(editor, args);\n\n    const setContent = (content, args) => setContent$1(editor, content, args);\n\n    const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n\n    const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n\n    const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n\n    const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n\n    const select$1 = (node, content) => {\n      select(dom, node, content).each(setRng);\n      return node;\n    };\n\n    const isCollapsed = () => {\n      const rng = getRng$1(),\n            sel = getSel();\n\n      if (!rng || rng.item) {\n        return false;\n      }\n\n      if (rng.compareEndPoints) {\n        return rng.compareEndPoints('StartToEnd', rng) === 0;\n      }\n\n      return !sel || rng.collapsed;\n    };\n\n    const isEditable = () => {\n      const rng = getRng$1();\n      const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n\n      if (fakeSelectedElements.length > 0) {\n        return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n      } else {\n        return isEditableRange(dom, rng);\n      }\n    };\n\n    const collapse = toStart => {\n      const rng = getRng$1();\n      rng.collapse(!!toStart);\n      setRng(rng);\n    };\n\n    const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n\n    const getRng$1 = () => {\n      let rng;\n\n      const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n        try {\n          return sourceRange.compareBoundaryPoints(how, destinationRange);\n        } catch (ex) {\n          return -1;\n        }\n      };\n\n      const doc = win.document;\n\n      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n        const bookmark = getRng(editor);\n\n        if (bookmark.isSome()) {\n          return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n        }\n      }\n\n      try {\n        const selection = getSel();\n\n        if (selection && !isRestrictedNode(selection.anchorNode)) {\n          if (selection.rangeCount > 0) {\n            rng = selection.getRangeAt(0);\n          } else {\n            rng = doc.createRange();\n          }\n\n          rng = processRanges(editor, [rng])[0];\n        }\n      } catch (ex) {}\n\n      if (!rng) {\n        rng = doc.createRange();\n      }\n\n      if (isDocument$1(rng.startContainer) && rng.collapsed) {\n        const elm = dom.getRoot();\n        rng.setStart(elm, 0);\n        rng.setEnd(elm, 0);\n      }\n\n      if (selectedRange && explicitRange) {\n        if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n          rng = explicitRange;\n        } else {\n          selectedRange = null;\n          explicitRange = null;\n        }\n      }\n\n      return rng;\n    };\n\n    const setRng = (rng, forward) => {\n      if (!isValidRange(rng)) {\n        return;\n      }\n\n      const sel = getSel();\n      const evt = editor.dispatch('SetSelectionRange', {\n        range: rng,\n        forward\n      });\n      rng = evt.range;\n\n      if (sel) {\n        explicitRange = rng;\n\n        try {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        } catch (ex) {}\n\n        if (forward === false && sel.extend) {\n          sel.collapse(rng.endContainer, rng.endOffset);\n          sel.extend(rng.startContainer, rng.startOffset);\n        }\n\n        selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n      }\n\n      if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n        if (rng.endOffset - rng.startOffset < 2) {\n          if (rng.startContainer.hasChildNodes()) {\n            const node = rng.startContainer.childNodes[rng.startOffset];\n\n            if (node && node.nodeName === 'IMG') {\n              sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n\n              if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                sel.setBaseAndExtent(node, 0, node, 1);\n              }\n            }\n          }\n        }\n      }\n\n      editor.dispatch('AfterSetSelectionRange', {\n        range: rng,\n        forward\n      });\n    };\n\n    const setNode = elm => {\n      setContent(dom.getOuterHTML(elm));\n      return elm;\n    };\n\n    const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n\n    const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n\n    const isForward = () => {\n      const sel = getSel();\n      const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n      const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n\n      if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n        return true;\n      }\n\n      const anchorRange = dom.createRng();\n      const focusRange = dom.createRng();\n\n      try {\n        anchorRange.setStart(anchorNode, sel.anchorOffset);\n        anchorRange.collapse(true);\n        focusRange.setStart(focusNode, sel.focusOffset);\n        focusRange.collapse(true);\n      } catch (e) {\n        return true;\n      }\n\n      return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n    };\n\n    const normalize = () => {\n      const rng = getRng$1();\n      const sel = getSel();\n\n      if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n        const normRng = normalize$2(dom, rng);\n        normRng.each(normRng => {\n          setRng(normRng, isForward());\n        });\n        return normRng.getOr(rng);\n      }\n\n      return rng;\n    };\n\n    const selectorChanged = (selector, callback) => {\n      selectorChangedWithUnbind(selector, callback);\n      return exports;\n    };\n\n    const getScrollContainer = () => {\n      let scrollContainer;\n      let node = dom.getRoot();\n\n      while (node && node.nodeName !== 'BODY') {\n        if (node.scrollHeight > node.clientHeight) {\n          scrollContainer = node;\n          break;\n        }\n\n        node = node.parentNode;\n      }\n\n      return scrollContainer;\n    };\n\n    const scrollIntoView = (elm, alignToTop) => {\n      if (isNonNullable(elm)) {\n        scrollElementIntoView(editor, elm, alignToTop);\n      } else {\n        scrollRangeIntoView(editor, getRng$1(), alignToTop);\n      }\n    };\n\n    const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n\n    const getBoundingClientRect = () => {\n      const rng = getRng$1();\n      return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n    };\n\n    const destroy = () => {\n      win = selectedRange = explicitRange = null;\n      controlSelection.destroy();\n    };\n\n    const expand = (options = {\n      type: 'word'\n    }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n\n    const exports = {\n      dom,\n      win,\n      serializer,\n      editor,\n      expand,\n      collapse,\n      setCursorLocation,\n      getContent,\n      setContent,\n      getBookmark,\n      moveToBookmark,\n      select: select$1,\n      isCollapsed,\n      isEditable,\n      isForward,\n      setNode,\n      getNode: getNode$1,\n      getSel,\n      setRng,\n      getRng: getRng$1,\n      getStart: getStart$1,\n      getEnd,\n      getSelectedBlocks: getSelectedBlocks$1,\n      normalize,\n      selectorChanged,\n      selectorChangedWithUnbind,\n      getScrollContainer,\n      scrollIntoView,\n      placeCaretAt,\n      getBoundingClientRect,\n      destroy\n    };\n    const bookmarkManager = BookmarkManager(exports);\n    const controlSelection = ControlSelection(exports, editor);\n    exports.bookmarkManager = bookmarkManager;\n    exports.controlSelection = controlSelection;\n    return exports;\n  };\n\n  const register$3 = (htmlParser, settings, dom) => {\n    htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        node.attr('tabindex', node.attr('data-mce-tabindex'));\n        node.attr(name, null);\n      }\n    });\n    htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n      const internalName = 'data-mce-' + name;\n      const urlConverter = settings.url_converter;\n      const urlConverterScope = settings.url_converter_scope;\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr(internalName);\n\n        if (value !== undefined) {\n          node.attr(name, value.length > 0 ? value : null);\n          node.attr(internalName, null);\n        } else {\n          value = node.attr(name);\n\n          if (name === 'style') {\n            value = dom.serializeStyle(dom.parseStyle(value), node.name);\n          } else if (urlConverter) {\n            value = urlConverter.call(urlConverterScope, value, name, node.name);\n          }\n\n          node.attr(name, value.length > 0 ? value : null);\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('class', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr('class');\n\n        if (value) {\n          value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n          node.attr('class', value.length > 0 ? value : null);\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n          const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n            var _a;\n\n            return !isZwsp$1((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n          });\n\n          if (hasChildren) {\n            node.unwrap();\n          } else {\n            node.remove();\n          }\n        }\n      }\n    });\n    htmlParser.addNodeFilter('noscript', nodes => {\n      var _a;\n\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i].firstChild;\n\n        if (node) {\n          node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : '');\n        }\n      }\n    });\n    htmlParser.addNodeFilter('script,style', (nodes, name) => {\n      var _a;\n\n      const trim = value => {\n        return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n      };\n\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        const firstChild = node.firstChild;\n        const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n\n        if (name === 'script') {\n          const type = node.attr('type');\n\n          if (type) {\n            node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n          }\n\n          if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n            firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n          }\n        } else {\n          if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n            firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n          }\n        }\n      }\n    });\n    htmlParser.addNodeFilter('#comment', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        const value = node.value;\n\n        if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n          node.name = '#cdata';\n          node.type = 4;\n          node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n        } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n          node.name = '#text';\n          node.type = 3;\n          node.raw = true;\n          node.value = unescape(value).substr(14);\n        }\n      }\n    });\n    htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (node.type === 7) {\n          node.remove();\n        } else if (node.type === 1) {\n          if (name === 'input' && !node.attr('type')) {\n            node.attr('type', 'text');\n          }\n        }\n      }\n    });\n    htmlParser.addAttributeFilter('data-mce-type', nodes => {\n      each$e(nodes, node => {\n        if (node.attr('data-mce-type') === 'format-caret') {\n          if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n            node.remove();\n          } else {\n            node.unwrap();\n          }\n        }\n      });\n    });\n    htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n      let i = nodes.length;\n\n      while (i--) {\n        nodes[i].attr(name, null);\n      }\n    });\n\n    if (settings.remove_trailing_brs) {\n      addNodeFilter(settings, htmlParser, htmlParser.schema);\n    }\n  };\n\n  const trimTrailingBr = rootNode => {\n    const isBr = node => {\n      return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n    };\n\n    const brNode1 = rootNode.lastChild;\n\n    if (isBr(brNode1)) {\n      const brNode2 = brNode1.prev;\n\n      if (isBr(brNode2)) {\n        brNode1.remove();\n        brNode2.remove();\n      }\n    }\n  };\n\n  const preProcess$1 = (editor, node, args) => {\n    let oldDoc;\n    const dom = editor.dom;\n    let clonedNode = node.cloneNode(true);\n    const impl = document.implementation;\n\n    if (impl.createHTMLDocument) {\n      const doc = impl.createHTMLDocument('');\n      Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n        doc.body.appendChild(doc.importNode(node, true));\n      });\n\n      if (clonedNode.nodeName !== 'BODY') {\n        clonedNode = doc.body.firstChild;\n      } else {\n        clonedNode = doc.body;\n      }\n\n      oldDoc = dom.doc;\n      dom.doc = doc;\n    }\n\n    firePreProcess(editor, { ...args,\n      node: clonedNode\n    });\n\n    if (oldDoc) {\n      dom.doc = oldDoc;\n    }\n\n    return clonedNode;\n  };\n\n  const shouldFireEvent = (editor, args) => {\n    return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n  };\n\n  const process$1 = (editor, node, args) => {\n    return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n  };\n\n  const addTempAttr = (htmlParser, tempAttrs, name) => {\n    if (Tools.inArray(tempAttrs, name) === -1) {\n      htmlParser.addAttributeFilter(name, (nodes, name) => {\n        let i = nodes.length;\n\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      tempAttrs.push(name);\n    }\n  };\n\n  const postProcess = (editor, args, content) => {\n    if (!args.no_events && editor) {\n      const outArgs = firePostProcess(editor, { ...args,\n        content\n      });\n      return outArgs.content;\n    } else {\n      return content;\n    }\n  };\n\n  const getHtmlFromNode = (dom, node, args) => {\n    const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n    return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n  };\n\n  const parseHtml = (htmlParser, html, args) => {\n    const parserArgs = args.selection ? {\n      forced_root_block: false,\n      ...args\n    } : args;\n    const rootNode = htmlParser.parse(html, parserArgs);\n    trimTrailingBr(rootNode);\n    return rootNode;\n  };\n\n  const serializeNode = (settings, schema, node) => {\n    const htmlSerializer = HtmlSerializer(settings, schema);\n    return htmlSerializer.serialize(node);\n  };\n\n  const toHtml = (editor, settings, schema, rootNode, args) => {\n    const content = serializeNode(settings, schema, rootNode);\n    return postProcess(editor, args, content);\n  };\n\n  const DomSerializerImpl = (settings, editor) => {\n    const tempAttrs = ['data-mce-selected'];\n    const defaultedSettings = {\n      entity_encoding: 'named',\n      remove_trailing_brs: true,\n      pad_empty_with_br: false,\n      ...settings\n    };\n    const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n    const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n    const htmlParser = DomParser(defaultedSettings, schema);\n    register$3(htmlParser, defaultedSettings, dom);\n\n    const serialize = (node, parserArgs = {}) => {\n      const args = {\n        format: 'html',\n        ...parserArgs\n      };\n      const targetNode = process$1(editor, node, args);\n      const html = getHtmlFromNode(dom, targetNode, args);\n      const rootNode = parseHtml(htmlParser, html, args);\n      return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n    };\n\n    return {\n      schema,\n      addNodeFilter: htmlParser.addNodeFilter,\n      addAttributeFilter: htmlParser.addAttributeFilter,\n      serialize: serialize,\n      addRules: schema.addValidElements,\n      setRules: schema.setValidElements,\n      addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n      getTempAttrs: constant(tempAttrs),\n      getNodeFilters: htmlParser.getNodeFilters,\n      getAttributeFilters: htmlParser.getAttributeFilters,\n      removeNodeFilter: htmlParser.removeNodeFilter,\n      removeAttributeFilter: htmlParser.removeAttributeFilter\n    };\n  };\n\n  const DomSerializer = (settings, editor) => {\n    const domSerializer = DomSerializerImpl(settings, editor);\n    return {\n      schema: domSerializer.schema,\n      addNodeFilter: domSerializer.addNodeFilter,\n      addAttributeFilter: domSerializer.addAttributeFilter,\n      serialize: domSerializer.serialize,\n      addRules: domSerializer.addRules,\n      setRules: domSerializer.setRules,\n      addTempAttr: domSerializer.addTempAttr,\n      getTempAttrs: domSerializer.getTempAttrs,\n      getNodeFilters: domSerializer.getNodeFilters,\n      getAttributeFilters: domSerializer.getAttributeFilters,\n      removeNodeFilter: domSerializer.removeNodeFilter,\n      removeAttributeFilter: domSerializer.removeAttributeFilter\n    };\n  };\n\n  const defaultFormat$1 = 'html';\n\n  const setupArgs$1 = (args, format) => ({ ...args,\n    format,\n    get: true,\n    getInner: true\n  });\n\n  const getContent = (editor, args = {}) => {\n    const format = args.format ? args.format : defaultFormat$1;\n    const defaultedArgs = setupArgs$1(args, format);\n    return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n      const content = getContent$2(editor, updatedArgs);\n      return postProcessGetContent(editor, content, updatedArgs);\n    });\n  };\n\n  const defaultFormat = 'html';\n\n  const setupArgs = (args, content) => ({\n    format: defaultFormat,\n    ...args,\n    set: true,\n    content\n  });\n\n  const setContent = (editor, content, args = {}) => {\n    const defaultedArgs = setupArgs(args, content);\n    return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n      const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n      postProcessSetContent(editor, result.html, updatedArgs);\n      return result.content;\n    }).getOr(content);\n  };\n\n  const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n  const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');\n  const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n  const deprecatedPlugins = [{\n    name: 'template',\n    replacedWith: 'Advanced Template'\n  }, {\n    name: 'rtc'\n  }];\n\n  const getMatchingOptions = (options, searchingFor) => {\n    const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n    return sort(settingNames);\n  };\n\n  const getRemovedOptions = options => {\n    const settingNames = getMatchingOptions(options, removedOptions);\n    const forcedRootBlock = options.forced_root_block;\n\n    if (forcedRootBlock === false || forcedRootBlock === '') {\n      settingNames.push('forced_root_block (false only)');\n    }\n\n    return sort(settingNames);\n  };\n\n  const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n\n  const getMatchingPlugins = (options, searchingFor) => {\n    const plugins = Tools.makeMap(options.plugins, ' ');\n\n    const hasPlugin = plugin => has$2(plugins, plugin);\n\n    const pluginNames = filter$5(searchingFor, hasPlugin);\n    return sort(pluginNames);\n  };\n\n  const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n\n  const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n\n  const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n    const removedOptions = getRemovedOptions(rawOptions);\n    const removedPlugins = getRemovedPlugins(normalizedOptions);\n    const hasRemovedPlugins = removedPlugins.length > 0;\n    const hasRemovedOptions = removedOptions.length > 0;\n    const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n\n    if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n      const listJoiner = '\\n- ';\n      const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${listJoiner}mobile` : '';\n      const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${listJoiner}${removedPlugins.join(listJoiner)}` : '';\n      const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${listJoiner}${removedOptions.join(listJoiner)}` : '';\n      console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n    }\n  };\n\n  const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n    if (entry.replacedWith) {\n      return `${name}, replaced by ${entry.replacedWith}`;\n    } else {\n      return name;\n    }\n  });\n\n  const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n    const deprecatedOptions = getDeprecatedOptions(rawOptions);\n    const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n    const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n    const hasDeprecatedOptions = deprecatedOptions.length > 0;\n\n    if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n      const listJoiner = '\\n- ';\n      const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${listJoiner}${deprecatedPlugins.map(getPluginDescription).join(listJoiner)}` : '';\n      const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${listJoiner}${deprecatedOptions.join(listJoiner)}` : '';\n      console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n    }\n  };\n\n  const logWarnings = (rawOptions, normalizedOptions) => {\n    logRemovedWarnings(rawOptions, normalizedOptions);\n    logDeprecatedWarnings(rawOptions, normalizedOptions);\n  };\n\n  const DOM$8 = DOMUtils.DOM;\n\n  const restoreOriginalStyles = editor => {\n    DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n  };\n\n  const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n\n  const clearDomReferences = editor => {\n    const ed = editor;\n    ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n    ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n    ed.iframeElement = ed.targetElm = null;\n    const selection = editor.selection;\n\n    if (selection) {\n      const dom = selection.dom;\n      ed.selection = selection.win = selection.dom = dom.doc = null;\n    }\n  };\n\n  const restoreForm = editor => {\n    const form = editor.formElement;\n\n    if (form) {\n      if (form._mceOldSubmit) {\n        form.submit = form._mceOldSubmit;\n        delete form._mceOldSubmit;\n      }\n\n      DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n    }\n  };\n\n  const remove$1 = editor => {\n    if (!editor.removed) {\n      const {\n        _selectionOverrides,\n        editorUpload\n      } = editor;\n      const body = editor.getBody();\n      const element = editor.getElement();\n\n      if (body) {\n        editor.save({\n          is_removing: true\n        });\n      }\n\n      editor.removed = true;\n      editor.unbindAllNativeEvents();\n\n      if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n        DOM$8.remove(element.nextSibling);\n      }\n\n      fireRemove(editor);\n      editor.editorManager.remove(editor);\n\n      if (!editor.inline && body) {\n        restoreOriginalStyles(editor);\n      }\n\n      fireDetach(editor);\n      DOM$8.remove(editor.getContainer());\n      safeDestroy(_selectionOverrides);\n      safeDestroy(editorUpload);\n      editor.destroy();\n    }\n  };\n\n  const destroy = (editor, automatic) => {\n    const {\n      selection,\n      dom\n    } = editor;\n\n    if (editor.destroyed) {\n      return;\n    }\n\n    if (!automatic && !editor.removed) {\n      editor.remove();\n      return;\n    }\n\n    if (!automatic) {\n      editor.editorManager.off('beforeunload', editor._beforeUnload);\n\n      if (editor.theme && editor.theme.destroy) {\n        editor.theme.destroy();\n      }\n\n      safeDestroy(selection);\n      safeDestroy(dom);\n    }\n\n    restoreForm(editor);\n    clearDomReferences(editor);\n    editor.destroyed = true;\n  };\n\n  const CreateIconManager = () => {\n    const lookup = {};\n\n    const add = (id, iconPack) => {\n      lookup[id] = iconPack;\n    };\n\n    const get = id => {\n      if (lookup[id]) {\n        return lookup[id];\n      } else {\n        return {\n          icons: {}\n        };\n      }\n    };\n\n    const has = id => has$2(lookup, id);\n\n    return {\n      add,\n      get,\n      has\n    };\n  };\n\n  const IconManager = CreateIconManager();\n  const ModelManager = AddOnManager.ModelManager;\n\n  const getProp = (propName, elm) => {\n    const rawElm = elm.dom;\n    return rawElm[propName];\n  };\n\n  const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n\n  const getClientWidth = curry(getProp, 'clientWidth');\n  const getClientHeight = curry(getProp, 'clientHeight');\n  const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n  const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n\n  const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n\n  const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n    const clientWidth = getClientWidth(bodyElm);\n    const clientHeight = getClientHeight(bodyElm);\n    return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n  };\n\n  const transpose = (inline, elm, clientX, clientY) => {\n    const clientRect = getBoundingClientRect(elm);\n    const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n    const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n    const x = clientX - deltaX;\n    const y = clientY - deltaY;\n    return {\n      x,\n      y\n    };\n  };\n\n  const isXYInContentArea = (editor, clientX, clientY) => {\n    const bodyElm = SugarElement.fromDom(editor.getBody());\n    const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n    const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n    return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n  };\n\n  const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n\n  const isEditorAttachedToDom = editor => {\n    const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n    return fromDomSafe(rawContainer).map(inBody).getOr(false);\n  };\n\n  var NotificationManagerImpl = () => {\n    const unimplemented = () => {\n      throw new Error('Theme did not provide a NotificationManager implementation.');\n    };\n\n    return {\n      open: unimplemented,\n      close: unimplemented,\n      getArgs: unimplemented\n    };\n  };\n\n  const NotificationManager = editor => {\n    const notifications = [];\n\n    const getImplementation = () => {\n      const theme = editor.theme;\n      return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n    };\n\n    const getTopNotification = () => {\n      return Optional.from(notifications[0]);\n    };\n\n    const isEqual = (a, b) => {\n      return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n    };\n\n    const reposition = () => {\n      each$e(notifications, notification => {\n        notification.reposition();\n      });\n    };\n\n    const addNotification = notification => {\n      notifications.push(notification);\n    };\n\n    const closeNotification = notification => {\n      findIndex$2(notifications, otherNotification => {\n        return otherNotification === notification;\n      }).each(index => {\n        notifications.splice(index, 1);\n      });\n    };\n\n    const open = (spec, fireEvent = true) => {\n      if (editor.removed || !isEditorAttachedToDom(editor)) {\n        return {};\n      }\n\n      if (fireEvent) {\n        editor.dispatch('BeforeOpenNotification', {\n          notification: spec\n        });\n      }\n\n      return find$2(notifications, notification => {\n        return isEqual(getImplementation().getArgs(notification), spec);\n      }).getOrThunk(() => {\n        editor.editorManager.setActive(editor);\n        const notification = getImplementation().open(spec, () => {\n          closeNotification(notification);\n          reposition();\n\n          if (hasEditorOrUiFocus(editor)) {\n            getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n          }\n        });\n        addNotification(notification);\n        reposition();\n        editor.dispatch('OpenNotification', {\n          notification: { ...notification\n          }\n        });\n        return notification;\n      });\n    };\n\n    const close = () => {\n      getTopNotification().each(notification => {\n        getImplementation().close(notification);\n        closeNotification(notification);\n        reposition();\n      });\n    };\n\n    const getNotifications = constant(notifications);\n\n    const registerEvents = editor => {\n      editor.on('SkinLoaded', () => {\n        const serviceMessage = getServiceMessage(editor);\n\n        if (serviceMessage) {\n          open({\n            text: serviceMessage,\n            type: 'warning',\n            timeout: 0\n          }, false);\n        }\n\n        reposition();\n      });\n      editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n        requestAnimationFrame(reposition);\n      });\n      editor.on('remove', () => {\n        each$e(notifications.slice(), notification => {\n          getImplementation().close(notification);\n        });\n      });\n    };\n\n    registerEvents(editor);\n    return {\n      open,\n      close,\n      getNotifications\n    };\n  };\n\n  const PluginManager = AddOnManager.PluginManager;\n  const ThemeManager = AddOnManager.ThemeManager;\n\n  var WindowManagerImpl = () => {\n    const unimplemented = () => {\n      throw new Error('Theme did not provide a WindowManager implementation.');\n    };\n\n    return {\n      open: unimplemented,\n      openUrl: unimplemented,\n      alert: unimplemented,\n      confirm: unimplemented,\n      close: unimplemented\n    };\n  };\n\n  const WindowManager = editor => {\n    let dialogs = [];\n\n    const getImplementation = () => {\n      const theme = editor.theme;\n      return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n    };\n\n    const funcBind = (scope, f) => {\n      return (...args) => {\n        return f ? f.apply(scope, args) : undefined;\n      };\n    };\n\n    const fireOpenEvent = dialog => {\n      editor.dispatch('OpenWindow', {\n        dialog\n      });\n    };\n\n    const fireCloseEvent = dialog => {\n      editor.dispatch('CloseWindow', {\n        dialog\n      });\n    };\n\n    const addDialog = dialog => {\n      dialogs.push(dialog);\n      fireOpenEvent(dialog);\n    };\n\n    const closeDialog = dialog => {\n      fireCloseEvent(dialog);\n      dialogs = filter$5(dialogs, otherDialog => {\n        return otherDialog !== dialog;\n      });\n\n      if (dialogs.length === 0) {\n        editor.focus();\n      }\n    };\n\n    const getTopDialog = () => {\n      return Optional.from(dialogs[dialogs.length - 1]);\n    };\n\n    const storeSelectionAndOpenDialog = openDialog => {\n      editor.editorManager.setActive(editor);\n      store(editor);\n      editor.ui.show();\n      const dialog = openDialog();\n      addDialog(dialog);\n      return dialog;\n    };\n\n    const open = (args, params) => {\n      return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n    };\n\n    const openUrl = args => {\n      return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n    };\n\n    const alert = (message, callback, scope) => {\n      const windowManagerImpl = getImplementation();\n      windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n    };\n\n    const confirm = (message, callback, scope) => {\n      const windowManagerImpl = getImplementation();\n      windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n    };\n\n    const close = () => {\n      getTopDialog().each(dialog => {\n        getImplementation().close(dialog);\n        closeDialog(dialog);\n      });\n    };\n\n    editor.on('remove', () => {\n      each$e(dialogs, dialog => {\n        getImplementation().close(dialog);\n      });\n    });\n    return {\n      open,\n      openUrl,\n      alert,\n      confirm,\n      close\n    };\n  };\n\n  const displayNotification = (editor, message) => {\n    editor.notificationManager.open({\n      type: 'error',\n      text: message\n    });\n  };\n\n  const displayError = (editor, message) => {\n    if (editor._skinLoaded) {\n      displayNotification(editor, message);\n    } else {\n      editor.on('SkinLoaded', () => {\n        displayNotification(editor, message);\n      });\n    }\n  };\n\n  const uploadError = (editor, message) => {\n    displayError(editor, I18n.translate(['Failed to upload image: {0}', message]));\n  };\n\n  const logError = (editor, errorType, msg) => {\n    fireError(editor, errorType, {\n      message: msg\n    });\n    console.error(msg);\n  };\n\n  const createLoadError = (type, url, name) => name ? `Failed to load ${type}: ${name} from url ${url}` : `Failed to load ${type} url: ${url}`;\n\n  const pluginLoadError = (editor, url, name) => {\n    logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n  };\n\n  const iconsLoadError = (editor, url, name) => {\n    logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n  };\n\n  const languageLoadError = (editor, url, name) => {\n    logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n  };\n\n  const themeLoadError = (editor, url, name) => {\n    logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n  };\n\n  const modelLoadError = (editor, url, name) => {\n    logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n  };\n\n  const pluginInitError = (editor, name, err) => {\n    const message = I18n.translate(['Failed to initialize plugin: {0}', name]);\n    fireError(editor, 'PluginLoadError', {\n      message\n    });\n    initError(message, err);\n    displayError(editor, message);\n  };\n\n  const initError = (message, ...x) => {\n    const console = window.console;\n\n    if (console) {\n      if (console.error) {\n        console.error(message, ...x);\n      } else {\n        console.log(message, ...x);\n      }\n    }\n  };\n\n  const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n\n  const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n\n  const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n\n  const getContentCssUrls = editor => {\n    return transformToUrls(editor, getContentCss(editor));\n  };\n\n  const getFontCssUrls = editor => {\n    return transformToUrls(editor, getFontCss(editor));\n  };\n\n  const transformToUrls = (editor, cssLinks) => {\n    const skinUrl = editor.editorManager.baseURL + '/skins/content';\n    const suffix = editor.editorManager.suffix;\n    const contentCssFile = `content${suffix}.css`;\n    return map$3(cssLinks, url => {\n      if (isBundledCssSkinName(url)) {\n        return url;\n      } else if (isContentCssSkinName(url) && !editor.inline) {\n        return `${skinUrl}/${url}/${contentCssFile}`;\n      } else {\n        return editor.documentBaseURI.toAbsolute(url);\n      }\n    });\n  };\n\n  const appendContentCssFromSettings = editor => {\n    editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n  };\n\n  const getAllImages = elm => {\n    return elm ? from(elm.getElementsByTagName('img')) : [];\n  };\n\n  const ImageScanner = (uploadStatus, blobCache) => {\n    const cachedPromises = {};\n\n    const findAll = (elm, predicate = always) => {\n      const images = filter$5(getAllImages(elm), img => {\n        const src = img.src;\n\n        if (img.hasAttribute('data-mce-bogus')) {\n          return false;\n        }\n\n        if (img.hasAttribute('data-mce-placeholder')) {\n          return false;\n        }\n\n        if (!src || src === Env.transparentSrc) {\n          return false;\n        }\n\n        if (startsWith(src, 'blob:')) {\n          return !uploadStatus.isUploaded(src) && predicate(img);\n        }\n\n        if (startsWith(src, 'data:')) {\n          return predicate(img);\n        }\n\n        return false;\n      });\n      const promises = map$3(images, img => {\n        const imageSrc = img.src;\n\n        if (has$2(cachedPromises, imageSrc)) {\n          return cachedPromises[imageSrc].then(imageInfo => {\n            if (isString(imageInfo)) {\n              return imageInfo;\n            } else {\n              return {\n                image: img,\n                blobInfo: imageInfo.blobInfo\n              };\n            }\n          });\n        } else {\n          const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n            delete cachedPromises[imageSrc];\n            return {\n              image: img,\n              blobInfo\n            };\n          }).catch(error => {\n            delete cachedPromises[imageSrc];\n            return error;\n          });\n          cachedPromises[imageSrc] = newPromise;\n          return newPromise;\n        }\n      });\n      return Promise.all(promises);\n    };\n\n    return {\n      findAll\n    };\n  };\n\n  const UploadStatus = () => {\n    const PENDING = 1,\n          UPLOADED = 2;\n    let blobUriStatuses = {};\n\n    const createStatus = (status, resultUri) => {\n      return {\n        status,\n        resultUri\n      };\n    };\n\n    const hasBlobUri = blobUri => {\n      return blobUri in blobUriStatuses;\n    };\n\n    const getResultUri = blobUri => {\n      const result = blobUriStatuses[blobUri];\n      return result ? result.resultUri : null;\n    };\n\n    const isPending = blobUri => {\n      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n    };\n\n    const isUploaded = blobUri => {\n      return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n    };\n\n    const markPending = blobUri => {\n      blobUriStatuses[blobUri] = createStatus(PENDING, null);\n    };\n\n    const markUploaded = (blobUri, resultUri) => {\n      blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n    };\n\n    const removeFailed = blobUri => {\n      delete blobUriStatuses[blobUri];\n    };\n\n    const destroy = () => {\n      blobUriStatuses = {};\n    };\n\n    return {\n      hasBlobUri,\n      getResultUri,\n      isPending,\n      isUploaded,\n      markPending,\n      markUploaded,\n      removeFailed,\n      destroy\n    };\n  };\n\n  let count = 0;\n\n  const seed = () => {\n    const rnd = () => {\n      return Math.round(Math.random() * 4294967295).toString(36);\n    };\n\n    const now = new Date().getTime();\n    return 's' + now.toString(36) + rnd() + rnd() + rnd();\n  };\n\n  const uuid = prefix => {\n    return prefix + count++ + seed();\n  };\n\n  const BlobCache = () => {\n    let cache = [];\n\n    const mimeToExt = mime => {\n      const mimes = {\n        'image/jpeg': 'jpg',\n        'image/jpg': 'jpg',\n        'image/gif': 'gif',\n        'image/png': 'png',\n        'image/apng': 'apng',\n        'image/avif': 'avif',\n        'image/svg+xml': 'svg',\n        'image/webp': 'webp',\n        'image/bmp': 'bmp',\n        'image/tiff': 'tiff'\n      };\n      return mimes[mime.toLowerCase()] || 'dat';\n    };\n\n    const create = (o, blob, base64, name, filename) => {\n      if (isString(o)) {\n        const id = o;\n        return toBlobInfo({\n          id,\n          name,\n          filename,\n          blob: blob,\n          base64: base64\n        });\n      } else if (isObject(o)) {\n        return toBlobInfo(o);\n      } else {\n        throw new Error('Unknown input type');\n      }\n    };\n\n    const toBlobInfo = o => {\n      if (!o.blob || !o.base64) {\n        throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n      }\n\n      const id = o.id || uuid('blobid');\n      const name = o.name || id;\n      const blob = o.blob;\n      return {\n        id: constant(id),\n        name: constant(name),\n        filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n        blob: constant(blob),\n        base64: constant(o.base64),\n        blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n        uri: constant(o.uri)\n      };\n    };\n\n    const add = blobInfo => {\n      if (!get(blobInfo.id())) {\n        cache.push(blobInfo);\n      }\n    };\n\n    const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n\n    const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n\n    const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n\n    const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n\n    const removeByUri = blobUri => {\n      cache = filter$5(cache, blobInfo => {\n        if (blobInfo.blobUri() === blobUri) {\n          URL.revokeObjectURL(blobInfo.blobUri());\n          return false;\n        }\n\n        return true;\n      });\n    };\n\n    const destroy = () => {\n      each$e(cache, cachedBlobInfo => {\n        URL.revokeObjectURL(cachedBlobInfo.blobUri());\n      });\n      cache = [];\n    };\n\n    return {\n      create,\n      add,\n      get,\n      getByUri,\n      getByData,\n      findFirst,\n      removeByUri,\n      destroy\n    };\n  };\n\n  const Uploader = (uploadStatus, settings) => {\n    const pendingPromises = {};\n\n    const pathJoin = (path1, path2) => {\n      if (path1) {\n        return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n      }\n\n      return path2;\n    };\n\n    const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', settings.url);\n      xhr.withCredentials = settings.credentials;\n\n      xhr.upload.onprogress = e => {\n        progress(e.loaded / e.total * 100);\n      };\n\n      xhr.onerror = () => {\n        failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n      };\n\n      xhr.onload = () => {\n        if (xhr.status < 200 || xhr.status >= 300) {\n          failure('HTTP Error: ' + xhr.status);\n          return;\n        }\n\n        const json = JSON.parse(xhr.responseText);\n\n        if (!json || !isString(json.location)) {\n          failure('Invalid JSON: ' + xhr.responseText);\n          return;\n        }\n\n        success(pathJoin(settings.basePath, json.location));\n      };\n\n      const formData = new FormData();\n      formData.append('file', blobInfo.blob(), blobInfo.filename());\n      xhr.send(formData);\n    });\n\n    const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n\n    const noUpload = () => new Promise(resolve => {\n      resolve([]);\n    });\n\n    const handlerSuccess = (blobInfo, url) => ({\n      url,\n      blobInfo,\n      status: true\n    });\n\n    const handlerFailure = (blobInfo, error) => ({\n      url: '',\n      blobInfo,\n      status: false,\n      error\n    });\n\n    const resolvePending = (blobUri, result) => {\n      Tools.each(pendingPromises[blobUri], resolve => {\n        resolve(result);\n      });\n      delete pendingPromises[blobUri];\n    };\n\n    const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n      uploadStatus.markPending(blobInfo.blobUri());\n      return new Promise(resolve => {\n        let notification;\n        let progress;\n\n        try {\n          const closeNotification = () => {\n            if (notification) {\n              notification.close();\n              progress = noop;\n            }\n          };\n\n          const success = url => {\n            closeNotification();\n            uploadStatus.markUploaded(blobInfo.blobUri(), url);\n            resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n            resolve(handlerSuccess(blobInfo, url));\n          };\n\n          const failure = error => {\n            closeNotification();\n            uploadStatus.removeFailed(blobInfo.blobUri());\n            resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n            resolve(handlerFailure(blobInfo, error));\n          };\n\n          progress = percent => {\n            if (percent < 0 || percent > 100) {\n              return;\n            }\n\n            Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n              notification = n;\n              n.progressBar.value(percent);\n            });\n          };\n\n          handler(blobInfo, progress).then(success, err => {\n            failure(isString(err) ? {\n              message: err\n            } : err);\n          });\n        } catch (ex) {\n          resolve(handlerFailure(blobInfo, ex));\n        }\n      });\n    };\n\n    const isDefaultHandler = handler => handler === defaultHandler;\n\n    const pendingUploadBlobInfo = blobInfo => {\n      const blobUri = blobInfo.blobUri();\n      return new Promise(resolve => {\n        pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n        pendingPromises[blobUri].push(resolve);\n      });\n    };\n\n    const uploadBlobs = (blobInfos, openNotification) => {\n      blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n      return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n    };\n\n    const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n\n    return {\n      upload\n    };\n  };\n\n  const openNotification = editor => () => editor.notificationManager.open({\n    text: editor.translate('Image uploading...'),\n    type: 'info',\n    timeout: -1,\n    progressBar: true\n  });\n\n  const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n    url: getImageUploadUrl(editor),\n    basePath: getImageUploadBasePath(editor),\n    credentials: getImagesUploadCredentials(editor),\n    handler: getImagesUploadHandler(editor)\n  });\n\n  const ImageUploader = editor => {\n    const uploadStatus = UploadStatus();\n    const uploader = createUploader(editor, uploadStatus);\n    return {\n      upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined)\n    };\n  };\n\n  const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n\n  const addPaddingToEmpty = editor => element => {\n    if (isEmptyForPadding(editor, element)) {\n      append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n    }\n  };\n\n  const EditorUpload = editor => {\n    const blobCache = BlobCache();\n    let uploader, imageScanner;\n    const uploadStatus = UploadStatus();\n    const urlFilters = [];\n\n    const aliveGuard = callback => {\n      return result => {\n        if (editor.selection) {\n          return callback(result);\n        }\n\n        return [];\n      };\n    };\n\n    const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n\n    const replaceString = (content, search, replace) => {\n      let index = 0;\n\n      do {\n        index = content.indexOf(search, index);\n\n        if (index !== -1) {\n          content = content.substring(0, index) + replace + content.substr(index + search.length);\n          index += replace.length - search.length + 1;\n        }\n      } while (index !== -1);\n\n      return content;\n    };\n\n    const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n      const replacementString = `src=\"${replacementUrl}\"${replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : ''}`;\n      content = replaceString(content, `src=\"${targetUrl}\"`, replacementString);\n      content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n      return content;\n    };\n\n    const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n      each$e(editor.undoManager.data, level => {\n        if (level.type === 'fragmented') {\n          level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n        } else {\n          level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n        }\n      });\n    };\n\n    const replaceImageUriInView = (image, resultUri) => {\n      const src = editor.convertURL(resultUri, 'src');\n      replaceUrlInUndoStack(image.src, resultUri);\n      setAll$1(SugarElement.fromDom(image), {\n        'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n        'data-mce-src': src\n      });\n    };\n\n    const uploadImages = () => {\n      if (!uploader) {\n        uploader = createUploader(editor, uploadStatus);\n      }\n\n      return scanForImages().then(aliveGuard(imageInfos => {\n        const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n        return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n          const imagesToRemove = [];\n          let shouldDispatchChange = false;\n          const filteredResult = map$3(result, (uploadInfo, index) => {\n            const {\n              blobInfo,\n              image\n            } = imageInfos[index];\n            let removed = false;\n\n            if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n              if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                shouldDispatchChange = true;\n              }\n\n              blobCache.removeByUri(image.src);\n              if (isRtc(editor)) ;else {\n                replaceImageUriInView(image, uploadInfo.url);\n              }\n            } else if (uploadInfo.error) {\n              if (uploadInfo.error.remove) {\n                replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                imagesToRemove.push(image);\n                removed = true;\n              }\n\n              uploadError(editor, uploadInfo.error.message);\n            }\n\n            return {\n              element: image,\n              status: uploadInfo.status,\n              uploadUri: uploadInfo.url,\n              blobInfo,\n              removed\n            };\n          });\n\n          if (imagesToRemove.length > 0 && !isRtc(editor)) {\n            editor.undoManager.transact(() => {\n              each$e(fromDom$1(imagesToRemove), sugarElement => {\n                const parentOpt = parent(sugarElement);\n                remove$5(sugarElement);\n                parentOpt.each(addPaddingToEmpty(editor));\n                blobCache.removeByUri(sugarElement.dom.src);\n              });\n            });\n          } else if (shouldDispatchChange) {\n            editor.undoManager.dispatchChange();\n          }\n\n          return filteredResult;\n        }));\n      }));\n    };\n\n    const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n\n    const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n\n    const addFilter = filter => {\n      urlFilters.push(filter);\n    };\n\n    const scanForImages = () => {\n      if (!imageScanner) {\n        imageScanner = ImageScanner(uploadStatus, blobCache);\n      }\n\n      return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n        const filteredResult = filter$5(result, resultItem => {\n          if (isString(resultItem)) {\n            displayError(editor, resultItem);\n            return false;\n          } else if (resultItem.uriType === 'blob') {\n            return false;\n          } else {\n            return true;\n          }\n        });\n        if (isRtc(editor)) ;else {\n          each$e(filteredResult, resultItem => {\n            replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n            resultItem.image.src = resultItem.blobInfo.blobUri();\n            resultItem.image.removeAttribute('data-mce-src');\n          });\n        }\n        return filteredResult;\n      }));\n    };\n\n    const destroy = () => {\n      blobCache.destroy();\n      uploadStatus.destroy();\n      imageScanner = uploader = null;\n    };\n\n    const replaceBlobUris = content => {\n      return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n        const resultUri = uploadStatus.getResultUri(blobUri);\n\n        if (resultUri) {\n          return 'src=\"' + resultUri + '\"';\n        }\n\n        let blobInfo = blobCache.getByUri(blobUri);\n\n        if (!blobInfo) {\n          blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n            return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n          }, undefined);\n        }\n\n        if (blobInfo) {\n          const blob = blobInfo.blob();\n          return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n        }\n\n        return match;\n      });\n    };\n\n    editor.on('SetContent', () => {\n      if (isAutomaticUploadsEnabled(editor)) {\n        uploadImagesAuto();\n      } else {\n        scanForImages();\n      }\n    });\n    editor.on('RawSaveContent', e => {\n      e.content = replaceBlobUris(e.content);\n    });\n    editor.on('GetContent', e => {\n      if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n        return;\n      }\n\n      e.content = replaceBlobUris(e.content);\n    });\n    editor.on('PostRender', () => {\n      editor.parser.addNodeFilter('img', images => {\n        each$e(images, img => {\n          const src = img.attr('src');\n\n          if (!src || blobCache.getByUri(src)) {\n            return;\n          }\n\n          const resultUri = uploadStatus.getResultUri(src);\n\n          if (resultUri) {\n            img.attr('src', resultUri);\n          }\n        });\n      });\n    });\n    return {\n      blobCache,\n      addFilter,\n      uploadImages,\n      uploadImagesAuto,\n      scanForImages,\n      destroy\n    };\n  };\n\n  const get$1 = editor => {\n    const dom = editor.dom;\n    const schemaType = editor.schema.type;\n    const formats = {\n      valigntop: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'top'\n        }\n      }],\n      valignmiddle: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'middle'\n        }\n      }],\n      valignbottom: [{\n        selector: 'td,th',\n        styles: {\n          verticalAlign: 'bottom'\n        }\n      }],\n      alignleft: [{\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-left',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'left'\n        },\n        inherit: false,\n        preview: false\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          float: 'left'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginLeft: '0px',\n          marginRight: 'auto'\n        },\n        onformat: table => {\n          dom.setStyle(table, 'float', null);\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: '.mce-preview-object,[data-ephox-embed-iri]',\n        ceFalseOverride: true,\n        styles: {\n          float: 'left'\n        }\n      }],\n      aligncenter: [{\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'center'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-center',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          display: 'block',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: '.mce-preview-object',\n        ceFalseOverride: true,\n        styles: {\n          display: 'table',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }, {\n        selector: '[data-ephox-embed-iri]',\n        ceFalseOverride: true,\n        styles: {\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        preview: false\n      }],\n      alignright: [{\n        selector: 'figure.image',\n        collapsed: false,\n        classes: 'align-right',\n        ceFalseOverride: true,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'right'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }, {\n        selector: 'img,audio,video',\n        collapsed: false,\n        styles: {\n          float: 'right'\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: 'table',\n        collapsed: false,\n        styles: {\n          marginRight: '0px',\n          marginLeft: 'auto'\n        },\n        onformat: table => {\n          dom.setStyle(table, 'float', null);\n        },\n        preview: 'font-family font-size'\n      }, {\n        selector: '.mce-preview-object,[data-ephox-embed-iri]',\n        ceFalseOverride: true,\n        styles: {\n          float: 'right'\n        },\n        preview: false\n      }],\n      alignjustify: [{\n        selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n        styles: {\n          textAlign: 'justify'\n        },\n        inherit: false,\n        preview: 'font-family font-size'\n      }],\n      bold: [{\n        inline: 'strong',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }, {\n        inline: 'span',\n        styles: {\n          fontWeight: 'bold'\n        }\n      }, {\n        inline: 'b',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      italic: [{\n        inline: 'em',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }, {\n        inline: 'span',\n        styles: {\n          fontStyle: 'italic'\n        }\n      }, {\n        inline: 'i',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      underline: [{\n        inline: 'span',\n        styles: {\n          textDecoration: 'underline'\n        },\n        exact: true\n      }, {\n        inline: 'u',\n        remove: 'all',\n        preserve_attributes: ['class', 'style']\n      }],\n      strikethrough: (() => {\n        const span = {\n          inline: 'span',\n          styles: {\n            textDecoration: 'line-through'\n          },\n          exact: true\n        };\n        const strike = {\n          inline: 'strike',\n          remove: 'all',\n          preserve_attributes: ['class', 'style']\n        };\n        const s = {\n          inline: 's',\n          remove: 'all',\n          preserve_attributes: ['class', 'style']\n        };\n        return schemaType !== 'html4' ? [s, span, strike] : [span, s, strike];\n      })(),\n      forecolor: {\n        inline: 'span',\n        styles: {\n          color: '%value'\n        },\n        links: true,\n        remove_similar: true,\n        clear_child_styles: true\n      },\n      hilitecolor: {\n        inline: 'span',\n        styles: {\n          backgroundColor: '%value'\n        },\n        links: true,\n        remove_similar: true,\n        clear_child_styles: true\n      },\n      fontname: {\n        inline: 'span',\n        toggle: false,\n        styles: {\n          fontFamily: '%value'\n        },\n        clear_child_styles: true\n      },\n      fontsize: {\n        inline: 'span',\n        toggle: false,\n        styles: {\n          fontSize: '%value'\n        },\n        clear_child_styles: true\n      },\n      lineheight: {\n        selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n        styles: {\n          lineHeight: '%value'\n        }\n      },\n      fontsize_class: {\n        inline: 'span',\n        attributes: {\n          class: '%value'\n        }\n      },\n      blockquote: {\n        block: 'blockquote',\n        wrapper: true,\n        remove: 'all'\n      },\n      subscript: {\n        inline: 'sub'\n      },\n      superscript: {\n        inline: 'sup'\n      },\n      code: {\n        inline: 'code'\n      },\n      link: {\n        inline: 'a',\n        selector: 'a',\n        remove: 'all',\n        split: true,\n        deep: true,\n        onmatch: (node, _fmt, _itemName) => {\n          return isElement$6(node) && node.hasAttribute('href');\n        },\n        onformat: (elm, _fmt, vars) => {\n          Tools.each(vars, (value, key) => {\n            dom.setAttrib(elm, key, value);\n          });\n        }\n      },\n      lang: {\n        inline: 'span',\n        clear_child_styles: true,\n        remove_similar: true,\n        attributes: {\n          'lang': '%value',\n          'data-mce-lang': vars => {\n            var _a;\n\n            return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n          }\n        }\n      },\n      removeformat: [{\n        selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n        remove: 'all',\n        split: true,\n        expand: false,\n        block_expand: true,\n        deep: true\n      }, {\n        selector: 'span',\n        attributes: ['style', 'class'],\n        remove: 'empty',\n        split: true,\n        expand: false,\n        deep: true\n      }, {\n        selector: '*',\n        attributes: ['style', 'class'],\n        split: false,\n        expand: false,\n        deep: true\n      }]\n    };\n    Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n      formats[name] = {\n        block: name,\n        remove: 'all'\n      };\n    });\n    return formats;\n  };\n\n  const genericBase = {\n    remove_similar: true,\n    inherit: false\n  };\n  const cellBase = {\n    selector: 'td,th',\n    ...genericBase\n  };\n  const cellFormats = {\n    tablecellbackgroundcolor: {\n      styles: {\n        backgroundColor: '%value'\n      },\n      ...cellBase\n    },\n    tablecellverticalalign: {\n      styles: {\n        'vertical-align': '%value'\n      },\n      ...cellBase\n    },\n    tablecellbordercolor: {\n      styles: {\n        borderColor: '%value'\n      },\n      ...cellBase\n    },\n    tablecellclass: {\n      classes: ['%value'],\n      ...cellBase\n    },\n    tableclass: {\n      selector: 'table',\n      classes: ['%value'],\n      ...genericBase\n    },\n    tablecellborderstyle: {\n      styles: {\n        borderStyle: '%value'\n      },\n      ...cellBase\n    },\n    tablecellborderwidth: {\n      styles: {\n        borderWidth: '%value'\n      },\n      ...cellBase\n    }\n  };\n  const get = constant(cellFormats);\n\n  const FormatRegistry = editor => {\n    const formats = {};\n\n    const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n\n    const has = name => has$2(formats, name);\n\n    const register = (name, format) => {\n      if (name) {\n        if (!isString(name)) {\n          each$d(name, (format, name) => {\n            register(name, format);\n          });\n        } else {\n          if (!isArray$1(format)) {\n            format = [format];\n          }\n\n          each$e(format, format => {\n            if (isUndefined(format.deep)) {\n              format.deep = !isSelectorFormat(format);\n            }\n\n            if (isUndefined(format.split)) {\n              format.split = !isSelectorFormat(format) || isInlineFormat(format);\n            }\n\n            if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n              format.remove = 'none';\n            }\n\n            if (isSelectorFormat(format) && isInlineFormat(format)) {\n              format.mixed = true;\n              format.block_expand = true;\n            }\n\n            if (isString(format.classes)) {\n              format.classes = format.classes.split(/\\s+/);\n            }\n          });\n          formats[name] = format;\n        }\n      }\n    };\n\n    const unregister = name => {\n      if (name && formats[name]) {\n        delete formats[name];\n      }\n\n      return formats;\n    };\n\n    register(get$1(editor));\n    register(get());\n    register(getFormats(editor));\n    return {\n      get: get$2,\n      has,\n      register,\n      unregister\n    };\n  };\n\n  const each$3 = Tools.each;\n  const dom = DOMUtils.DOM;\n\n  const isPreviewItem = item => isNonNullable(item) && isObject(item);\n\n  const parsedSelectorToHtml = (ancestry, editor) => {\n    const schema = editor && editor.schema || Schema({});\n\n    const decorate = (elm, item) => {\n      if (item.classes.length > 0) {\n        dom.addClass(elm, item.classes.join(' '));\n      }\n\n      dom.setAttribs(elm, item.attrs);\n    };\n\n    const createElement = sItem => {\n      const item = isString(sItem) ? {\n        name: sItem,\n        classes: [],\n        attrs: {}\n      } : sItem;\n      const elm = dom.create(item.name);\n      decorate(elm, item);\n      return elm;\n    };\n\n    const getRequiredParent = (elm, candidate) => {\n      const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n      const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n\n      if (parentsRequired && parentsRequired.length) {\n        return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n      } else {\n        return false;\n      }\n    };\n\n    const wrapInHtml = (elm, ancestors, siblings) => {\n      let parentCandidate;\n      const ancestor = ancestors[0];\n      const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n      const parentRequired = getRequiredParent(elm, ancestorName);\n\n      if (parentRequired) {\n        if (ancestorName === parentRequired) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else {\n          parentCandidate = parentRequired;\n        }\n      } else if (ancestor) {\n        parentCandidate = ancestor;\n        ancestors = ancestors.slice(1);\n      } else if (!siblings) {\n        return elm;\n      }\n\n      const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n      parent.appendChild(elm);\n\n      if (siblings) {\n        Tools.each(siblings, sibling => {\n          const siblingElm = createElement(sibling);\n          parent.insertBefore(siblingElm, elm);\n        });\n      }\n\n      const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n      return wrapInHtml(parent, ancestors, parentSiblings);\n    };\n\n    const fragment = dom.create('div');\n\n    if (ancestry.length > 0) {\n      const item = ancestry[0];\n      const elm = createElement(item);\n      const siblings = isPreviewItem(item) ? item.siblings : undefined;\n      fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n    }\n\n    return fragment;\n  };\n\n  const parseSelectorItem = item => {\n    item = Tools.trim(item);\n    let tagName = 'div';\n    const obj = {\n      name: tagName,\n      classes: [],\n      attrs: {},\n      selector: item\n    };\n\n    if (item !== '*') {\n      tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n        switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n\n          case '.':\n            obj.classes.push($2);\n            break;\n\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n\n            break;\n        }\n\n        if ($3 === '[') {\n          const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n\n          if (m) {\n            obj.attrs[m[1]] = m[2];\n          }\n        }\n\n        return '';\n      });\n    }\n\n    obj.name = tagName || 'div';\n    return obj;\n  };\n\n  const parseSelector = selector => {\n    if (!isString(selector)) {\n      return [];\n    }\n\n    selector = selector.split(/\\s*,\\s*/)[0];\n    selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n    return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n      const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n      const obj = siblings.pop();\n\n      if (siblings.length) {\n        obj.siblings = siblings;\n      }\n\n      return obj;\n    }).reverse();\n  };\n\n  const getCssText = (editor, format) => {\n    let previewCss = '';\n    let previewStyles = getPreviewStyles(editor);\n\n    if (previewStyles === '') {\n      return '';\n    }\n\n    const removeVars = val => {\n      return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n    };\n\n    const getComputedStyle = (name, elm) => {\n      return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n    };\n\n    if (isString(format)) {\n      const formats = editor.formatter.get(format);\n\n      if (!formats) {\n        return '';\n      }\n\n      format = formats[0];\n    }\n\n    if ('preview' in format) {\n      const preview = format.preview;\n\n      if (preview === false) {\n        return '';\n      } else {\n        previewStyles = preview || previewStyles;\n      }\n    }\n\n    let name = format.block || format.inline || 'span';\n    let previewFrag;\n    const items = parseSelector(format.selector);\n\n    if (items.length > 0) {\n      if (!items[0].name) {\n        items[0].name = name;\n      }\n\n      name = format.selector;\n      previewFrag = parsedSelectorToHtml(items, editor);\n    } else {\n      previewFrag = parsedSelectorToHtml([name], editor);\n    }\n\n    const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n    each$3(format.styles, (value, name) => {\n      const newValue = removeVars(value);\n\n      if (newValue) {\n        dom.setStyle(previewElm, name, newValue);\n      }\n    });\n    each$3(format.attributes, (value, name) => {\n      const newValue = removeVars(value);\n\n      if (newValue) {\n        dom.setAttrib(previewElm, name, newValue);\n      }\n    });\n    each$3(format.classes, value => {\n      const newValue = removeVars(value);\n\n      if (!dom.hasClass(previewElm, newValue)) {\n        dom.addClass(previewElm, newValue);\n      }\n    });\n    editor.dispatch('PreviewFormats');\n    dom.setStyles(previewFrag, {\n      position: 'absolute',\n      left: -65535\n    });\n    editor.getBody().appendChild(previewFrag);\n    const rawParentFontSize = getComputedStyle('fontSize');\n    const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n    each$3(previewStyles.split(' '), name => {\n      let value = getComputedStyle(name, previewElm);\n\n      if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n        value = getComputedStyle(name);\n\n        if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n          return;\n        }\n      }\n\n      if (name === 'color') {\n        if (rgbaToHexString(value).toLowerCase() === '#000000') {\n          return;\n        }\n      }\n\n      if (name === 'font-size') {\n        if (/em|%$/.test(value)) {\n          if (parentFontSize === 0) {\n            return;\n          }\n\n          const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n          value = numValue * parentFontSize + 'px';\n        }\n      }\n\n      if (name === 'border' && value) {\n        previewCss += 'padding:0 2px;';\n      }\n\n      previewCss += name + ':' + value + ';';\n    });\n    editor.dispatch('AfterPreviewFormats');\n    dom.remove(previewFrag);\n    return previewCss;\n  };\n\n  const setup$s = editor => {\n    editor.addShortcut('meta+b', '', 'Bold');\n    editor.addShortcut('meta+i', '', 'Italic');\n    editor.addShortcut('meta+u', '', 'Underline');\n\n    for (let i = 1; i <= 6; i++) {\n      editor.addShortcut('access+' + i, '', ['FormatBlock', false, 'h' + i]);\n    }\n\n    editor.addShortcut('access+7', '', ['FormatBlock', false, 'p']);\n    editor.addShortcut('access+8', '', ['FormatBlock', false, 'div']);\n    editor.addShortcut('access+9', '', ['FormatBlock', false, 'address']);\n  };\n\n  const Formatter = editor => {\n    const formats = FormatRegistry(editor);\n    const formatChangeState = Cell({});\n    setup$s(editor);\n    setup$v(editor);\n\n    if (!isRtc(editor)) {\n      setup$u(formatChangeState, editor);\n    }\n\n    return {\n      get: formats.get,\n      has: formats.has,\n      register: formats.register,\n      unregister: formats.unregister,\n      apply: (name, vars, node) => {\n        applyFormat(editor, name, vars, node);\n      },\n      remove: (name, vars, node, similar) => {\n        removeFormat(editor, name, vars, node, similar);\n      },\n      toggle: (name, vars, node) => {\n        toggleFormat(editor, name, vars, node);\n      },\n      match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n      closest: names => closestFormat(editor, names),\n      matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n      matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n      canApply: name => canApplyFormat(editor, name),\n      formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n      getCssText: curry(getCssText, editor)\n    };\n  };\n\n  const shouldIgnoreCommand = cmd => {\n    switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n\n      default:\n        return false;\n    }\n  };\n\n  const registerEvents = (editor, undoManager, locks) => {\n    const isFirstTypedCharacter = Cell(false);\n\n    const addNonTypingUndoLevel = e => {\n      setTyping(undoManager, false, locks);\n      undoManager.add({}, e);\n    };\n\n    editor.on('init', () => {\n      undoManager.add();\n    });\n    editor.on('BeforeExecCommand', e => {\n      const cmd = e.command;\n\n      if (!shouldIgnoreCommand(cmd)) {\n        endTyping(undoManager, locks);\n        undoManager.beforeChange();\n      }\n    });\n    editor.on('ExecCommand', e => {\n      const cmd = e.command;\n\n      if (!shouldIgnoreCommand(cmd)) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    editor.on('ObjectResizeStart cut', () => {\n      undoManager.beforeChange();\n    });\n    editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n    editor.on('dragend', addNonTypingUndoLevel);\n    editor.on('keyup', e => {\n      const keyCode = e.keyCode;\n\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n\n      const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n\n      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n        addNonTypingUndoLevel();\n        editor.nodeChanged();\n      }\n\n      if (keyCode === 46 || keyCode === 8) {\n        editor.nodeChanged();\n      }\n\n      if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n        if (!editor.isDirty()) {\n          editor.setDirty(true);\n        }\n\n        editor.dispatch('TypingUndo');\n        isFirstTypedCharacter.set(false);\n        editor.nodeChanged();\n      }\n    });\n    editor.on('keydown', e => {\n      const keyCode = e.keyCode;\n\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n\n      if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n\n        return;\n      }\n\n      const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n\n      if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n        undoManager.beforeChange();\n        setTyping(undoManager, true, locks);\n        undoManager.add({}, e);\n        isFirstTypedCharacter.set(true);\n        return;\n      }\n\n      const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n\n      if (hasOnlyMetaOrCtrlModifier) {\n        undoManager.beforeChange();\n      }\n    });\n    editor.on('mousedown', e => {\n      if (undoManager.typing) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n\n    const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n\n    const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n\n    const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n\n    editor.on('input', e => {\n      if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n        addNonTypingUndoLevel(e);\n      }\n    });\n    editor.on('AddUndo Undo Redo ClearUndos', e => {\n      if (!e.isDefaultPrevented()) {\n        editor.nodeChanged();\n      }\n    });\n  };\n\n  const addKeyboardShortcuts = editor => {\n    editor.addShortcut('meta+z', '', 'Undo');\n    editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n  };\n\n  const UndoManager = editor => {\n    const beforeBookmark = value$2();\n    const locks = Cell(0);\n    const index = Cell(0);\n    const undoManager = {\n      data: [],\n      typing: false,\n      beforeChange: () => {\n        beforeChange(editor, locks, beforeBookmark);\n      },\n      add: (level, event) => {\n        return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n      },\n      dispatchChange: () => {\n        editor.setDirty(true);\n        const level = createFromEditor(editor);\n        level.bookmark = getUndoBookmark(editor.selection);\n        editor.dispatch('change', {\n          level,\n          lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n        });\n      },\n      undo: () => {\n        return undo(editor, undoManager, locks, index);\n      },\n      redo: () => {\n        return redo(editor, index, undoManager.data);\n      },\n      clear: () => {\n        clear(editor, undoManager, index);\n      },\n      reset: () => {\n        reset(editor, undoManager);\n      },\n      hasUndo: () => {\n        return hasUndo(editor, undoManager, index);\n      },\n      hasRedo: () => {\n        return hasRedo(editor, undoManager, index);\n      },\n      transact: callback => {\n        return transact(editor, undoManager, locks, callback);\n      },\n      ignore: callback => {\n        ignore(editor, locks, callback);\n      },\n      extra: (callback1, callback2) => {\n        extra(editor, undoManager, index, callback1, callback2);\n      }\n    };\n\n    if (!isRtc(editor)) {\n      registerEvents(editor, undoManager, locks);\n    }\n\n    addKeyboardShortcuts(editor);\n    return undoManager;\n  };\n\n  const nonTypingKeycodes = [9, 27, VK.HOME, VK.END, 19, 20, 44, 144, 145, 33, 34, 45, 16, 17, 18, 91, 92, 93, VK.DOWN, VK.UP, VK.LEFT, VK.RIGHT].concat(Env.browser.isFirefox() ? [224] : []);\n  const placeholderAttr = 'data-mce-placeholder';\n\n  const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n\n  const isDeleteEvent = e => {\n    const keyCode = e.keyCode;\n    return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n  };\n\n  const isNonTypingKeyboardEvent = e => {\n    if (isKeyboardEvent(e)) {\n      const keyCode = e.keyCode;\n      return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n    } else {\n      return false;\n    }\n  };\n\n  const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n\n  const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n    if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n      const firstElement = rootElm.firstElementChild;\n\n      if (!firstElement) {\n        return true;\n      } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n        return false;\n      } else {\n        return forcedRootBlock === firstElement.nodeName.toLowerCase();\n      }\n    } else {\n      return false;\n    }\n  };\n\n  const setup$r = editor => {\n    var _a;\n\n    const dom = editor.dom;\n    const rootBlock = getForcedRootBlock(editor);\n    const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n\n    const updatePlaceholder = (e, initial) => {\n      if (isNonTypingKeyboardEvent(e)) {\n        return;\n      }\n\n      const body = editor.getBody();\n      const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n      const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n\n      if (isPlaceholderShown !== showPlaceholder || initial) {\n        dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n        dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n        firePlaceholderToggle(editor, showPlaceholder);\n        editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n        editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n      }\n    };\n\n    if (isNotEmpty(placeholder)) {\n      editor.on('init', e => {\n        updatePlaceholder(e, true);\n        editor.on('change SetContent ExecCommand', updatePlaceholder);\n        editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n      });\n    }\n  };\n\n  const blockPosition = (block, position) => ({\n    block,\n    position\n  });\n\n  const blockBoundary = (from, to) => ({\n    from,\n    to\n  });\n\n  const getBlockPosition = (rootNode, pos) => {\n    const rootElm = SugarElement.fromDom(rootNode);\n    const containerElm = SugarElement.fromDom(pos.container());\n    return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n  };\n\n  const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n\n  const getClosestHost = (root, scope) => {\n    const isRoot = node => eq(node, root);\n\n    const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n\n    return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n  };\n\n  const hasSameHost = (rootNode, blockBoundary) => {\n    const root = SugarElement.fromDom(rootNode);\n    return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n  };\n\n  const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n\n  const hasValidBlocks = blockBoundary => {\n    const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);\n\n    return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n  };\n\n  const skipLastBr = (rootNode, forward, blockPosition) => {\n    if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {\n      return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n        if (lastPositionInBlock.isEqual(blockPosition.position)) {\n          return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n        } else {\n          return Optional.some(blockPosition);\n        }\n      }).getOr(blockPosition);\n    } else {\n      return blockPosition;\n    }\n  };\n\n  const readFromRange = (rootNode, forward, rng) => {\n    const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n    const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n    return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));\n  };\n\n  const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n  const getChildrenUntilBlockBoundary = (block, schema) => {\n    const children = children$1(block);\n    return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n  };\n\n  const extractChildren = (block, schema) => {\n    const children = getChildrenUntilBlockBoundary(block, schema);\n    each$e(children, remove$5);\n    return children;\n  };\n\n  const removeEmptyRoot = (rootNode, block) => {\n    const parents = parentsAndSelf(block, rootNode);\n    return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n  };\n\n  const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n\n  const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\n    if (isEmpty$2(toBlock)) {\n      fillWithPaddingBr(toBlock);\n      return firstPositionIn(toBlock.dom);\n    }\n\n    if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n      before$3(insertionPoint, SugarElement.fromTag('br'));\n    }\n\n    const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n    each$e(extractChildren(fromBlock, schema), child => {\n      before$3(insertionPoint, child);\n    });\n    removeEmptyRoot(rootNode, fromBlock);\n    return position;\n  };\n\n  const isInline = (schema, node) => schema.isInline(name(node));\n\n  const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\n    if (isEmpty$2(toBlock)) {\n      if (isEmpty$2(fromBlock)) {\n        const getInlineToBlockDescendants = el => {\n          const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n\n          return helper(el, []);\n        };\n\n        const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n          wrap$2(element, descendant);\n          return descendant;\n        }, createPaddingBr());\n        empty(fromBlock);\n        append$1(fromBlock, newFromBlockDescendants);\n      }\n\n      remove$5(toBlock);\n      return firstPositionIn(fromBlock.dom);\n    }\n\n    const position = lastPositionIn(toBlock.dom);\n    each$e(extractChildren(fromBlock, schema), child => {\n      append$1(toBlock, child);\n    });\n    removeEmptyRoot(rootNode, fromBlock);\n    return position;\n  };\n\n  const findInsertionPoint = (toBlock, block) => {\n    const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n    return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n  };\n\n  const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n\n  const trimBr = (first, block) => {\n    positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);\n  };\n\n  const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\n    trimBr(true, fromBlock);\n    trimBr(false, toBlock);\n    return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\n  };\n\n  const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\n\n  const backspaceDelete$9 = (editor, forward) => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n      mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\n        editor.selection.setRng(pos.toRange());\n      });\n    });\n    return position;\n  };\n\n  const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n    const rng = selection.getRng();\n    return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n      if (!eq(block1, block2)) {\n        return Optional.some(() => {\n          rng.deleteContents();\n          mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n            selection.setRng(pos.toRange());\n          });\n        });\n      } else {\n        return Optional.none();\n      }\n    }).getOr(Optional.none());\n  };\n\n  const isRawNodeInTable = (root, rawNode) => {\n    const node = SugarElement.fromDom(rawNode);\n    const isRoot = curry(eq, root);\n    return ancestor$4(node, isTableCell$2, isRoot).isSome();\n  };\n\n  const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n\n  const isEverythingSelected = (root, rng) => {\n    const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n    const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n    return !isSelectionInTable(root, rng) && noPrevious && noNext;\n  };\n\n  const emptyEditor = editor => {\n    return Optional.some(() => {\n      editor.setContent('');\n      editor.selection.setCursorLocation();\n    });\n  };\n\n  const deleteRange$2 = editor => {\n    const rootNode = SugarElement.fromDom(editor.getBody());\n    const rng = editor.selection.getRng();\n    return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n  };\n\n  const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n\n  const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n\n  const getNodeRange = node => {\n    const rng = node.ownerDocument.createRange();\n    rng.selectNode(node);\n    return rng;\n  };\n\n  const selectNode = (editor, node) => {\n    const e = editor.dispatch('BeforeObjectSelected', {\n      target: node\n    });\n\n    if (e.isDefaultPrevented()) {\n      return Optional.none();\n    }\n\n    return Optional.some(getNodeRange(node));\n  };\n\n  const renderCaretAtRange = (editor, range, scrollIntoView) => {\n    const normalizedRange = normalizeRange(1, editor.getBody(), range);\n    const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n    const caretPositionNode = caretPosition.getNode();\n\n    if (isInlineFakeCaretTarget(caretPositionNode)) {\n      return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n    }\n\n    const caretPositionBeforeNode = caretPosition.getNode(true);\n\n    if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n      return showCaret(1, editor, caretPositionBeforeNode, false, false);\n    }\n\n    const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n\n    if (isInlineFakeCaretTarget(ceRoot)) {\n      return showCaret(1, editor, ceRoot, false, scrollIntoView);\n    }\n\n    return Optional.none();\n  };\n\n  const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n  const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n\n  const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n\n  const trimEmptyTextNode = (dom, node) => {\n    if (isText$a(node) && node.data.length === 0) {\n      dom.remove(node);\n    }\n  };\n\n  const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n    showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n      if (range.collapsed) {\n        const deleteRange = range.cloneRange();\n\n        if (forward) {\n          deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n        } else {\n          deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n        }\n\n        deleteRange.deleteContents();\n      } else {\n        range.deleteContents();\n      }\n\n      editor.selection.setRng(caretRange);\n    });\n    trimEmptyTextNode(editor.dom, node);\n  };\n\n  const deleteBoundaryText = (editor, forward) => {\n    const range = editor.selection.getRng();\n\n    if (!isText$a(range.commonAncestorContainer)) {\n      return Optional.none();\n    }\n\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const caretWalker = CaretWalker(editor.getBody());\n    const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n    const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    const nextCaretPosition = getNextPosFn(caretPosition);\n    const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n\n    if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n      return Optional.none();\n    } else if (isBeforeFn(normalizedNextCaretPosition)) {\n      return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n    }\n\n    const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n\n    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n      if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n  const getEdgeCefPosition = (editor, atStart) => {\n    const root = editor.getBody();\n    return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n  };\n\n  const isCefAtEdgeSelected = editor => {\n    const rng = editor.selection.getRng();\n    return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n  };\n\n  const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n\n  const DeleteAction = Adt.generate([{\n    remove: ['element']\n  }, {\n    moveToElement: ['element']\n  }, {\n    moveToPosition: ['position']\n  }]);\n\n  const isAtContentEditableBlockCaret = (forward, from) => {\n    const elm = from.getNode(!forward);\n    const caretLocation = forward ? 'after' : 'before';\n    return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n  };\n\n  const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n    const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n\n    return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n  };\n\n  const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n    const toCefElm = to.getNode(!forward);\n    return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n  };\n\n  const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n    if (isCompoundElement(to.getNode())) {\n      return Optional.none();\n    } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n      return Optional.none();\n    } else if (forward && isContentEditableFalse$b(to.getNode())) {\n      return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n    } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n      return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n    } else if (forward && isAfterContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    } else if (!forward && isBeforeContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    } else {\n      return Optional.none();\n    }\n  });\n\n  const getContentEditableBlockAction = (forward, elm) => {\n    if (isNullable(elm)) {\n      return Optional.none();\n    } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n      return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n    } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n      return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n    if (isInSameBlock(from, to, root)) {\n      return Optional.none();\n    } else {\n      return Optional.some(DeleteAction.moveToPosition(to));\n    }\n  });\n\n  const getContentEditableAction = (root, forward, from, schema) => {\n    if (isAtContentEditableBlockCaret(forward, from)) {\n      return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n    } else {\n      return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n    }\n  };\n\n  const read = (root, forward, rng, schema) => {\n    const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n    const from = CaretPosition.fromRangeStart(normalizedRange);\n    const rootElement = SugarElement.fromDom(root);\n\n    if (!forward && isAfterContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.remove(from.getNode(true)));\n    } else if (forward && isBeforeContentEditableFalse(from)) {\n      return Optional.some(DeleteAction.remove(from.getNode()));\n    } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n      return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n    } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n      return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n    } else {\n      return getContentEditableAction(root, forward, from, schema);\n    }\n  };\n\n  const deleteElement$1 = (editor, forward) => element => {\n    editor._selectionOverrides.hideFakeCaret();\n\n    deleteElement$2(editor, forward, SugarElement.fromDom(element));\n    return true;\n  };\n\n  const moveToElement = (editor, forward) => element => {\n    const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n    editor.selection.setRng(pos.toRange());\n    return true;\n  };\n\n  const moveToPosition = editor => pos => {\n    editor.selection.setRng(pos.toRange());\n    return true;\n  };\n\n  const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n\n  const backspaceDeleteCaret = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n  };\n\n  const deleteOffscreenSelection = rootElement => {\n    each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n  };\n\n  const backspaceDeleteRange = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n\n    if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n      const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n      return hasCefAncestor.fold(() => Optional.some(() => {\n        deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n        deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n        paddEmptyBody(editor);\n      }), () => Optional.some(noop));\n    }\n\n    if (isCefAtEdgeSelected(editor)) {\n      return Optional.some(() => {\n        deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n      });\n    }\n\n    return Optional.none();\n  };\n\n  const paddEmptyElement = editor => {\n    const dom = editor.dom,\n          selection = editor.selection;\n    const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n\n    if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n      const br = dom.create('br', {\n        'data-mce-bogus': '1'\n      });\n      dom.setHTML(ceRoot, '');\n      ceRoot.appendChild(br);\n      selection.setRng(CaretPosition.before(br).toRange());\n    }\n\n    return true;\n  };\n\n  const backspaceDelete$6 = (editor, forward) => {\n    if (editor.selection.isCollapsed()) {\n      return backspaceDeleteCaret(editor, forward);\n    } else {\n      return backspaceDeleteRange(editor, forward);\n    }\n  };\n\n  const deleteCaret$2 = (editor, forward) => {\n    const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n  };\n\n  const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n  const isText$2 = isText$a;\n\n  const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n\n  const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n\n  const createZwsp = node => {\n    var _a;\n\n    const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n    return doc.createTextNode(ZWSP$1);\n  };\n\n  const insertBefore$1 = node => {\n    var _a;\n\n    if (isText$2(node.previousSibling)) {\n      if (endsWithCaretContainer(node.previousSibling)) {\n        return node.previousSibling;\n      } else {\n        node.previousSibling.appendData(ZWSP$1);\n        return node.previousSibling;\n      }\n    } else if (isText$2(node)) {\n      if (startsWithCaretContainer(node)) {\n        return node;\n      } else {\n        node.insertData(0, ZWSP$1);\n        return node;\n      }\n    } else {\n      const newNode = createZwsp(node);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n      return newNode;\n    }\n  };\n\n  const insertAfter$1 = node => {\n    var _a, _b;\n\n    if (isText$2(node.nextSibling)) {\n      if (startsWithCaretContainer(node.nextSibling)) {\n        return node.nextSibling;\n      } else {\n        node.nextSibling.insertData(0, ZWSP$1);\n        return node.nextSibling;\n      }\n    } else if (isText$2(node)) {\n      if (endsWithCaretContainer(node)) {\n        return node;\n      } else {\n        node.appendData(ZWSP$1);\n        return node;\n      }\n    } else {\n      const newNode = createZwsp(node);\n\n      if (node.nextSibling) {\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n      } else {\n        (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n      }\n\n      return newNode;\n    }\n  };\n\n  const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n\n  const insertInlineBefore = curry(insertInline, true);\n  const insertInlineAfter = curry(insertInline, false);\n\n  const insertInlinePos = (pos, before) => {\n    if (isText$a(pos.container())) {\n      return insertInline(before, pos.container());\n    } else {\n      return insertInline(before, pos.getNode());\n    }\n  };\n\n  const isPosCaretContainer = (pos, caret) => {\n    const caretNode = caret.get();\n    return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n  };\n\n  const renderCaret = (caret, location) => location.fold(element => {\n    remove$3(caret.get());\n    const text = insertInlineBefore(element);\n    caret.set(text);\n    return Optional.some(CaretPosition(text, text.length - 1));\n  }, element => firstPositionIn(element).map(pos => {\n    if (!isPosCaretContainer(pos, caret)) {\n      remove$3(caret.get());\n      const text = insertInlinePos(pos, true);\n      caret.set(text);\n      return CaretPosition(text, 1);\n    } else {\n      const node = caret.get();\n      return CaretPosition(node, 1);\n    }\n  }), element => lastPositionIn(element).map(pos => {\n    if (!isPosCaretContainer(pos, caret)) {\n      remove$3(caret.get());\n      const text = insertInlinePos(pos, false);\n      caret.set(text);\n      return CaretPosition(text, text.length - 1);\n    } else {\n      const node = caret.get();\n      return CaretPosition(node, node.length - 1);\n    }\n  }), element => {\n    remove$3(caret.get());\n    const text = insertInlineAfter(element);\n    caret.set(text);\n    return Optional.some(CaretPosition(text, 1));\n  });\n\n  const evaluateUntil = (fns, args) => {\n    for (let i = 0; i < fns.length; i++) {\n      const result = fns[i].apply(null, args);\n\n      if (result.isSome()) {\n        return result;\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const Location = Adt.generate([{\n    before: ['element']\n  }, {\n    start: ['element']\n  }, {\n    end: ['element']\n  }, {\n    after: ['element']\n  }]);\n\n  const rescope$1 = (rootNode, node) => {\n    const parentBlock = getParentBlock$3(node, rootNode);\n    return parentBlock ? parentBlock : rootNode;\n  };\n\n  const before = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeForwards(pos);\n    const scope = rescope$1(rootNode, nPos.container());\n    return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n  };\n\n  const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n\n  const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n\n  const start$1 = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeBackwards(pos);\n    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n      const prevPos = prevPosition(inline, nPos);\n      return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n    });\n  };\n\n  const end = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeForwards(pos);\n    return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n      const nextPos = nextPosition(inline, nPos);\n      return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n    });\n  };\n\n  const after = (isInlineTarget, rootNode, pos) => {\n    const nPos = normalizeBackwards(pos);\n    const scope = rescope$1(rootNode, nPos.container());\n    return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n  };\n\n  const isValidLocation = location => !isRtl(getElement(location));\n\n  const readLocation = (isInlineTarget, rootNode, pos) => {\n    const location = evaluateUntil([before, start$1, end, after], [isInlineTarget, rootNode, pos]);\n    return location.filter(isValidLocation);\n  };\n\n  const getElement = location => location.fold(identity, identity, identity, identity);\n\n  const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n\n  const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n\n  const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n\n  const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n\n  const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n    if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n      return Location.after(forward ? fromInline : toInline);\n    } else {\n      return location;\n    }\n  }).getOr(location);\n\n  const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n\n  const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n    const from = normalizePosition(forward, pos);\n    const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n    const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n    return location.filter(isValidLocation);\n  };\n\n  const findLocationSimple = (forward, location) => {\n    if (forward) {\n      return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n    } else {\n      return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n    }\n  };\n\n  const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n    const from = normalizePosition(forward, pos);\n    const fromLocation = readLocation(isInlineTarget, rootNode, from);\n    return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n  };\n\n  const hasSelectionModifyApi = editor => {\n    return isFunction(editor.selection.getSel().modify);\n  };\n\n  const moveRel = (forward, selection, pos) => {\n    const delta = forward ? 1 : -1;\n    selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n    selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n    return true;\n  };\n\n  const moveByWord = (forward, editor) => {\n    const rng = editor.selection.getRng();\n    const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n\n    if (!hasSelectionModifyApi(editor)) {\n      return false;\n    } else if (forward && isBeforeInline(pos)) {\n      return moveRel(true, editor.selection, pos);\n    } else if (!forward && isAfterInline(pos)) {\n      return moveRel(false, editor.selection, pos);\n    } else {\n      return false;\n    }\n  };\n\n  var BreakType;\n\n  (function (BreakType) {\n    BreakType[BreakType['Br'] = 0] = 'Br';\n    BreakType[BreakType['Block'] = 1] = 'Block';\n    BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n    BreakType[BreakType['Eol'] = 3] = 'Eol';\n  })(BreakType || (BreakType = {}));\n\n  const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n\n  const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n\n  const getBreakType = (scope, direction, currentPos, nextPos) => {\n    if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n      return BreakType.Br;\n    } else if (isInSameBlock(currentPos, nextPos) === false) {\n      return BreakType.Block;\n    } else {\n      return BreakType.Wrap;\n    }\n  };\n\n  const getPositionsUntil = (predicate, direction, scope, start) => {\n    const caretWalker = CaretWalker(scope);\n    let currentPos = start;\n    const positions = [];\n\n    while (currentPos) {\n      const nextPos = walk$1(direction, caretWalker, currentPos);\n\n      if (!nextPos) {\n        break;\n      }\n\n      if (isBr$6(nextPos.getNode(false))) {\n        if (direction === HDirection.Forwards) {\n          return {\n            positions: flip(direction, positions).concat([nextPos]),\n            breakType: BreakType.Br,\n            breakAt: Optional.some(nextPos)\n          };\n        } else {\n          return {\n            positions: flip(direction, positions),\n            breakType: BreakType.Br,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n      }\n\n      if (!nextPos.isVisible()) {\n        currentPos = nextPos;\n        continue;\n      }\n\n      if (predicate(currentPos, nextPos)) {\n        const breakType = getBreakType(scope, direction, currentPos, nextPos);\n        return {\n          positions: flip(direction, positions),\n          breakType,\n          breakAt: Optional.some(nextPos)\n        };\n      }\n\n      positions.push(nextPos);\n      currentPos = nextPos;\n    }\n\n    return {\n      positions: flip(direction, positions),\n      breakType: BreakType.Eol,\n      breakAt: Optional.none()\n    };\n  };\n\n  const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n    const positions = getPositionsUntilBreak(scope, pos).positions;\n    return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n  }).getOr([]);\n\n  const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n    const lastDist = Math.abs(x - lastRect.left);\n    const newDist = Math.abs(x - newRect.left);\n    return newDist <= lastDist ? newPos : lastPos;\n  }).or(acc)), Optional.none());\n\n  const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n\n  const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n  const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n  const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n  const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n\n  const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n\n  const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n\n  const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n\n  const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n\n  const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n\n  const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n\n  const isContentEditableFalse$4 = isContentEditableFalse$b;\n\n  const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n\n  const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n\n  const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n\n  const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n    const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n    const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n\n    if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {\n      return clientRect;\n    }\n\n    if (newDistance < oldDistance) {\n      return clientRect;\n    }\n\n    return oldClientRect;\n  });\n\n  const getNodeClientRects = node => {\n    const toArrayWithNode = clientRects => {\n      return map$3(clientRects, rect => {\n        const clientRect = clone$1(rect);\n        clientRect.node = node;\n        return clientRect;\n      });\n    };\n\n    if (isElement$6(node)) {\n      return toArrayWithNode(node.getClientRects());\n    } else if (isText$a(node)) {\n      const rng = node.ownerDocument.createRange();\n      rng.setStart(node, 0);\n      rng.setEnd(node, node.data.length);\n      return toArrayWithNode(rng.getClientRects());\n    } else {\n      return [];\n    }\n  };\n\n  const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n  var VDirection;\n\n  (function (VDirection) {\n    VDirection[VDirection['Up'] = -1] = 'Up';\n    VDirection[VDirection['Down'] = 1] = 'Down';\n  })(VDirection || (VDirection = {}));\n\n  const findUntil = (direction, root, predicateFn, node) => {\n    let currentNode = node;\n\n    while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n      if (predicateFn(currentNode)) {\n        return;\n      }\n    }\n  };\n\n  const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n    let line = 0;\n    const result = [];\n\n    const add = node => {\n      let clientRects = getClientRects([node]);\n\n      if (direction === -1) {\n        clientRects = clientRects.reverse();\n      }\n\n      for (let i = 0; i < clientRects.length; i++) {\n        const clientRect = clientRects[i];\n\n        if (isBeflowFn(clientRect, targetClientRect)) {\n          continue;\n        }\n\n        if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n          line++;\n        }\n\n        clientRect.line = line;\n\n        if (predicateFn(clientRect)) {\n          return true;\n        }\n\n        result.push(clientRect);\n      }\n\n      return false;\n    };\n\n    const targetClientRect = last$2(caretPosition.getClientRects());\n\n    if (!targetClientRect) {\n      return result;\n    }\n\n    const node = caretPosition.getNode();\n\n    if (node) {\n      add(node);\n      findUntil(direction, root, add, node);\n    }\n\n    return result;\n  };\n\n  const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n\n  const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n\n  const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n  const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n\n  const getLastClientRect = caretPosition => {\n    return last$2(caretPosition.getClientRects());\n  };\n\n  const positionsUntil = (direction, root, predicateFn, node) => {\n    const caretWalker = CaretWalker(root);\n    let walkFn;\n    let isBelowFn;\n    let isAboveFn;\n    let caretPosition;\n    const result = [];\n    let line = 0;\n\n    if (direction === 1) {\n      walkFn = caretWalker.next;\n      isBelowFn = isBelow$1;\n      isAboveFn = isAbove$1;\n      caretPosition = CaretPosition.after(node);\n    } else {\n      walkFn = caretWalker.prev;\n      isBelowFn = isAbove$1;\n      isAboveFn = isBelow$1;\n      caretPosition = CaretPosition.before(node);\n    }\n\n    const targetClientRect = getLastClientRect(caretPosition);\n\n    do {\n      if (!caretPosition.isVisible()) {\n        continue;\n      }\n\n      const rect = getLastClientRect(caretPosition);\n\n      if (isAboveFn(rect, targetClientRect)) {\n        continue;\n      }\n\n      if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n        line++;\n      }\n\n      const clientRect = clone$1(rect);\n      clientRect.position = caretPosition;\n      clientRect.line = line;\n\n      if (predicateFn(clientRect)) {\n        return result;\n      }\n\n      result.push(clientRect);\n    } while (caretPosition = walkFn(caretPosition));\n\n    return result;\n  };\n\n  const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n\n  const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n  const moveToRange = (editor, rng) => {\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, editor.selection.getRng());\n  };\n\n  const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n\n  const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n    const forwards = direction === HDirection.Forwards;\n    const caretWalker = CaretWalker(editor.getBody());\n    const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n    const isBeforeFn = forwards ? isBefore : isAfter;\n\n    if (!range.collapsed) {\n      const node = getSelectedNode(range);\n\n      if (isElement(node)) {\n        return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n      } else if (isCefAtEdgeSelected(editor)) {\n        const newRange = range.cloneRange();\n        newRange.collapse(direction === HDirection.Backwards);\n        return Optional.from(newRange);\n      }\n    }\n\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n\n    if (isBeforeFn(caretPosition)) {\n      return selectNode(editor, caretPosition.getNode(!forwards));\n    }\n\n    let nextCaretPosition = getNextPosFn(caretPosition);\n    const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n\n    if (!nextCaretPosition) {\n      return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n    } else {\n      nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n    }\n\n    if (isBeforeFn(nextCaretPosition)) {\n      return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n    }\n\n    const peekCaretPosition = getNextPosFn(nextCaretPosition);\n\n    if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n      if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n        return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n      }\n    }\n\n    if (rangeIsInContainerBlock) {\n      return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n    }\n\n    return Optional.none();\n  };\n\n  const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n    const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n    const caretClientRect = last$2(caretPosition.getClientRects());\n    const forwards = direction === VDirection.Down;\n    const root = editor.getBody();\n\n    if (!caretClientRect) {\n      return Optional.none();\n    }\n\n    if (isCefAtEdgeSelected(editor)) {\n      const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n      const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n      return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n    }\n\n    const walkerFn = forwards ? downUntil : upUntil;\n    const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n    const nextLinePositions = filter$5(linePositions, isLine(1));\n    const clientX = caretClientRect.left;\n    const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n\n    if (nextLineRect && isElement(nextLineRect.node)) {\n      const dist1 = Math.abs(clientX - nextLineRect.left);\n      const dist2 = Math.abs(clientX - nextLineRect.right);\n      return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n    }\n\n    let currentNode;\n\n    if (isBefore(caretPosition)) {\n      currentNode = caretPosition.getNode();\n    } else if (isAfter(caretPosition)) {\n      currentNode = caretPosition.getNode(true);\n    } else {\n      currentNode = getSelectedNode(range);\n    }\n\n    if (currentNode) {\n      const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n      let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n\n      if (closestNextLineRect) {\n        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n      }\n\n      closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));\n\n      if (closestNextLineRect) {\n        return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n      }\n    }\n\n    if (nextLinePositions.length === 0) {\n      return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n    }\n\n    return Optional.none();\n  };\n\n  const getLineEndPoint = (editor, forward) => {\n    const rng = editor.selection.getRng();\n    const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n    const host = getEditingHost(from.container(), editor.getBody());\n\n    if (forward) {\n      const lineInfo = getPositionsUntilNextLine(host, from);\n      return last$3(lineInfo.positions);\n    } else {\n      const lineInfo = getPositionsUntilPreviousLine(host, from);\n      return head(lineInfo.positions);\n    }\n  };\n\n  const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n    editor.selection.setRng(pos.toRange());\n    return true;\n  });\n\n  const setCaretPosition = (editor, pos) => {\n    const rng = editor.dom.createRng();\n    rng.setStart(pos.container(), pos.offset());\n    rng.setEnd(pos.container(), pos.offset());\n    editor.selection.setRng(rng);\n  };\n\n  const setSelected = (state, elm) => {\n    if (state) {\n      elm.setAttribute('data-mce-selected', 'inline-boundary');\n    } else {\n      elm.removeAttribute('data-mce-selected');\n    }\n  };\n\n  const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n    setCaretPosition(editor, pos);\n    return location;\n  });\n\n  const getPositionFromRange = (range, root, forward) => {\n    const start = CaretPosition.fromRangeStart(range);\n\n    if (range.collapsed) {\n      return start;\n    } else {\n      const end = CaretPosition.fromRangeEnd(range);\n      return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n    }\n  };\n\n  const findLocation = (editor, caret, forward) => {\n    const rootNode = editor.getBody();\n    const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n    return location.bind(location => renderCaretLocation(editor, caret, location));\n  };\n\n  const toggleInlines = (isInlineTarget, dom, elms) => {\n    const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n    const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n    const targetInlines = filter$5(elms, isInlineTarget);\n    each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n    each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n  };\n\n  const safeRemoveCaretContainer = (editor, caret) => {\n    const caretValue = caret.get();\n\n    if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n\n      if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n        setCaretPosition(editor, removeAndReposition(caretValue, pos));\n        caret.set(null);\n      }\n    }\n  };\n\n  const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n    if (editor.selection.isCollapsed()) {\n      const inlines = filter$5(elms, isInlineTarget);\n      each$e(inlines, _inline => {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n      });\n    }\n  };\n\n  const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n\n  const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n\n  const setupSelectedState = editor => {\n    const caret = Cell(null);\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    editor.on('NodeChange', e => {\n      if (isInlineBoundariesEnabled(editor)) {\n        toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n        safeRemoveCaretContainer(editor, caret);\n        renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n      }\n    });\n    return caret;\n  };\n\n  const moveNextWord = curry(moveWord, true);\n  const movePrevWord = curry(moveWord, false);\n\n  const moveToLineEndPoint$2 = (editor, forward, caret) => {\n    if (isInlineBoundariesEnabled(editor)) {\n      const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n        const rng = editor.selection.getRng();\n        return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      });\n      return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n        const outsideLoc = outside(loc);\n        return renderCaret(caret, outsideLoc).exists(pos => {\n          setCaretPosition(editor, pos);\n          return true;\n        });\n      });\n    } else {\n      return false;\n    }\n  };\n\n  const rangeFromPositions = (from, to) => {\n    const range = document.createRange();\n    range.setStart(from.container(), from.offset());\n    range.setEnd(to.container(), to.offset());\n    return range;\n  };\n\n  const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n    const normalizedFirstPos = normalizePosition(true, firstPos);\n    const normalizedLastPos = normalizePosition(false, lastPos);\n    return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n  }).getOr(true);\n\n  const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n\n  const deleteFromTo = (editor, caret, from, to) => {\n    const rootNode = editor.getBody();\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    editor.undoManager.ignore(() => {\n      editor.selection.setRng(rangeFromPositions(from, to));\n      execNativeDeleteCommand(editor);\n      readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n    });\n    editor.nodeChanged();\n  };\n\n  const rescope = (rootNode, node) => {\n    const parentBlock = getParentBlock$3(node, rootNode);\n    return parentBlock ? parentBlock : rootNode;\n  };\n\n  const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n    const rootNode = rescope(editor.getBody(), from.container());\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n    const location = fromLocation.bind(location => {\n      if (forward) {\n        return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n      } else {\n        return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n      }\n    });\n    return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n      const toPosition = navigate(forward, rootNode, from);\n      const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n      return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n        if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n          return Optional.some(() => {\n            deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n          });\n        } else {\n          return Optional.none();\n        }\n      })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n        return () => {\n          if (forward) {\n            deleteFromTo(editor, caret, from, to);\n          } else {\n            deleteFromTo(editor, caret, to, from);\n          }\n        };\n      })));\n    });\n  };\n\n  const backspaceDelete$4 = (editor, caret, forward) => {\n    if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return backspaceDeleteCollapsed(editor, caret, forward, from);\n    }\n\n    return Optional.none();\n  };\n\n  const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n\n  const getParentsUntil = (editor, pred) => {\n    const rootElm = SugarElement.fromDom(editor.getBody());\n    const startElm = SugarElement.fromDom(editor.selection.getStart());\n    const parents = parentsAndSelf(startElm, rootElm);\n    return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n  };\n\n  const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n\n  const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n\n  const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n\n  const getFormatNodes = (editor, parentInlines) => {\n    const isFormatElement$1 = curry(isFormatElement, editor);\n    return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n  };\n\n  const getFormatNodesAtStart = editor => {\n    const parentInlines = getParentInlines(editor);\n    return getFormatNodes(editor, parentInlines);\n  };\n\n  const deleteLastPosition = (forward, editor, target, parentInlines) => {\n    const formatNodes = getFormatNodes(editor, parentInlines);\n\n    if (formatNodes.length === 0) {\n      deleteElement$2(editor, forward, target);\n    } else {\n      const pos = replaceWithCaretFormat(target.dom, formatNodes);\n      editor.selection.setRng(pos.toRange());\n    }\n  };\n\n  const deleteCaret$1 = (editor, forward) => {\n    const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n    return last$3(parentInlines).bind(target => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n\n      if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n        return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n      } else {\n        return Optional.none();\n      }\n    });\n  };\n\n  const isBrInEmptyElement = (editor, elm) => {\n    const parentElm = elm.parentElement;\n    return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n  };\n\n  const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n\n  const createCaretFormatAtStart = (editor, formatNodes) => {\n    const startElm = editor.selection.getStart();\n    const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n    editor.selection.setRng(pos.toRange());\n  };\n\n  const updateCaretFormat = (editor, updateFormats) => {\n    const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n\n    if (missingFormats.length > 0) {\n      createCaretFormatAtStart(editor, missingFormats);\n    }\n  };\n\n  const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);\n\n  const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n\n  const rangeStartParentIsFormatElement = (editor, rng) => {\n    const startParent = rng.startContainer.parentElement;\n    return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n  };\n\n  const rangeStartAndEndHaveSameParent = rng => {\n    const startParent = rng.startContainer.parentNode;\n    const endParent = rng.endContainer.parentNode;\n    return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n  };\n\n  const rangeEndsAtEndOfEndContainer = rng => {\n    const endContainer = rng.endContainer;\n    return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);\n  };\n\n  const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n\n  const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n\n  const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n\n  const requiresDeleteRangeOverride = editor => {\n    const rng = editor.selection.getRng();\n    return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n  };\n\n  const deleteRange$1 = editor => {\n    if (requiresDeleteRangeOverride(editor)) {\n      const formatNodes = getFormatNodesAtStart(editor);\n      return Optional.some(() => {\n        execNativeDeleteCommand(editor);\n        updateCaretFormat(editor, formatNodes);\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n\n  const hasAncestorInlineCaret = (elm, schema) => ancestor$1(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n\n  const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n\n  const requiresRefreshCaretOverride = editor => {\n    const rng = editor.selection.getRng();\n    return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n  };\n\n  const refreshCaret = editor => {\n    if (requiresRefreshCaretOverride(editor)) {\n      createCaretFormatAtStart(editor, []);\n    }\n\n    return true;\n  };\n\n  const deleteElement = (editor, forward, element) => {\n    if (isNonNullable(element)) {\n      return Optional.some(() => {\n        editor._selectionOverrides.hideFakeCaret();\n\n        deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const deleteCaret = (editor, forward) => {\n    const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n\n    if (isNearMedia(fromPos)) {\n      return deleteElement(editor, forward, fromPos.getNode(!forward));\n    } else {\n      return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n    }\n  };\n\n  const deleteRange = (editor, forward) => {\n    const selectedNode = editor.selection.getNode();\n    return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n  };\n\n  const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n  const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n\n  const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n\n  const getIndentStyleName = (useMargin, element) => {\n    const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n    const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n    return indentStyleName + suffix;\n  };\n\n  const indentElement = (dom, command, useMargin, value, unit, element) => {\n    const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n    const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n\n    if (command === 'outdent') {\n      const styleValue = Math.max(0, parsedValue - value);\n      dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n    } else {\n      const styleValue = parsedValue + value + unit;\n      dom.setStyle(element, indentStyleName, styleValue);\n    }\n  };\n\n  const validateBlocks = (editor, blocks) => forall(blocks, block => {\n    const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n    const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n    const contentEditable = editor.dom.getContentEditable(block.dom);\n    return contentEditable !== 'false' && intentValue > 0;\n  });\n\n  const canOutdent = editor => {\n    const blocks = getBlocksToIndent(editor);\n    return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n  };\n\n  const isListComponent = el => isList(el) || isListItem$1(el);\n\n  const parentIsListComponent = el => parent(el).exists(isListComponent);\n\n  const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n\n  const handle = (editor, command) => {\n    var _a, _b;\n\n    const {\n      dom\n    } = editor;\n    const indentation = getIndentation(editor);\n    const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n    const indentValue = parseIndentValue(indentation);\n    const useMargin = shouldIndentUseMargin(editor);\n    each$e(getBlocksToIndent(editor), block => {\n      indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n    });\n  };\n\n  const indent = editor => handle(editor, 'indent');\n\n  const outdent = editor => handle(editor, 'outdent');\n\n  const backspaceDelete$1 = editor => {\n    if (editor.selection.isCollapsed() && canOutdent(editor)) {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const block = dom.getParent(rng.startContainer, dom.isBlock);\n\n      if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n        return Optional.some(() => outdent(editor));\n      }\n    }\n\n    return Optional.none();\n  };\n\n  const findAction = (editor, caret, forward) => findMap([backspaceDelete$1, backspaceDelete$6, backspaceDelete$7, (editor, forward) => backspaceDelete$4(editor, caret, forward), backspaceDelete$9, backspaceDelete$a, backspaceDelete$5, backspaceDelete$2, backspaceDelete$8, backspaceDelete$3], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n\n  const deleteCommand = (editor, caret) => {\n    const result = findAction(editor, caret, false);\n    result.fold(() => {\n      if (editor.selection.isEditable()) {\n        execNativeDeleteCommand(editor);\n        paddEmptyBody(editor);\n      }\n    }, call);\n  };\n\n  const forwardDeleteCommand = (editor, caret) => {\n    const result = findAction(editor, caret, true);\n    result.fold(() => {\n      if (editor.selection.isEditable()) {\n        execNativeForwardDeleteCommand(editor);\n      }\n    }, call);\n  };\n\n  const setup$q = (editor, caret) => {\n    editor.addCommand('delete', () => {\n      deleteCommand(editor, caret);\n    });\n    editor.addCommand('forwardDelete', () => {\n      forwardDeleteCommand(editor, caret);\n    });\n  };\n\n  const SIGNIFICANT_MOVE = 5;\n  const LONGPRESS_DELAY = 400;\n\n  const getTouch = event => {\n    if (event.touches === undefined || event.touches.length !== 1) {\n      return Optional.none();\n    }\n\n    return Optional.some(event.touches[0]);\n  };\n\n  const isFarEnough = (touch, data) => {\n    const distX = Math.abs(touch.clientX - data.x);\n    const distY = Math.abs(touch.clientY - data.y);\n    return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n  };\n\n  const setup$p = editor => {\n    const startData = value$2();\n    const longpressFired = Cell(false);\n    const debounceLongpress = last$1(e => {\n      editor.dispatch('longpress', { ...e,\n        type: 'longpress'\n      });\n      longpressFired.set(true);\n    }, LONGPRESS_DELAY);\n    editor.on('touchstart', e => {\n      getTouch(e).each(touch => {\n        debounceLongpress.cancel();\n        const data = {\n          x: touch.clientX,\n          y: touch.clientY,\n          target: e.target\n        };\n        debounceLongpress.throttle(e);\n        longpressFired.set(false);\n        startData.set(data);\n      });\n    }, true);\n    editor.on('touchmove', e => {\n      debounceLongpress.cancel();\n      getTouch(e).each(touch => {\n        startData.on(data => {\n          if (isFarEnough(touch, data)) {\n            startData.clear();\n            longpressFired.set(false);\n            editor.dispatch('longpresscancel');\n          }\n        });\n      });\n    }, true);\n    editor.on('touchend touchcancel', e => {\n      debounceLongpress.cancel();\n\n      if (e.type === 'touchcancel') {\n        return;\n      }\n\n      startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n        if (longpressFired.get()) {\n          e.preventDefault();\n        } else {\n          editor.dispatch('tap', { ...e,\n            type: 'tap'\n          });\n        }\n      });\n    }, true);\n  };\n\n  const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n\n  const isValidTarget = (schema, node) => {\n    if (isText$a(node)) {\n      return true;\n    } else if (isElement$6(node)) {\n      return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n    } else {\n      return false;\n    }\n  };\n\n  const hasBlockParent = (blockElements, root, node) => {\n    return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n      return isBlockElement(blockElements, elm.dom);\n    });\n  };\n\n  const shouldRemoveTextNode = (blockElements, node) => {\n    if (isText$a(node)) {\n      if (node.data.length === 0) {\n        return true;\n      } else if (/^\\s+$/.test(node.data)) {\n        return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n      }\n    }\n\n    return false;\n  };\n\n  const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n\n  const addRootBlocks = editor => {\n    const dom = editor.dom,\n          selection = editor.selection;\n    const schema = editor.schema;\n    const blockElements = schema.getBlockElements();\n    const startNode = selection.getStart();\n    const rootNode = editor.getBody();\n    let rootBlockNode;\n    let tempNode;\n    let wrapped = false;\n    const forcedRootBlock = getForcedRootBlock(editor);\n\n    if (!startNode || !isElement$6(startNode)) {\n      return;\n    }\n\n    const rootNodeName = rootNode.nodeName.toLowerCase();\n\n    if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n      return;\n    }\n\n    const rng = selection.getRng();\n    const {\n      startContainer,\n      startOffset,\n      endContainer,\n      endOffset\n    } = rng;\n    const restoreSelection = hasFocus(editor);\n    let node = rootNode.firstChild;\n\n    while (node) {\n      if (isElement$6(node)) {\n        updateElement(schema, node);\n      }\n\n      if (isValidTarget(schema, node)) {\n        if (shouldRemoveTextNode(blockElements, node)) {\n          tempNode = node;\n          node = node.nextSibling;\n          dom.remove(tempNode);\n          continue;\n        }\n\n        if (!rootBlockNode) {\n          rootBlockNode = createRootBlock(editor);\n          rootNode.insertBefore(rootBlockNode, node);\n          wrapped = true;\n        }\n\n        tempNode = node;\n        node = node.nextSibling;\n        rootBlockNode.appendChild(tempNode);\n      } else {\n        rootBlockNode = null;\n        node = node.nextSibling;\n      }\n    }\n\n    if (wrapped && restoreSelection) {\n      rng.setStart(startContainer, startOffset);\n      rng.setEnd(endContainer, endOffset);\n      selection.setRng(rng);\n      editor.nodeChanged();\n    }\n  };\n\n  const insertEmptyLine = (editor, root, insertBlock) => {\n    const block = SugarElement.fromDom(createRootBlock(editor));\n    const br = createPaddingBr();\n    append$1(block, br);\n    insertBlock(root, block);\n    const rng = document.createRange();\n    rng.setStartBefore(br.dom);\n    rng.setEndBefore(br.dom);\n    return rng;\n  };\n\n  const setup$o = editor => {\n    editor.on('NodeChange', curry(addRootBlocks, editor));\n  };\n\n  const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n\n  const replaceMatchWithSpan = (editor, content, cls) => {\n    return function (match) {\n      const args = arguments,\n            index = args[args.length - 2];\n      const prevChar = index > 0 ? content.charAt(index - 1) : '';\n\n      if (prevChar === '\"') {\n        return match;\n      }\n\n      if (prevChar === '>') {\n        const findStartTagIndex = content.lastIndexOf('<', index);\n\n        if (findStartTagIndex !== -1) {\n          const tagHtml = content.substring(findStartTagIndex, index);\n\n          if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n            return match;\n          }\n        }\n      }\n\n      return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n    };\n  };\n\n  const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n    let i = nonEditableRegExps.length,\n        content = e.content;\n\n    if (e.format === 'raw') {\n      return;\n    }\n\n    while (i--) {\n      content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n    }\n\n    e.content = content;\n  };\n\n  const setup$n = editor => {\n    const contentEditableAttrName = 'contenteditable';\n    const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n    const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n    const hasEditClass = hasClass(editClass);\n    const hasNonEditClass = hasClass(nonEditClass);\n    const nonEditableRegExps = getNonEditableRegExps(editor);\n\n    if (nonEditableRegExps.length > 0) {\n      editor.on('BeforeSetContent', e => {\n        convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n      });\n    }\n\n    editor.parser.addAttributeFilter('class', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (hasEditClass(node)) {\n          node.attr(contentEditableAttrName, 'true');\n        } else if (hasNonEditClass(node)) {\n          node.attr(contentEditableAttrName, 'false');\n        }\n      }\n    });\n    editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (!hasEditClass(node) && !hasNonEditClass(node)) {\n          continue;\n        }\n\n        if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n          node.name = '#text';\n          node.type = 3;\n          node.raw = true;\n          node.value = node.attr('data-mce-content');\n        } else {\n          node.attr(contentEditableAttrName, null);\n        }\n      }\n    });\n  };\n\n  const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n\n  const showBlockCaretContainer = (editor, blockCaretContainer) => {\n    if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n      showCaretContainerBlock(blockCaretContainer);\n      editor.selection.setRng(editor.selection.getRng());\n      editor.selection.scrollIntoView(blockCaretContainer);\n    }\n  };\n\n  const handleBlockContainer = (editor, e) => {\n    const blockCaretContainer = findBlockCaretContainer(editor);\n\n    if (!blockCaretContainer) {\n      return;\n    }\n\n    if (e.type === 'compositionstart') {\n      e.preventDefault();\n      e.stopPropagation();\n      showBlockCaretContainer(editor, blockCaretContainer);\n      return;\n    }\n\n    if (hasContent(blockCaretContainer)) {\n      showBlockCaretContainer(editor, blockCaretContainer);\n      editor.undoManager.add();\n    }\n  };\n\n  const setup$m = editor => {\n    editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n  };\n\n  const isContentEditableFalse$3 = isContentEditableFalse$b;\n\n  const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);\n\n  const moveToCeFalseVertically = (direction, editor, range) => {\n    const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n\n    const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n\n    return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);\n  };\n\n  const createTextBlock = editor => {\n    const textBlock = editor.dom.create(getForcedRootBlock(editor));\n    textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n    return textBlock;\n  };\n\n  const exitPreBlock = (editor, direction, range) => {\n    const caretWalker = CaretWalker(editor.getBody());\n    const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n\n    if (range.collapsed) {\n      const pre = editor.dom.getParent(range.startContainer, 'PRE');\n\n      if (!pre) {\n        return;\n      }\n\n      const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n\n      if (!caretPos) {\n        const newBlock = SugarElement.fromDom(createTextBlock(editor));\n\n        if (direction === 1) {\n          after$4(SugarElement.fromDom(pre), newBlock);\n        } else {\n          before$3(SugarElement.fromDom(pre), newBlock);\n        }\n\n        editor.selection.select(newBlock.dom, true);\n        editor.selection.collapse();\n      }\n    }\n  };\n\n  const getHorizontalRange = (editor, forward) => {\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const range = editor.selection.getRng();\n    return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n      exitPreBlock(editor, direction, range);\n      return Optional.none();\n    });\n  };\n\n  const getVerticalRange = (editor, down) => {\n    const direction = down ? 1 : -1;\n    const range = editor.selection.getRng();\n    return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n      exitPreBlock(editor, direction, range);\n      return Optional.none();\n    });\n  };\n\n  const flipDirection = (selection, forward) => {\n    const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n    return isRtl(elm) ? !forward : forward;\n  };\n\n  const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n    moveToRange(editor, newRange);\n    return true;\n  });\n\n  const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n    moveToRange(editor, newRange);\n    return true;\n  });\n\n  const moveToLineEndPoint$1 = (editor, forward) => {\n    const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n    return moveToLineEndPoint$3(editor, forward, isCefPosition);\n  };\n\n  const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n    const rng = pos.toRange();\n    const curRng = editor.selection.getRng();\n\n    if (forward) {\n      rng.setStart(curRng.startContainer, curRng.startOffset);\n    } else {\n      rng.setEnd(curRng.endContainer, curRng.endOffset);\n    }\n\n    return rng;\n  }).exists(rng => {\n    moveToRange(editor, rng);\n    return true;\n  });\n\n  const isTarget = node => contains$2(['figcaption'], name(node));\n\n  const getClosestTargetBlock = (pos, root, schema) => {\n    const isRoot = curry(eq, root);\n    return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n  };\n\n  const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n\n  const moveCaretToNewEmptyLine = (editor, forward) => {\n    const root = SugarElement.fromDom(editor.getBody());\n    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n      if (isAtFirstOrLastLine(root, forward, pos)) {\n        const insertFn = forward ? append$1 : prepend;\n        const rng = insertEmptyLine(editor, root, insertFn);\n        editor.selection.setRng(rng);\n        return true;\n      } else {\n        return false;\n      }\n    });\n  };\n\n  const moveV$3 = (editor, forward) => {\n    if (editor.selection.isCollapsed()) {\n      return moveCaretToNewEmptyLine(editor, forward);\n    } else {\n      return false;\n    }\n  };\n\n  const moveUp = (editor, details, summary) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n\n    if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n      editor.execCommand('InsertNewBlockBefore');\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const moveDown = (editor, details) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n\n    if (root.lastChild === details && isAtLastLine(details, pos)) {\n      editor.execCommand('InsertNewBlockAfter');\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const move$2 = (editor, forward) => {\n    if (forward) {\n      return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n    } else {\n      return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n    }\n  };\n\n  const moveV$2 = (editor, forward) => move$2(editor, forward);\n\n  const baseKeyPattern = {\n    shiftKey: false,\n    altKey: false,\n    ctrlKey: false,\n    metaKey: false,\n    keyCode: 0\n  };\n\n  const defaultPatterns = patterns => map$3(patterns, pattern => ({ ...baseKeyPattern,\n    ...pattern\n  }));\n\n  const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({ ...baseKeyPattern,\n    ...pattern\n  }));\n\n  const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n\n  const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n\n  const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n\n  const action = (f, ...x) => () => f.apply(null, x);\n\n  const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n\n  const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n  const moveH$1 = (editor, forward) => {\n    const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n    const range = editor.selection.getRng();\n    return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n  };\n\n  const moveV$1 = (editor, down) => {\n    const direction = down ? 1 : -1;\n    const range = editor.selection.getRng();\n    return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n  };\n\n  const moveToLineEndPoint = (editor, forward) => {\n    const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n    return moveToLineEndPoint$3(editor, forward, isNearMedia);\n  };\n\n  const adt = Adt.generate([{\n    none: ['current']\n  }, {\n    first: ['current']\n  }, {\n    middle: ['current', 'target']\n  }, {\n    last: ['current']\n  }]);\n\n  const none = current => adt.none(current);\n\n  const CellLocation = { ...adt,\n    none\n  };\n\n  const firstLayer = (scope, selector) => {\n    return filterFirstLayer(scope, selector, always);\n  };\n\n  const filterFirstLayer = (scope, selector, predicate) => {\n    return bind$3(children$1(scope), x => {\n      if (is$1(x, selector)) {\n        return predicate(x) ? [x] : [];\n      } else {\n        return filterFirstLayer(x, selector, predicate);\n      }\n    });\n  };\n\n  const lookup$1 = (tags, element, isRoot = never) => {\n    if (isRoot(element)) {\n      return Optional.none();\n    }\n\n    if (contains$2(tags, name(element))) {\n      return Optional.some(element);\n    }\n\n    const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n\n    return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n  };\n\n  const cell = (element, isRoot) => lookup$1(['td', 'th'], element, isRoot);\n\n  const cells = ancestor => firstLayer(ancestor, 'th,td');\n\n  const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n  const walk = (all, current, index, direction, isEligible = always) => {\n    const forwards = direction === 1;\n\n    if (!forwards && index <= 0) {\n      return CellLocation.first(all[0]);\n    } else if (forwards && index >= all.length - 1) {\n      return CellLocation.last(all[all.length - 1]);\n    } else {\n      const newIndex = index + direction;\n      const elem = all[newIndex];\n      return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n    }\n  };\n\n  const detect = (current, isRoot) => {\n    return table(current, isRoot).bind(table => {\n      const all = cells(table);\n      const index = findIndex$2(all, x => eq(current, x));\n      return index.map(index => ({\n        index,\n        all\n      }));\n    });\n  };\n\n  const next = (current, isEligible, isRoot) => {\n    const detection = detect(current, isRoot);\n    return detection.fold(() => {\n      return CellLocation.none(current);\n    }, info => {\n      return walk(info.all, current, info.index, 1, isEligible);\n    });\n  };\n\n  const prev = (current, isEligible, isRoot) => {\n    const detection = detect(current, isRoot);\n    return detection.fold(() => {\n      return CellLocation.none();\n    }, info => {\n      return walk(info.all, current, info.index, -1, isEligible);\n    });\n  };\n\n  const deflate = (rect, delta) => ({\n    left: rect.left - delta,\n    top: rect.top - delta,\n    right: rect.right + delta * 2,\n    bottom: rect.bottom + delta * 2,\n    width: rect.width + delta,\n    height: rect.height + delta\n  });\n\n  const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n    const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n    return [{\n      x: rect.left,\n      y: getYAxisValue(rect),\n      cell: td\n    }, {\n      x: rect.right,\n      y: getYAxisValue(rect),\n      cell: td\n    }];\n  });\n\n  const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n    const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n    const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n    return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n  }), Optional.none());\n\n  const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n    const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n    const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n    return findClosestCorner(corners, x, y).map(corner => corner.cell);\n  };\n\n  const getBottomValue = rect => rect.bottom;\n\n  const getTopValue = rect => rect.top;\n\n  const isAbove = (corner, y) => corner.y < y;\n\n  const isBelow = (corner, y) => corner.y > y;\n\n  const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n  const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n\n  const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n\n  const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n  const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n\n  const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n\n  const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n\n  const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n    const lineInfo = getPositionsUntil(scope, pos);\n\n    if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n      return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n    } else {\n      return lineInfo.breakAt.isNone();\n    }\n  };\n\n  const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n  const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n\n  const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n    const caretPos = CaretPosition.fromRangeStart(rng);\n    return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n  };\n\n  const navigateHorizontally = (editor, forward, table, _td) => {\n    const rng = editor.selection.getRng();\n    const direction = forward ? 1 : -1;\n\n    if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n      showCaret(direction, editor, table, !forward, false).each(newRng => {\n        moveToRange(editor, newRng);\n      });\n      return true;\n    }\n\n    return false;\n  };\n\n  const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n\n  const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n\n  const getTable = (previous, pos) => {\n    const node = pos.getNode(previous);\n    return isTable$2(node) ? Optional.some(node) : Optional.none();\n  };\n\n  const renderBlock = (down, editor, table) => {\n    editor.undoManager.transact(() => {\n      const insertFn = down ? after$4 : before$3;\n      const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n      moveToRange(editor, rng);\n    });\n  };\n\n  const moveCaret = (editor, down, pos) => {\n    const table = down ? getTable(true, pos) : getTable(false, pos);\n    const last = down === false;\n    table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n  };\n\n  const navigateVertically = (editor, down, table, td) => {\n    const rng = editor.selection.getRng();\n    const pos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n\n    if (!down && isAtFirstTableCellLine(td, pos)) {\n      const newPos = getClosestAbovePosition(root, table, pos);\n      moveCaret(editor, down, newPos);\n      return true;\n    } else if (down && isAtLastTableCellLine(td, pos)) {\n      const newPos = getClosestBelowPosition(root, table, pos);\n      moveCaret(editor, down, newPos);\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n\n  const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n\n  const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n\n  const getCellFirstCursorPosition = cell => {\n    const selection = SimSelection.exact(cell, 0, cell, 0);\n    return toNative(selection);\n  };\n\n  const tabGo = (editor, isRoot, cell) => {\n    return cell.fold(Optional.none, Optional.none, (_current, next) => {\n      return first(next).map(cell => {\n        return getCellFirstCursorPosition(cell);\n      });\n    }, current => {\n      editor.execCommand('mceTableInsertRowAfter');\n      return tabForward(editor, isRoot, current);\n    });\n  };\n\n  const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n\n  const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n\n  const handleTab = (editor, forward) => {\n    const rootElements = ['table', 'li', 'dl'];\n    const body = SugarElement.fromDom(editor.getBody());\n\n    const isRoot = element => {\n      const name$1 = name(element);\n      return eq(element, body) || contains$2(rootElements, name$1);\n    };\n\n    const rng = editor.selection.getRng();\n    const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n    return cell(container, isRoot).map(cell => {\n      table(cell, isRoot).each(table => {\n        editor.model.table.clearSelectedCells(table.dom);\n      });\n      editor.selection.collapse(!forward);\n      const navigation = !forward ? tabBackward : tabForward;\n      const rng = navigation(editor, isRoot, cell);\n      rng.each(range => {\n        editor.selection.setRng(range);\n      });\n      return true;\n    }).getOr(false);\n  };\n\n  const executeKeydownOverride$4 = (editor, caret, evt) => {\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    execute([{\n      keyCode: VK.RIGHT,\n      action: action(moveH$2, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH$2, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$4, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$4, editor, true)\n    }, ...(isMac ? [{\n      keyCode: VK.UP,\n      action: action(selectToEndPoint, editor, false),\n      metaKey: true,\n      shiftKey: true\n    }, {\n      keyCode: VK.DOWN,\n      action: action(selectToEndPoint, editor, true),\n      metaKey: true,\n      shiftKey: true\n    }] : []), {\n      keyCode: VK.RIGHT,\n      action: action(moveH, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV, editor, true)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$2, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$2, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(moveH$1, editor, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(moveH$1, editor, false)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$1, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$1, editor, true)\n    }, {\n      keyCode: VK.RIGHT,\n      action: action(move$3, editor, caret, true)\n    }, {\n      keyCode: VK.LEFT,\n      action: action(move$3, editor, caret, false)\n    }, {\n      keyCode: VK.RIGHT,\n      ctrlKey: !isMac,\n      altKey: isMac,\n      action: action(moveNextWord, editor, caret)\n    }, {\n      keyCode: VK.LEFT,\n      ctrlKey: !isMac,\n      altKey: isMac,\n      action: action(movePrevWord, editor, caret)\n    }, {\n      keyCode: VK.UP,\n      action: action(moveV$3, editor, false)\n    }, {\n      keyCode: VK.DOWN,\n      action: action(moveV$3, editor, true)\n    }], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n\n  const setup$l = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$4(editor, caret, evt);\n      }\n    });\n  };\n\n  const point = (container, offset) => ({\n    container,\n    offset\n  });\n\n  const DOM$7 = DOMUtils.DOM;\n\n  const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n\n  const isBoundary = dom => node => dom.isBlock(node) || contains$2(['BR', 'IMG', 'HR', 'INPUT'], node.nodeName) || dom.getContentEditable(node) === 'false';\n\n  const textBefore = (node, offset, rootNode) => {\n    if (isText$a(node) && offset >= 0) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n    }\n  };\n\n  const textAfter = (node, offset, rootNode) => {\n    if (isText$a(node) && offset >= node.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n    }\n  };\n\n  const scanLeft = (node, offset, rootNode) => {\n    if (!isText$a(node)) {\n      return Optional.none();\n    }\n\n    const text = node.data;\n\n    if (offset >= 0 && offset <= text.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n        const prevText = prev.container.data;\n        return scanLeft(prev.container, offset + prevText.length, rootNode);\n      });\n    }\n  };\n\n  const scanRight = (node, offset, rootNode) => {\n    if (!isText$a(node)) {\n      return Optional.none();\n    }\n\n    const text = node.data;\n\n    if (offset <= text.length) {\n      return Optional.some(point(node, offset));\n    } else {\n      const textSeeker = TextSeeker(DOM$7);\n      return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n    }\n  };\n\n  const repeatLeft = (dom, node, offset, process, rootNode) => {\n    const search = TextSeeker(dom, isBoundary(dom));\n    return Optional.from(search.backwards(node, offset, process, rootNode));\n  };\n\n  const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);\n\n  const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n\n  const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n  const stripTrigger = (text, trigger) => text.substring(trigger.length);\n\n  const findTrigger = (text, index, trigger) => {\n    let i;\n    const firstChar = trigger.charAt(0);\n\n    for (i = index - 1; i >= 0; i--) {\n      const char = text.charAt(i);\n\n      if (isWhitespace(char)) {\n        return Optional.none();\n      }\n\n      if (firstChar === char && contains$1(text, trigger, i, index)) {\n        break;\n      }\n    }\n\n    return Optional.some(i);\n  };\n\n  const findStart = (dom, initRange, trigger, minChars = 0) => {\n    if (!isValidTextRange(initRange)) {\n      return Optional.none();\n    }\n\n    const buffer = {\n      text: '',\n      offset: 0\n    };\n\n    const findTriggerIndex = (element, offset, text) => {\n      buffer.text = text + buffer.text;\n      buffer.offset += offset;\n      return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);\n    };\n\n    const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n    return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n      const range = initRange.cloneRange();\n      range.setStart(spot.container, spot.offset);\n      range.setEnd(initRange.endContainer, initRange.endOffset);\n\n      if (range.collapsed) {\n        return Optional.none();\n      }\n\n      const text = getText(range);\n      const triggerIndex = text.lastIndexOf(trigger);\n\n      if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {\n        return Optional.none();\n      } else {\n        return Optional.some({\n          text: stripTrigger(text, trigger),\n          range,\n          trigger\n        });\n      }\n    });\n  };\n\n  const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {\n    const range = dom.createRng();\n    range.selectNode(elm.dom);\n    const text = getText(range);\n    return Optional.some({\n      range,\n      text: stripTrigger(text, trigger),\n      trigger\n    });\n  });\n\n  const isText$1 = node => node.nodeType === TEXT;\n\n  const isElement = node => node.nodeType === ELEMENT;\n\n  const toLast = node => {\n    if (isText$1(node)) {\n      return point(node, node.data.length);\n    } else {\n      const children = node.childNodes;\n      return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n    }\n  };\n\n  const toLeaf = (node, offset) => {\n    const children = node.childNodes;\n\n    if (children.length > 0 && offset < children.length) {\n      return toLeaf(children[offset], 0);\n    } else if (children.length > 0 && isElement(node) && children.length === offset) {\n      return toLast(children[children.length - 1]);\n    } else {\n      return point(node, offset);\n    }\n  };\n\n  const isPreviousCharContent = (dom, leaf) => {\n    var _a;\n\n    const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n    return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n      const char = spot.container.data.charAt(spot.offset - 1);\n      return !isWhitespace(char);\n    }).isSome();\n  };\n\n  const isStartOfWord = dom => rng => {\n    const leaf = toLeaf(rng.startContainer, rng.startOffset);\n    return !isPreviousCharContent(dom, leaf);\n  };\n\n  const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n\n  const lookup = (editor, getDatabase) => {\n    const database = getDatabase();\n    const rng = editor.selection.getRng();\n    return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n  };\n\n  const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n    var _a;\n\n    const database = getDatabase();\n    const rng = editor.selection.getRng();\n    const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n    const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n\n    if (autocompleters.length === 0) {\n      return Optional.none();\n    }\n\n    const lookupData = Promise.all(map$3(autocompleters, ac => {\n      const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n      return fetchResult.then(results => ({\n        matchText: context.text,\n        items: results,\n        columns: ac.columns,\n        onAction: ac.onAction,\n        highlightOn: ac.highlightOn\n      }));\n    }));\n    return Optional.some({\n      lookupData,\n      context\n    });\n  };\n\n  var SimpleResultType;\n\n  (function (SimpleResultType) {\n    SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n    SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n  })(SimpleResultType || (SimpleResultType = {}));\n\n  const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n\n  const partition = results => {\n    const values = [];\n    const errors = [];\n    each$e(results, obj => {\n      fold$1(obj, err => errors.push(err), val => values.push(val));\n    });\n    return {\n      values,\n      errors\n    };\n  };\n\n  const mapError = (res, f) => {\n    if (res.stype === SimpleResultType.Error) {\n      return {\n        stype: SimpleResultType.Error,\n        serror: f(res.serror)\n      };\n    } else {\n      return res;\n    }\n  };\n\n  const map = (res, f) => {\n    if (res.stype === SimpleResultType.Value) {\n      return {\n        stype: SimpleResultType.Value,\n        svalue: f(res.svalue)\n      };\n    } else {\n      return res;\n    }\n  };\n\n  const bind$1 = (res, f) => {\n    if (res.stype === SimpleResultType.Value) {\n      return f(res.svalue);\n    } else {\n      return res;\n    }\n  };\n\n  const bindError = (res, f) => {\n    if (res.stype === SimpleResultType.Error) {\n      return f(res.serror);\n    } else {\n      return res;\n    }\n  };\n\n  const svalue = v => ({\n    stype: SimpleResultType.Value,\n    svalue: v\n  });\n\n  const serror = e => ({\n    stype: SimpleResultType.Error,\n    serror: e\n  });\n\n  const toResult = res => fold$1(res, Result.error, Result.value);\n\n  const fromResult = res => res.fold(serror, svalue);\n\n  const SimpleResult = {\n    fromResult,\n    toResult,\n    svalue,\n    partition,\n    serror,\n    bind: bind$1,\n    bindError,\n    map,\n    mapError,\n    fold: fold$1\n  };\n\n  const formatObj = input => {\n    return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n  };\n\n  const formatErrors = errors => {\n    const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n      path: [],\n      getErrorInfo: constant('... (only showing first ten failures)')\n    }]) : errors;\n    return map$3(es, e => {\n      return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n    });\n  };\n\n  const nu = (path, getErrorInfo) => {\n    return SimpleResult.serror([{\n      path,\n      getErrorInfo\n    }]);\n  };\n\n  const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n\n  const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n\n  const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n\n  const custom = (path, err) => nu(path, constant(err));\n\n  const chooseFrom = (path, input, branches, ch) => {\n    const fields = get$a(branches, ch);\n    return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n  };\n\n  const choose$1 = (key, branches) => {\n    const extract = (path, input) => {\n      const choice = get$a(input, key);\n      return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n    };\n\n    const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const shallow = (old, nu) => {\n    return nu;\n  };\n\n  const deep = (old, nu) => {\n    const bothObjects = isPlainObject(old) && isPlainObject(nu);\n    return bothObjects ? deepMerge(old, nu) : nu;\n  };\n\n  const baseMerge = merger => {\n    return (...objects) => {\n      if (objects.length === 0) {\n        throw new Error(`Can't merge zero objects`);\n      }\n\n      const ret = {};\n\n      for (let j = 0; j < objects.length; j++) {\n        const curObject = objects[j];\n\n        for (const key in curObject) {\n          if (has$2(curObject, key)) {\n            ret[key] = merger(ret[key], curObject[key]);\n          }\n        }\n      }\n\n      return ret;\n    };\n  };\n\n  const deepMerge = baseMerge(deep);\n  const merge = baseMerge(shallow);\n\n  const required = () => ({\n    tag: 'required',\n    process: {}\n  });\n\n  const defaultedThunk = fallbackThunk => ({\n    tag: 'defaultedThunk',\n    process: fallbackThunk\n  });\n\n  const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n\n  const asOption = () => ({\n    tag: 'option',\n    process: {}\n  });\n\n  const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n\n  const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n\n  const consolidateObj = (objects, base) => {\n    const partition = SimpleResult.partition(objects);\n    return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n  };\n\n  const consolidateArr = objects => {\n    const partitions = SimpleResult.partition(objects);\n    return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n  };\n\n  const ResultCombine = {\n    consolidateObj,\n    consolidateArr\n  };\n\n  const field$1 = (key, newKey, presence, prop) => ({\n    tag: 'field',\n    key,\n    newKey,\n    presence,\n    prop\n  });\n\n  const customField$1 = (newKey, instantiator) => ({\n    tag: 'custom',\n    newKey,\n    instantiator\n  });\n\n  const fold = (value, ifField, ifCustom) => {\n    switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n    }\n  };\n\n  const value = validator => {\n    const extract = (path, val) => {\n      return SimpleResult.bindError(validator(val), err => custom(path, err));\n    };\n\n    const toString = constant('val');\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const anyValue$1 = value(SimpleResult.svalue);\n\n  const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n\n  const fallbackAccess = (obj, key, fallback, bundle) => {\n    const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n    return bundle(v);\n  };\n\n  const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n\n  const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n    const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n    return bundle(opt);\n  };\n\n  const extractField = (field, path, obj, key, prop) => {\n    const bundle = av => prop.extract(path.concat([key]), av);\n\n    const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n      const result = prop.extract(path.concat([key]), ov);\n      return SimpleResult.map(result, Optional.some);\n    });\n\n    switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n\n      case 'mergeWithThunk':\n        {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n    }\n  };\n\n  const extractFields = (path, obj, fields) => {\n    const success = {};\n    const errors = [];\n\n    for (const field of fields) {\n      fold(field, (key, newKey, presence, prop) => {\n        const result = extractField(presence, path, obj, key, prop);\n        SimpleResult.fold(result, err => {\n          errors.push(...err);\n        }, res => {\n          success[newKey] = res;\n        });\n      }, (newKey, instantiator) => {\n        success[newKey] = instantiator(obj);\n      });\n    }\n\n    return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n  };\n\n  const objOf = values => {\n    const extract = (path, o) => extractFields(path, o, values);\n\n    const toString = () => {\n      const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n      return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n    };\n\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const arrOf = prop => {\n    const extract = (path, array) => {\n      const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n      return ResultCombine.consolidateArr(results);\n    };\n\n    const toString = () => 'array(' + prop.toString() + ')';\n\n    return {\n      extract,\n      toString\n    };\n  };\n\n  const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n\n  const extractValue = (label, prop, obj) => {\n    const res = prop.extract([label], obj);\n    return SimpleResult.mapError(res, errs => ({\n      input: obj,\n      errors: errs\n    }));\n  };\n\n  const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n\n  const formatError = errInfo => {\n    return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n  };\n\n  const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n  const anyValue = constant(anyValue$1);\n\n  const typedValue = (validator, expectedType) => value(a => {\n    const actualType = typeof a;\n    return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${expectedType} but got: ${actualType}`);\n  });\n\n  const number = typedValue(isNumber, 'number');\n  const string = typedValue(isString, 'string');\n  const boolean = typedValue(isBoolean, 'boolean');\n  const functionProcessor = typedValue(isFunction, 'function');\n  const field = field$1;\n  const customField = customField$1;\n\n  const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${value}\", choose one of \"${values.join(', ')}\".`));\n\n  const requiredOf = (key, schema) => field(key, key, required(), schema);\n\n  const requiredString = key => requiredOf(key, string);\n\n  const requiredFunction = key => requiredOf(key, functionProcessor);\n\n  const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n\n  const optionOf = (key, schema) => field(key, key, asOption(), schema);\n\n  const optionString = key => optionOf(key, string);\n\n  const optionFunction = key => optionOf(key, functionProcessor);\n\n  const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n\n  const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n\n  const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n\n  const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n\n  const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n\n  const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n\n  const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n\n  const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n  const type = requiredString('type');\n  const fetch$1 = requiredFunction('fetch');\n  const onAction = requiredFunction('onAction');\n  const onSetup = defaultedFunction('onSetup', () => noop);\n  const optionalText = optionString('text');\n  const optionalIcon = optionString('icon');\n  const optionalTooltip = optionString('tooltip');\n  const optionalLabel = optionString('label');\n  const active = defaultedBoolean('active', false);\n  const enabled = defaultedBoolean('enabled', true);\n  const primary = defaultedBoolean('primary', false);\n\n  const defaultedColumns = num => defaulted('columns', num);\n\n  const defaultedType = type => defaultedString('type', type);\n\n  const autocompleterSchema = objOf([type, requiredString('trigger'), defaultedNumber('minChars', 1), defaultedColumns(1), defaultedNumber('maxResults', 10), optionFunction('matches'), fetch$1, onAction, defaultedArrayOf('highlightOn', [], string)]);\n\n  const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {\n    trigger: spec.ch,\n    ...spec\n  });\n\n  const baseToolbarButtonFields = [enabled, optionalTooltip, optionalIcon, optionalText, onSetup];\n  const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n  const contextBarFields = [defaultedFunction('predicate', never), defaultedStringEnum('scope', 'node', ['node', 'editor']), defaultedStringEnum('position', 'selection', ['node', 'selection', 'line'])];\n  const contextButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformbutton'), primary, onAction, customField('original', identity)]);\n  const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n  const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n  const toggleOrNormal = choose('type', {\n    contextformbutton: contextButtonFields,\n    contextformtogglebutton: contextToggleButtonFields\n  });\n  objOf([defaultedType('contextform'), defaultedFunction('initValue', constant('')), optionalLabel, requiredArrayOf('commands', toggleOrNormal), optionOf('launch', choose('type', {\n    contextformbutton: launchButtonFields,\n    contextformtogglebutton: launchToggleButtonFields\n  }))].concat(contextBarFields));\n\n  const register$2 = editor => {\n    const popups = editor.ui.registry.getAll().popups;\n    const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n      throw new Error(formatError(err));\n    }, identity));\n    const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n    const datasetValues = values(dataset);\n\n    const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n\n    return {\n      dataset,\n      triggers,\n      lookupByTrigger\n    };\n  };\n\n  const setupEditorInput = (editor, api) => {\n    const update = last$1(api.load, 50);\n    editor.on('keypress compositionend', e => {\n      if (e.which === 27) {\n        return;\n      }\n\n      update.throttle();\n    });\n    editor.on('keydown', e => {\n      const keyCode = e.which;\n\n      if (keyCode === 8) {\n        update.throttle();\n      } else if (keyCode === 27) {\n        api.cancelIfNecessary();\n      }\n    });\n    editor.on('remove', update.cancel);\n  };\n\n  const setup$k = editor => {\n    const activeAutocompleter = value$2();\n    const uiActive = Cell(false);\n    const isActive = activeAutocompleter.isSet;\n\n    const cancelIfNecessary = () => {\n      if (isActive()) {\n        removeAutocompleterDecoration(editor);\n        fireAutocompleterEnd(editor);\n        uiActive.set(false);\n        activeAutocompleter.clear();\n      }\n    };\n\n    const commenceIfNecessary = context => {\n      if (!isActive()) {\n        addAutocompleterDecoration(editor, context.range);\n        activeAutocompleter.set({\n          trigger: context.trigger,\n          matchLength: context.text.length\n        });\n      }\n    };\n\n    const getAutocompleters = cached(() => register$2(editor));\n\n    const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n\n    const load = fetchOptions => {\n      doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n        commenceIfNecessary(lookupInfo.context);\n        lookupInfo.lookupData.then(lookupData => {\n          activeAutocompleter.get().map(ac => {\n            const context = lookupInfo.context;\n\n            if (ac.trigger === context.trigger) {\n              if (context.text.length - ac.matchLength >= 10) {\n                cancelIfNecessary();\n              } else {\n                activeAutocompleter.set({ ...ac,\n                  matchLength: context.text.length\n                });\n\n                if (uiActive.get()) {\n                  fireAutocompleterUpdate(editor, {\n                    lookupData\n                  });\n                } else {\n                  uiActive.set(true);\n                  fireAutocompleterStart(editor, {\n                    lookupData\n                  });\n                }\n              }\n            }\n          });\n        });\n      });\n    };\n\n    editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n      const fetchOptions = isObject(value) ? value.fetchOptions : {};\n      load(fetchOptions);\n    });\n    editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n    setupEditorInput(editor, {\n      cancelIfNecessary,\n      load\n    });\n  };\n\n  const browser$1 = detect$2().browser;\n  const isSafari = browser$1.isSafari();\n\n  const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n\n  const isEntireNodeSelected = (rng, node) => {\n    var _a;\n\n    return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n  };\n\n  const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n\n  const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n\n  const getDetailsElements = (dom, rng) => {\n    const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n    const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n\n    if (startDetails.isSome() || endDetails.isSome()) {\n      const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n      return Optional.some({\n        startSummary,\n        startDetails,\n        endDetails\n      });\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n\n  const isCaretInTheEndOf = (caretPos, element) => {\n    return lastPositionIn(element).exists(pos => {\n      if (isBr$6(pos.getNode())) {\n        return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n      } else {\n        return pos.isEqual(caretPos);\n      }\n    });\n  };\n\n  const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n\n  const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n\n  const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n\n  const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n\n  const setCaretToPosition = (editor, position) => {\n    const node = position.getNode();\n\n    if (!isUndefined(node)) {\n      editor.selection.setCursorLocation(node, position.offset());\n    }\n  };\n\n  const moveCaretToDetailsPos = (editor, pos, forward) => {\n    const details = editor.dom.getParent(pos.container(), 'details');\n\n    if (details && !details.open) {\n      const summary = editor.dom.select('summary', details)[0];\n\n      if (summary) {\n        const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n        newPos.each(pos => setCaretToPosition(editor, pos));\n      }\n    } else {\n      setCaretToPosition(editor, pos);\n    }\n  };\n\n  const isPartialDelete = (rng, detailsElements) => {\n    const containsStart = element => element.contains(rng.startContainer);\n\n    const containsEnd = element => element.contains(rng.endContainer);\n\n    const startInSummary = detailsElements.startSummary.exists(containsStart);\n    const endInSummary = detailsElements.startSummary.exists(containsEnd);\n    const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n    const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n    return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n  };\n\n  const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const root = editor.getBody();\n\n    if (granularity === 'character') {\n      const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n      const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n      const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n      const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n      const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n      const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n\n      if (inEmptyParentBlock) {\n        const firstOrLast = forward ? isLastBlock : isFirstBlock;\n\n        if (firstOrLast) {\n          const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n            return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n          });\n\n          if (isBeforeAfterDetails) {\n            return true;\n          }\n        }\n      }\n\n      return navigate(forward, root, caretPos).fold(never, pos => {\n        const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n\n        if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n          if (!forward) {\n            moveCaretToDetailsPos(editor, pos, false);\n          }\n\n          if (parentBlock && inEmptyParentBlock) {\n            if (forward && isFirstBlock) {\n              return true;\n            } else if (!forward && isLastBlock) {\n              return true;\n            }\n\n            moveCaretToDetailsPos(editor, pos, forward);\n            editor.dom.remove(parentBlock);\n          }\n\n          return true;\n        } else {\n          return false;\n        }\n      });\n    } else {\n      return false;\n    }\n  };\n\n  const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n    const selection = editor.selection;\n    const rng = selection.getRng();\n    const caretPos = CaretPosition.fromRangeStart(rng);\n    const root = editor.getBody();\n\n    if (granularity === 'selection') {\n      return isPartialDelete(rng, detailElements);\n    } else if (forward) {\n      return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n    } else {\n      return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n    }\n  };\n\n  const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n\n  const handleDeleteActionSafari = (editor, forward, granularity) => {\n    const selection = editor.selection;\n    const node = selection.getNode();\n    const rng = selection.getRng();\n    const caretPos = CaretPosition.fromRangeStart(rng);\n\n    if (isSummary$1(node)) {\n      if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n        emptyNodeContents(node);\n      } else {\n        editor.undoManager.transact(() => {\n          const sel = selection.getSel();\n          let {\n            anchorNode,\n            anchorOffset,\n            focusNode,\n            focusOffset\n          } = sel !== null && sel !== void 0 ? sel : {};\n\n          const applySelection = () => {\n            if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n              sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n            }\n          };\n\n          const updateSelection = () => {\n            anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n            anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n            focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n            focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n          };\n\n          const appendAllChildNodes = (from, to) => {\n            each$e(from.childNodes, child => {\n              if (isNode(child)) {\n                to.appendChild(child);\n              }\n            });\n          };\n\n          const container = editor.dom.create('span', {\n            'data-mce-bogus': '1'\n          });\n          appendAllChildNodes(node, container);\n          node.appendChild(container);\n          applySelection();\n\n          if (granularity === 'word' || granularity === 'line') {\n            sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n          }\n\n          if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n            emptyNodeContents(node);\n          } else {\n            editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n            updateSelection();\n            appendAllChildNodes(container, node);\n            applySelection();\n          }\n\n          editor.dom.remove(container);\n        });\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n\n  const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n    const target = editor.getBody();\n    const overrides = {\n      bubbles: true,\n      composed: true,\n      data: null,\n      isComposing: false,\n      detail: 0,\n      view: null,\n      target,\n      currentTarget: target,\n      eventPhase: Event.AT_TARGET,\n      originalTarget: target,\n      explicitOriginalTarget: target,\n      isTrusted: false,\n      srcElement: target,\n      cancelable: false,\n      preventDefault: noop,\n      inputType\n    };\n    const input = clone$3(new InputEvent(eventType));\n    return editor.dispatch(eventType, { ...input,\n      ...overrides,\n      ...specifics\n    });\n  };\n\n  const fireInputEvent = createAndFireInputEvent('input');\n  const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n  const platform$2 = detect$2();\n  const os = platform$2.os;\n  const isMacOSOriOS = os.isMacOS() || os.isiOS();\n  const browser = platform$2.browser;\n  const isFirefox = browser.isFirefox();\n\n  const executeKeydownOverride$3 = (editor, caret, evt) => {\n    const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n    const isCollapsed = editor.selection.isCollapsed();\n    const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n\n    const getModifiedGranularity = isWord => {\n      if (isCollapsed) {\n        return isWord ? 'word' : 'line';\n      } else {\n        return 'selection';\n      }\n    };\n\n    executeWithDelayedAction([{\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$1, editor)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$6, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$6, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$7, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$7, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$4, editor, caret, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$4, editor, caret, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$a, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$a, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n    }, ...(isMacOSOriOS ? [{\n      keyCode: VK.BACKSPACE,\n      altKey: true,\n      action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n    }, {\n      keyCode: VK.DELETE,\n      altKey: true,\n      action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n    }, {\n      keyCode: VK.BACKSPACE,\n      metaKey: true,\n      action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n    }] : [{\n      keyCode: VK.BACKSPACE,\n      ctrlKey: true,\n      action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n    }, {\n      keyCode: VK.DELETE,\n      ctrlKey: true,\n      action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n    }]), {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$5, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$5, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$2, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$2, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$8, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$8, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$9, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$9, editor, true)\n    }, {\n      keyCode: VK.BACKSPACE,\n      action: action(backspaceDelete$3, editor, false)\n    }, {\n      keyCode: VK.DELETE,\n      action: action(backspaceDelete$3, editor, true)\n    }], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n      evt.preventDefault();\n      const beforeInput = fireBeforeInputEvent(editor, inputType);\n\n      if (!beforeInput.isDefaultPrevented()) {\n        applyAction();\n        fireInputEvent(editor, inputType);\n      }\n    });\n  };\n\n  const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([{\n    keyCode: VK.BACKSPACE,\n    action: action(paddEmptyElement, editor)\n  }, {\n    keyCode: VK.DELETE,\n    action: action(paddEmptyElement, editor)\n  }, ...(isMacOSOriOS ? [{\n    keyCode: VK.BACKSPACE,\n    altKey: true,\n    action: action(refreshCaret, editor)\n  }, {\n    keyCode: VK.DELETE,\n    altKey: true,\n    action: action(refreshCaret, editor)\n  }, ...(isBackspaceKeydown ? [{\n    keyCode: isFirefox ? 224 : 91,\n    action: action(refreshCaret, editor)\n  }] : [])] : [{\n    keyCode: VK.BACKSPACE,\n    ctrlKey: true,\n    action: action(refreshCaret, editor)\n  }, {\n    keyCode: VK.DELETE,\n    ctrlKey: true,\n    action: action(refreshCaret, editor)\n  }])], evt);\n\n  const setup$j = (editor, caret) => {\n    let isBackspaceKeydown = false;\n    editor.on('keydown', evt => {\n      isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$3(editor, caret, evt);\n      }\n    });\n    editor.on('keyup', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeyupOverride(editor, evt, isBackspaceKeydown);\n      }\n\n      isBackspaceKeydown = false;\n    });\n  };\n\n  const firstNonWhiteSpaceNodeSibling = node => {\n    while (node) {\n      if (isElement$6(node) || isText$a(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n        return node;\n      }\n\n      node = node.nextSibling;\n    }\n\n    return null;\n  };\n\n  const moveToCaretPosition = (editor, root) => {\n    const dom = editor.dom;\n    const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n\n    if (!root) {\n      return;\n    }\n\n    if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n      const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n\n      if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n        root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n      }\n    }\n\n    const rng = dom.createRng();\n    root.normalize();\n\n    if (root.hasChildNodes()) {\n      const walker = new DomTreeWalker(root, root);\n      let lastNode = root;\n      let node;\n\n      while (node = walker.current()) {\n        if (isText$a(node)) {\n          rng.setStart(node, 0);\n          rng.setEnd(node, 0);\n          break;\n        }\n\n        if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n          rng.setStartBefore(node);\n          rng.setEndBefore(node);\n          break;\n        }\n\n        lastNode = node;\n        node = walker.next();\n      }\n\n      if (!node) {\n        rng.setStart(lastNode, 0);\n        rng.setEnd(lastNode, 0);\n      }\n    } else {\n      if (isBr$6(root)) {\n        if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n          rng.setStartBefore(root);\n          rng.setEndBefore(root);\n        } else {\n          rng.setStartAfter(root);\n          rng.setEndAfter(root);\n        }\n      } else {\n        rng.setStart(root, 0);\n        rng.setEnd(root, 0);\n      }\n    }\n\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, rng);\n  };\n\n  const getEditableRoot = (dom, node) => {\n    const root = dom.getRoot();\n    let editableRoot;\n    let parent = node;\n\n    while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n      if (dom.getContentEditable(parent) === 'true') {\n        editableRoot = parent;\n        break;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return parent !== root ? editableRoot : root;\n  };\n\n  const getParentBlock$1 = editor => {\n    return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n  };\n\n  const getParentBlockName = editor => {\n    return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n      return parentBlock.nodeName.toUpperCase();\n    });\n  };\n\n  const isListItemParentBlock = editor => {\n    return getParentBlock$1(editor).filter(elm => {\n      return isListItem$1(SugarElement.fromDom(elm));\n    }).isSome();\n  };\n\n  const emptyBlock = elm => {\n    elm.innerHTML = '<br data-mce-bogus=\"1\">';\n  };\n\n  const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n    const dom = editor.dom;\n    Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n      const currentStyles = getAllRaw(SugarElement.fromDom(node));\n      const newStyles = { ...currentStyles,\n        ...attrStyles\n      };\n      dom.setStyles(node, newStyles);\n    });\n    const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n    const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n    lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n      const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n      const newClasses = [...attrClasses, ...filteredClasses];\n      dom.setAttrib(node, 'class', newClasses.join(' '));\n    });\n    const appliedAttrs = ['style', 'class'];\n    const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n    dom.setAttribs(node, remainingAttrs);\n  };\n\n  const setForcedBlockAttrs = (editor, node) => {\n    const forcedRootBlockName = getForcedRootBlock(editor);\n\n    if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n      const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n      applyAttributes(editor, node, forcedRootBlockAttrs);\n    }\n  };\n\n  const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n    const dom = editor.dom;\n    const schema = editor.schema;\n    const newBlockName = getForcedRootBlock(editor);\n    const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n    let node = container;\n    const textInlineElements = schema.getTextInlineElements();\n    let block;\n\n    if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n      block = dom.create(name || newBlockName, styles || {});\n    } else {\n      block = parentBlock.cloneNode(false);\n    }\n\n    let caretNode = block;\n\n    if (!keepStyles) {\n      dom.setAttrib(block, 'style', null);\n      dom.setAttrib(block, 'class', null);\n    } else {\n      do {\n        if (textInlineElements[node.nodeName]) {\n          if (isCaretNode(node) || isBookmarkNode$1(node)) {\n            continue;\n          }\n\n          const clonedNode = node.cloneNode(false);\n          dom.setAttrib(clonedNode, 'id', '');\n\n          if (block.hasChildNodes()) {\n            clonedNode.appendChild(block.firstChild);\n            block.appendChild(clonedNode);\n          } else {\n            caretNode = clonedNode;\n            block.appendChild(clonedNode);\n          }\n        }\n      } while ((node = node.parentNode) && node !== editableRoot);\n    }\n\n    setForcedBlockAttrs(editor, block);\n    emptyBlock(caretNode);\n    return block;\n  };\n\n  const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n\n  const isAtDetailsEdge = (root, element, isTextBlock) => {\n    let node = element;\n\n    while (node && node !== root && isNull(node.nextSibling)) {\n      const parent = node.parentElement;\n\n      if (!parent || !isTextBlock(parent)) {\n        return isDetails(parent);\n      }\n\n      node = parent;\n    }\n\n    return false;\n  };\n\n  const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n\n  const insertNewLine = (editor, createNewBlock, parentBlock) => {\n    var _a, _b, _c;\n\n    const newBlock = createNewBlock(getForcedRootBlock(editor));\n    const root = getDetailsRoot(editor, parentBlock);\n\n    if (!root) {\n      return;\n    }\n\n    editor.dom.insertAfter(newBlock, root);\n    moveToCaretPosition(editor, newBlock);\n\n    if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n      editor.dom.remove(parentBlock);\n    }\n  };\n\n  const hasFirstChild = (elm, name) => {\n    return elm.firstChild && elm.firstChild.nodeName === name;\n  };\n\n  const isFirstChild = elm => {\n    var _a;\n\n    return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n  };\n\n  const hasParent = (elm, parentName) => {\n    const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n    return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n  };\n\n  const isListBlock = elm => {\n    return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n  };\n\n  const isListItem = elm => {\n    return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n  };\n\n  const isNestedList = elm => {\n    return isListBlock(elm) && isListBlock(elm.parentNode);\n  };\n\n  const getContainerBlock = containerBlock => {\n    const containerBlockParent = containerBlock.parentNode;\n    return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n  };\n\n  const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n    let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n\n    while (node) {\n      if (isElement$6(node)) {\n        break;\n      }\n\n      node = node[first ? 'nextSibling' : 'previousSibling'];\n    }\n\n    return node === parentBlock;\n  };\n\n  const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${styleName}: ${style};`), (acc, s) => acc + s, '');\n\n  const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n    const dom = editor.dom;\n    const rng = editor.selection.getRng();\n    const containerParent = containerBlock.parentNode;\n\n    if (containerBlock === editor.getBody() || !containerParent) {\n      return;\n    }\n\n    if (isNestedList(containerBlock)) {\n      newBlockName = 'LI';\n    }\n\n    const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n    let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, {\n      style: getStyles(parentBlock)\n    }) : createNewBlock(newBlockName);\n\n    if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n      if (hasParent(containerBlock, 'LI')) {\n        const containerBlockParent = getContainerBlock(containerBlock);\n        dom.insertAfter(newBlock, containerBlockParent);\n\n        if (isFirstChild(containerBlock)) {\n          dom.remove(containerBlockParent);\n        } else {\n          dom.remove(containerBlock);\n        }\n      } else {\n        dom.replace(newBlock, containerBlock);\n      }\n    } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n      if (hasParent(containerBlock, 'LI')) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        newBlock.appendChild(dom.doc.createTextNode(' '));\n        newBlock.appendChild(containerBlock);\n      } else {\n        containerParent.insertBefore(newBlock, containerBlock);\n      }\n\n      dom.remove(parentBlock);\n    } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n      dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n      dom.remove(parentBlock);\n    } else {\n      containerBlock = getContainerBlock(containerBlock);\n      const tmpRng = rng.cloneRange();\n      tmpRng.setStartAfter(parentBlock);\n      tmpRng.setEndAfter(containerBlock);\n      const fragment = tmpRng.extractContents();\n\n      if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n        const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, containerBlock);\n        each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n\n        if (parentBlockStyles) {\n          newBlock.setAttribute('style', parentBlockStyles);\n        }\n      } else {\n        dom.insertAfter(fragment, containerBlock);\n        dom.insertAfter(newBlock, containerBlock);\n      }\n\n      dom.remove(parentBlock);\n    }\n\n    moveToCaretPosition(editor, newBlock);\n  };\n\n  const trimZwsp = fragment => {\n    each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {\n      const rawNode = text.dom;\n      rawNode.nodeValue = trim$2(rawNode.data);\n    });\n  };\n\n  const isWithinNonEditableList = (editor, node) => {\n    const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n    return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n  };\n\n  const isEmptyAnchor = (dom, elm) => {\n    return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n  };\n\n  const containerAndSiblingName = (container, nodeName) => {\n    return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n  };\n\n  const canSplitBlock = (dom, node) => {\n    return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n  };\n\n  const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n    var _a;\n\n    const firstChilds = [];\n\n    if (!block) {\n      return;\n    }\n\n    let currentNode = block;\n\n    while (currentNode = currentNode.firstChild) {\n      if (dom.isBlock(currentNode)) {\n        return;\n      }\n\n      if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n        firstChilds.push(currentNode);\n      }\n    }\n\n    let i = firstChilds.length;\n\n    while (i--) {\n      currentNode = firstChilds[i];\n\n      if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n        dom.remove(currentNode);\n      } else {\n        if (isEmptyAnchor(dom, currentNode)) {\n          dom.remove(currentNode);\n        }\n      }\n    }\n  };\n\n  const normalizeZwspOffset = (start, container, offset) => {\n    if (!isText$a(container)) {\n      return offset;\n    } else if (start) {\n      return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n    } else {\n      return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n    }\n  };\n\n  const includeZwspInRange = rng => {\n    const newRng = rng.cloneRange();\n    newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n    newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n    return newRng;\n  };\n\n  const trimLeadingLineBreaks = node => {\n    let currentNode = node;\n\n    do {\n      if (isText$a(currentNode)) {\n        currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n      }\n\n      currentNode = currentNode.firstChild;\n    } while (currentNode);\n  };\n\n  const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n    var _a, _b;\n\n    const dom = editor.dom;\n    const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n    let parentBlock = dom.getParent(container, dom.isBlock);\n\n    if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n      parentBlock = parentBlock || editableRoot;\n\n      if (!parentBlock.hasChildNodes()) {\n        const newBlock = dom.create(newBlockName);\n        setForcedBlockAttrs(editor, newBlock);\n        parentBlock.appendChild(newBlock);\n        rng.setStart(newBlock, 0);\n        rng.setEnd(newBlock, 0);\n        return newBlock;\n      }\n\n      let node = container;\n\n      while (node && node.parentNode !== parentBlock) {\n        node = node.parentNode;\n      }\n\n      let startNode;\n\n      while (node && !dom.isBlock(node)) {\n        startNode = node;\n        node = node.previousSibling;\n      }\n\n      const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n\n      if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n        const startNodeParent = startNode.parentNode;\n        const newBlock = dom.create(newBlockName);\n        setForcedBlockAttrs(editor, newBlock);\n        startNodeParent.insertBefore(newBlock, startNode);\n        node = startNode;\n\n        while (node && !dom.isBlock(node)) {\n          const next = node.nextSibling;\n          newBlock.appendChild(node);\n          node = next;\n        }\n\n        rng.setStart(container, offset);\n        rng.setEnd(container, offset);\n      }\n    }\n\n    return container;\n  };\n\n  const addBrToBlockIfNeeded = (dom, block) => {\n    block.normalize();\n    const lastChild = block.lastChild;\n\n    if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n      dom.add(block, 'br');\n    }\n  };\n\n  const shouldEndContainer = (editor, container) => {\n    const optionValue = shouldEndContainerOnEmptyBlock(editor);\n\n    if (isNullable(container)) {\n      return false;\n    } else if (isString(optionValue)) {\n      return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n    } else {\n      return optionValue;\n    }\n  };\n\n  const insert$3 = (editor, evt) => {\n    let container;\n    let offset;\n    let parentBlockName;\n    let containerBlock;\n    let isAfterLastNodeInContainer = false;\n    const dom = editor.dom;\n    const schema = editor.schema,\n          nonEmptyElementsMap = schema.getNonEmptyElements();\n    const rng = editor.selection.getRng();\n    const newBlockName = getForcedRootBlock(editor);\n    const start = SugarElement.fromDom(rng.startContainer);\n    const child = child$1(start, rng.startOffset);\n    const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n    const collapsedAndCef = rng.collapsed && isCef;\n\n    const createNewBlock$1 = (name, styles) => {\n      return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n    };\n\n    const isCaretAtStartOrEndOfBlock = start => {\n      const normalizedOffset = normalizeZwspOffset(start, container, offset);\n\n      if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n        return false;\n      }\n\n      if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n        return true;\n      }\n\n      if (start && isElement$6(container) && container === parentBlock.firstChild) {\n        return true;\n      }\n\n      if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n        return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n      }\n\n      const walker = new DomTreeWalker(container, parentBlock);\n\n      if (isText$a(container)) {\n        if (start && normalizedOffset === 0) {\n          walker.prev();\n        } else if (!start && normalizedOffset === container.data.length) {\n          walker.next();\n        }\n      }\n\n      let node;\n\n      while (node = walker.current()) {\n        if (isElement$6(node)) {\n          if (!node.getAttribute('data-mce-bogus')) {\n            const name = node.nodeName.toLowerCase();\n\n            if (nonEmptyElementsMap[name] && name !== 'br') {\n              return false;\n            }\n          }\n        } else if (isText$a(node) && !isWhitespaceText(node.data)) {\n          return false;\n        }\n\n        if (start) {\n          walker.prev();\n        } else {\n          walker.next();\n        }\n      }\n\n      return true;\n    };\n\n    const insertNewBlockAfter = () => {\n      let block;\n\n      if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n        block = createNewBlock$1(newBlockName);\n      } else {\n        block = createNewBlock$1();\n      }\n\n      if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, {\n        includeZwsp: true\n      })) {\n        block = dom.split(containerBlock, parentBlock);\n      } else {\n        dom.insertAfter(block, parentBlock);\n      }\n\n      moveToCaretPosition(editor, block);\n      return block;\n    };\n\n    normalize$2(dom, rng).each(normRng => {\n      rng.setStart(normRng.startContainer, normRng.startOffset);\n      rng.setEnd(normRng.endContainer, normRng.endOffset);\n    });\n    container = rng.startContainer;\n    offset = rng.startOffset;\n    const shiftKey = !!(evt && evt.shiftKey);\n    const ctrlKey = !!(evt && evt.ctrlKey);\n\n    if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n      isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n\n      if (isAfterLastNodeInContainer && isText$a(container)) {\n        offset = container.data.length;\n      } else {\n        offset = 0;\n      }\n    }\n\n    const editableRoot = getEditableRoot(dom, container);\n\n    if (!editableRoot || isWithinNonEditableList(editor, container)) {\n      return;\n    }\n\n    if (!shiftKey) {\n      container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n    }\n\n    let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n    containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n    parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n    const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n\n    if (containerBlockName === 'LI' && !ctrlKey) {\n      const liBlock = containerBlock;\n      parentBlock = liBlock;\n      containerBlock = liBlock.parentNode;\n      parentBlockName = containerBlockName;\n    }\n\n    if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n      return insertNewLine(editor, createNewBlock$1, parentBlock);\n    }\n\n    if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n      if (dom.isEmpty(parentBlock)) {\n        insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n        return;\n      }\n    }\n\n    if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n      return;\n    }\n\n    const parentBlockParent = parentBlock.parentNode;\n    let newBlock;\n\n    if (collapsedAndCef) {\n      newBlock = createNewBlock$1(newBlockName);\n      child.fold(() => {\n        append$1(start, SugarElement.fromDom(newBlock));\n      }, child => {\n        before$3(child, SugarElement.fromDom(newBlock));\n      });\n      editor.selection.setCursorLocation(newBlock, 0);\n    } else if (isCaretContainerBlock$1(parentBlock)) {\n      newBlock = showCaretContainerBlock(parentBlock);\n\n      if (dom.isEmpty(parentBlock)) {\n        emptyBlock(parentBlock);\n      }\n\n      setForcedBlockAttrs(editor, newBlock);\n      moveToCaretPosition(editor, newBlock);\n    } else if (isCaretAtStartOrEndOfBlock(false)) {\n      newBlock = insertNewBlockAfter();\n    } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n      newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n      const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;\n      moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') || isNearChildren ? newBlock : parentBlock);\n    } else {\n      const tmpRng = includeZwspInRange(rng).cloneRange();\n      tmpRng.setEndAfter(parentBlock);\n      const fragment = tmpRng.extractContents();\n      trimZwsp(fragment);\n      trimLeadingLineBreaks(fragment);\n      newBlock = fragment.firstChild;\n      dom.insertAfter(fragment, parentBlock);\n      trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n      addBrToBlockIfNeeded(dom, parentBlock);\n\n      if (dom.isEmpty(parentBlock)) {\n        emptyBlock(parentBlock);\n      }\n\n      newBlock.normalize();\n\n      if (dom.isEmpty(newBlock)) {\n        dom.remove(newBlock);\n        insertNewBlockAfter();\n      } else {\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      }\n    }\n\n    dom.setAttrib(newBlock, 'id', '');\n    editor.dispatch('NewBlock', {\n      newBlock\n    });\n  };\n\n  const fakeEventName$1 = 'insertParagraph';\n  const blockbreak = {\n    insert: insert$3,\n    fakeEventName: fakeEventName$1\n  };\n\n  const hasRightSideContent = (schema, container, parentBlock) => {\n    const walker = new DomTreeWalker(container, parentBlock);\n    let node;\n    const nonEmptyElementsMap = schema.getNonEmptyElements();\n\n    while (node = walker.next()) {\n      if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const moveSelectionToBr = (editor, brElm, extraBr) => {\n    const rng = editor.dom.createRng();\n\n    if (!extraBr) {\n      rng.setStartAfter(brElm);\n      rng.setEndAfter(brElm);\n    } else {\n      rng.setStartBefore(brElm);\n      rng.setEndBefore(brElm);\n    }\n\n    editor.selection.setRng(rng);\n    scrollRangeIntoView(editor, rng);\n  };\n\n  const insertBrAtCaret = (editor, evt) => {\n    const selection = editor.selection;\n    const dom = editor.dom;\n    const rng = selection.getRng();\n    let brElm;\n    let extraBr = false;\n    normalize$2(dom, rng).each(normRng => {\n      rng.setStart(normRng.startContainer, normRng.startOffset);\n      rng.setEnd(normRng.endContainer, normRng.endOffset);\n    });\n    let offset = rng.startOffset;\n    let container = rng.startContainer;\n\n    if (isElement$6(container) && container.hasChildNodes()) {\n      const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n      container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n\n      if (isAfterLastNodeInContainer && isText$a(container)) {\n        offset = container.data.length;\n      } else {\n        offset = 0;\n      }\n    }\n\n    let parentBlock = dom.getParent(container, dom.isBlock);\n    const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n    const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n    const isControlKey = !!(evt && evt.ctrlKey);\n\n    if (containerBlockName === 'LI' && !isControlKey) {\n      parentBlock = containerBlock;\n    }\n\n    if (isText$a(container) && offset >= container.data.length) {\n      if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n        brElm = dom.create('br');\n        rng.insertNode(brElm);\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n        extraBr = true;\n      }\n    }\n\n    brElm = dom.create('br');\n    rangeInsertNode(dom, rng, brElm);\n    moveSelectionToBr(editor, brElm, extraBr);\n    editor.undoManager.add();\n  };\n\n  const insertBrBefore = (editor, inline) => {\n    const br = SugarElement.fromTag('br');\n    before$3(SugarElement.fromDom(inline), br);\n    editor.undoManager.add();\n  };\n\n  const insertBrAfter = (editor, inline) => {\n    if (!hasBrAfter(editor.getBody(), inline)) {\n      after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n    }\n\n    const br = SugarElement.fromTag('br');\n    after$4(SugarElement.fromDom(inline), br);\n    moveSelectionToBr(editor, br.dom, false);\n    editor.undoManager.add();\n  };\n\n  const isBeforeBr = pos => {\n    return isBr$6(pos.getNode());\n  };\n\n  const hasBrAfter = (rootNode, startNode) => {\n    if (isBeforeBr(CaretPosition.after(startNode))) {\n      return true;\n    } else {\n      return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n        return isBr$6(pos.getNode());\n      }).getOr(false);\n    }\n  };\n\n  const isAnchorLink = elm => {\n    return elm && elm.nodeName === 'A' && 'href' in elm;\n  };\n\n  const isInsideAnchor = location => {\n    return location.fold(never, isAnchorLink, isAnchorLink, never);\n  };\n\n  const readInlineAnchorLocation = editor => {\n    const isInlineTarget$1 = curry(isInlineTarget, editor);\n    const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n    return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n  };\n\n  const insertBrOutsideAnchor = (editor, location) => {\n    location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n  };\n\n  const insert$2 = (editor, evt) => {\n    const anchorLocation = readInlineAnchorLocation(editor);\n\n    if (anchorLocation.isSome()) {\n      anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n    } else {\n      insertBrAtCaret(editor, evt);\n    }\n  };\n\n  const fakeEventName = 'insertLineBreak';\n  const linebreak = {\n    insert: insert$2,\n    fakeEventName\n  };\n\n  const matchesSelector = (editor, selector) => {\n    return getParentBlock$1(editor).filter(parentBlock => {\n      return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n    }).isSome();\n  };\n\n  const shouldInsertBr = editor => {\n    return matchesSelector(editor, getBrNewLineSelector(editor));\n  };\n\n  const shouldBlockNewLine$1 = editor => {\n    return matchesSelector(editor, getNoNewLineSelector(editor));\n  };\n\n  const newLineAction = Adt.generate([{\n    br: []\n  }, {\n    block: []\n  }, {\n    none: []\n  }]);\n\n  const shouldBlockNewLine = (editor, _shiftKey) => {\n    return shouldBlockNewLine$1(editor);\n  };\n\n  const inListBlock = requiredState => {\n    return (editor, _shiftKey) => {\n      return isListItemParentBlock(editor) === requiredState;\n    };\n  };\n\n  const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n    const state = getParentBlockName(editor) === blockName.toUpperCase();\n    return state === requiredState;\n  };\n\n  const inCefBlock = editor => {\n    const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n    return isNullable(editableRoot);\n  };\n\n  const inPreBlock = requiredState => inBlock('pre', requiredState);\n\n  const inSummaryBlock = () => inBlock('summary', true);\n\n  const shouldPutBrInPre = requiredState => {\n    return (editor, _shiftKey) => {\n      return shouldPutBrInPre$1(editor) === requiredState;\n    };\n  };\n\n  const inBrContext = (editor, _shiftKey) => {\n    return shouldInsertBr(editor);\n  };\n\n  const hasShiftKey = (_editor, shiftKey) => {\n    return shiftKey;\n  };\n\n  const canInsertIntoEditableRoot = editor => {\n    const forcedRootBlock = getForcedRootBlock(editor);\n    const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n    return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n  };\n\n  const isInRootWithEmptyOrCEF = editor => {\n    const rng = editor.selection.getRng();\n    const start = SugarElement.fromDom(rng.startContainer);\n    const child = child$1(start, rng.startOffset);\n    const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n    return rng.collapsed && isCefOpt.getOr(true);\n  };\n\n  const match = (predicates, action) => {\n    return (editor, shiftKey) => {\n      const isMatch = foldl(predicates, (res, p) => {\n        return res && p(editor, shiftKey);\n      }, true);\n      return isMatch ? Optional.some(action) : Optional.none();\n    };\n  };\n\n  const getAction = (editor, evt) => {\n    return evaluateUntil([match([shouldBlockNewLine], newLineAction.none()), match([inPreBlock(true), inCefBlock], newLineAction.none()), match([inSummaryBlock()], newLineAction.br()), match([inPreBlock(true), shouldPutBrInPre(false), hasShiftKey], newLineAction.br()), match([inPreBlock(true), shouldPutBrInPre(false)], newLineAction.block()), match([inPreBlock(true), shouldPutBrInPre(true), hasShiftKey], newLineAction.block()), match([inPreBlock(true), shouldPutBrInPre(true)], newLineAction.br()), match([inListBlock(true), hasShiftKey], newLineAction.br()), match([inListBlock(true)], newLineAction.block()), match([inBrContext], newLineAction.br()), match([hasShiftKey], newLineAction.br()), match([canInsertIntoEditableRoot], newLineAction.block()), match([isInRootWithEmptyOrCEF], newLineAction.block())], [editor, !!(evt && evt.shiftKey)]).getOr(newLineAction.none());\n  };\n\n  const insertBreak = (breakType, editor, evt) => {\n    if (!editor.selection.isCollapsed()) {\n      execEditorDeleteCommand(editor);\n    }\n\n    if (isNonNullable(evt)) {\n      const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n    }\n\n    breakType.insert(editor, evt);\n\n    if (isNonNullable(evt)) {\n      fireInputEvent(editor, breakType.fakeEventName);\n    }\n  };\n\n  const insert$1 = (editor, evt) => {\n    const br = () => insertBreak(linebreak, editor, evt);\n\n    const block = () => insertBreak(blockbreak, editor, evt);\n\n    const logicalAction = getAction(editor, evt);\n\n    switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n    }\n  };\n\n  const platform$1 = detect$2();\n  const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n\n  const handleEnterKeyEvent = (editor, event) => {\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n\n    event.preventDefault();\n    endTypingLevelIgnoreLocks(editor.undoManager);\n    editor.undoManager.transact(() => {\n      insert$1(editor, event);\n    });\n  };\n\n  const isCaretAfterKoreanCharacter = rng => {\n    if (!rng.collapsed) {\n      return false;\n    }\n\n    const startContainer = rng.startContainer;\n\n    if (isText$a(startContainer)) {\n      const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n      const char = startContainer.data.charAt(rng.startOffset - 1);\n      return koreanCharRegex.test(char);\n    } else {\n      return false;\n    }\n  };\n\n  const setup$i = editor => {\n    let iOSSafariKeydownBookmark = Optional.none();\n\n    const iOSSafariKeydownOverride = editor => {\n      iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n      editor.undoManager.add();\n    };\n\n    const iOSSafariKeyupOverride = (editor, event) => {\n      editor.undoManager.undo();\n      iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n      handleEnterKeyEvent(editor, event);\n      iOSSafariKeydownBookmark = Optional.none();\n    };\n\n    editor.on('keydown', event => {\n      if (event.keyCode === VK.ENTER) {\n        if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n          iOSSafariKeydownOverride(editor);\n        } else {\n          handleEnterKeyEvent(editor, event);\n        }\n      }\n    });\n    editor.on('keyup', event => {\n      if (event.keyCode === VK.ENTER) {\n        iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n      }\n    });\n  };\n\n  const executeKeydownOverride$2 = (editor, caret, evt) => {\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    execute([{\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint$1, editor, true)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint$1, editor, false)\n    }, ...(!isMac ? [{\n      keyCode: VK.HOME,\n      action: action(selectToEndPoint, editor, false),\n      ctrlKey: true,\n      shiftKey: true\n    }, {\n      keyCode: VK.END,\n      action: action(selectToEndPoint, editor, true),\n      ctrlKey: true,\n      shiftKey: true\n    }] : []), {\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint, editor, true)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint, editor, false)\n    }, {\n      keyCode: VK.END,\n      action: action(moveToLineEndPoint$2, editor, true, caret)\n    }, {\n      keyCode: VK.HOME,\n      action: action(moveToLineEndPoint$2, editor, false, caret)\n    }], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n\n  const setup$h = (editor, caret) => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$2(editor, caret, evt);\n      }\n    });\n  };\n\n  const setup$g = editor => {\n    editor.on('input', e => {\n      if (!e.isComposing) {\n        normalizeNbspsInEditor(editor);\n      }\n    });\n  };\n\n  const platform = detect$2();\n\n  const executeKeyupAction = (editor, caret, evt) => {\n    execute([{\n      keyCode: VK.PAGE_UP,\n      action: action(moveToLineEndPoint$2, editor, false, caret)\n    }, {\n      keyCode: VK.PAGE_DOWN,\n      action: action(moveToLineEndPoint$2, editor, true, caret)\n    }], evt);\n  };\n\n  const stopImmediatePropagation = e => e.stopImmediatePropagation();\n\n  const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n\n  const setNodeChangeBlocker = (blocked, editor, block) => {\n    if (block && !blocked.get()) {\n      editor.on('NodeChange', stopImmediatePropagation, true);\n    } else if (!block && blocked.get()) {\n      editor.off('NodeChange', stopImmediatePropagation);\n    }\n\n    blocked.set(block);\n  };\n\n  const setup$f = (editor, caret) => {\n    if (platform.os.isMacOS()) {\n      return;\n    }\n\n    const blocked = Cell(false);\n    editor.on('keydown', evt => {\n      if (isPageUpDown(evt)) {\n        setNodeChangeBlocker(blocked, editor, true);\n      }\n    });\n    editor.on('keyup', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeyupAction(editor, caret, evt);\n      }\n\n      if (isPageUpDown(evt) && blocked.get()) {\n        setNodeChangeBlocker(blocked, editor, false);\n        editor.nodeChanged();\n      }\n    });\n  };\n\n  const setup$e = editor => {\n    editor.on('beforeinput', e => {\n      if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n        e.preventDefault();\n      }\n    });\n  };\n\n  const insertTextAtPosition = (text, pos) => {\n    const container = pos.container();\n    const offset = pos.offset();\n\n    if (isText$a(container)) {\n      container.insertData(offset, text);\n      return Optional.some(CaretPosition(container, offset + text.length));\n    } else {\n      return getElementFromPosition(pos).map(elm => {\n        const textNode = SugarElement.fromText(text);\n\n        if (pos.isAtEnd()) {\n          after$4(elm, textNode);\n        } else {\n          before$3(elm, textNode);\n        }\n\n        return CaretPosition(textNode.dom, text.length);\n      });\n    }\n  };\n\n  const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n  const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n  const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n\n  const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n\n  const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n\n  const setSelection = editor => pos => {\n    editor.selection.setRng(pos.toRange());\n    editor.nodeChanged();\n  };\n\n  const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n\n  const insertSpaceOrNbspAtSelection = editor => {\n    const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n    const root = SugarElement.fromDom(editor.getBody());\n\n    if (editor.selection.isCollapsed()) {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n    } else {\n      return Optional.none();\n    }\n  };\n\n  const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n    const insertSpaceThunk = () => {\n      const root = SugarElement.fromDom(editor.getBody());\n\n      if (!editor.selection.isCollapsed()) {\n        editor.getDoc().execCommand('Delete');\n      }\n\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n    };\n\n    return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n  };\n\n  const executeKeydownOverride$1 = (editor, evt) => {\n    executeWithDelayedAction([{\n      keyCode: VK.SPACEBAR,\n      action: action(insertSpaceOrNbspAtSelection, editor)\n    }, {\n      keyCode: VK.SPACEBAR,\n      action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n    }], evt).each(applyAction => {\n      evt.preventDefault();\n      const event = fireBeforeInputEvent(editor, 'insertText', {\n        data: ' '\n      });\n\n      if (!event.isDefaultPrevented()) {\n        applyAction();\n        fireInputEvent(editor, 'insertText', {\n          data: ' '\n        });\n      }\n    });\n  };\n\n  const setup$d = editor => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride$1(editor, evt);\n      }\n    });\n  };\n\n  const tableTabNavigation = editor => {\n    if (hasTableTabNavigation(editor)) {\n      return [{\n        keyCode: VK.TAB,\n        action: action(handleTab, editor, true)\n      }, {\n        keyCode: VK.TAB,\n        shiftKey: true,\n        action: action(handleTab, editor, false)\n      }];\n    } else {\n      return [];\n    }\n  };\n\n  const executeKeydownOverride = (editor, evt) => {\n    execute([...tableTabNavigation(editor)], evt).each(_ => {\n      evt.preventDefault();\n    });\n  };\n\n  const setup$c = editor => {\n    editor.on('keydown', evt => {\n      if (!evt.isDefaultPrevented()) {\n        executeKeydownOverride(editor, evt);\n      }\n    });\n  };\n\n  const setup$b = editor => {\n    editor.addShortcut('Meta+P', '', 'mcePrint');\n    setup$k(editor);\n\n    if (isRtc(editor)) {\n      return Cell(null);\n    } else {\n      const caret = setupSelectedState(editor);\n      setup$e(editor);\n      setup$m(editor);\n      setup$l(editor, caret);\n      setup$j(editor, caret);\n      setup$i(editor);\n      setup$d(editor);\n      setup$g(editor);\n      setup$c(editor);\n      setup$h(editor, caret);\n      setup$f(editor, caret);\n      return caret;\n    }\n  };\n\n  class NodeChange {\n    constructor(editor) {\n      this.lastPath = [];\n      this.editor = editor;\n      let lastRng;\n      const self = this;\n\n      if (!('onselectionchange' in editor.getDoc())) {\n        editor.on('NodeChange click mouseup keyup focus', e => {\n          const nativeRng = editor.selection.getRng();\n          const fakeRng = {\n            startContainer: nativeRng.startContainer,\n            startOffset: nativeRng.startOffset,\n            endContainer: nativeRng.endContainer,\n            endOffset: nativeRng.endOffset\n          };\n\n          if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n            editor.dispatch('SelectionChange');\n          }\n\n          lastRng = fakeRng;\n        });\n      }\n\n      editor.on('contextmenu', () => {\n        editor.dispatch('SelectionChange');\n      });\n      editor.on('SelectionChange', () => {\n        const startElm = editor.selection.getStart(true);\n\n        if (!startElm) {\n          return;\n        }\n\n        if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n          editor.nodeChanged({\n            selectionChange: true\n          });\n        }\n      });\n      editor.on('mouseup', e => {\n        if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n          if (editor.selection.getNode().nodeName === 'IMG') {\n            Delay.setEditorTimeout(editor, () => {\n              editor.nodeChanged();\n            });\n          } else {\n            editor.nodeChanged();\n          }\n        }\n      });\n    }\n\n    nodeChanged(args = {}) {\n      const selection = this.editor.selection;\n      let node;\n\n      if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n        const root = this.editor.getBody();\n        node = selection.getStart(true) || root;\n\n        if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n          node = root;\n        }\n\n        const parents = [];\n        this.editor.dom.getParent(node, node => {\n          if (node === root) {\n            return true;\n          } else {\n            parents.push(node);\n            return false;\n          }\n        });\n        this.editor.dispatch('NodeChange', { ...args,\n          element: node,\n          parents\n        });\n      }\n    }\n\n    isSameElementPath(startElm) {\n      let i;\n      const editor = this.editor;\n      const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n\n      if (currentPath.length === this.lastPath.length) {\n        for (i = currentPath.length; i >= 0; i--) {\n          if (currentPath[i] !== this.lastPath[i]) {\n            break;\n          }\n        }\n\n        if (i === -1) {\n          this.lastPath = currentPath;\n          return true;\n        }\n      }\n\n      this.lastPath = currentPath;\n      return false;\n    }\n\n  }\n\n  const imageId = generate$1('image');\n\n  const getDragImage = transfer => {\n    const dt = transfer;\n    return Optional.from(dt[imageId]);\n  };\n\n  const setDragImage = (transfer, imageData) => {\n    const dt = transfer;\n    dt[imageId] = imageData;\n  };\n\n  const eventId = generate$1('event');\n\n  const getEvent = transfer => {\n    const dt = transfer;\n    return Optional.from(dt[eventId]);\n  };\n\n  const mkSetEventFn = type => transfer => {\n    const dt = transfer;\n    dt[eventId] = type;\n  };\n\n  const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n\n  const setDragstartEvent = mkSetEventFn(0);\n  const setDropEvent = mkSetEventFn(2);\n  const setDragendEvent = mkSetEventFn(1);\n\n  const checkEvent = expectedType => transfer => {\n    const dt = transfer;\n    return Optional.from(dt[eventId]).exists(type => type === expectedType);\n  };\n\n  const isInDragStartEvent = checkEvent(0);\n\n  const createEmptyFileList = () => Object.freeze({\n    length: 0,\n    item: _ => null\n  });\n\n  const modeId = generate$1('mode');\n\n  const getMode = transfer => {\n    const dt = transfer;\n    return Optional.from(dt[modeId]);\n  };\n\n  const mkSetModeFn = mode => transfer => {\n    const dt = transfer;\n    dt[modeId] = mode;\n  };\n\n  const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n\n  const setReadWriteMode = mkSetModeFn(0);\n  const setReadOnlyMode = mkSetModeFn(2);\n  const setProtectedMode = mkSetModeFn(1);\n\n  const checkMode = expectedMode => transfer => {\n    const dt = transfer;\n    return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n  };\n\n  const isInReadWriteMode = checkMode(0);\n  const isInProtectedMode = checkMode(1);\n\n  const normalizeItems = (dataTransfer, itemsImpl) => ({ ...itemsImpl,\n\n    get length() {\n      return itemsImpl.length;\n    },\n\n    add: (data, type) => {\n      if (isInReadWriteMode(dataTransfer)) {\n        if (isString(data)) {\n          if (!isUndefined(type)) {\n            return itemsImpl.add(data, type);\n          }\n        } else {\n          return itemsImpl.add(data);\n        }\n      }\n\n      return null;\n    },\n    remove: idx => {\n      if (isInReadWriteMode(dataTransfer)) {\n        itemsImpl.remove(idx);\n      }\n    },\n    clear: () => {\n      if (isInReadWriteMode(dataTransfer)) {\n        itemsImpl.clear();\n      }\n    }\n  });\n\n  const validDropEffects = ['none', 'copy', 'link', 'move'];\n  const validEffectAlloweds = ['none', 'copy', 'copyLink', 'copyMove', 'link', 'linkMove', 'move', 'all', 'uninitialized'];\n\n  const createDataTransfer = () => {\n    const dataTransferImpl = new window.DataTransfer();\n    let dropEffect = 'move';\n    let effectAllowed = 'all';\n    const dataTransfer = {\n      get dropEffect() {\n        return dropEffect;\n      },\n\n      set dropEffect(effect) {\n        if (contains$2(validDropEffects, effect)) {\n          dropEffect = effect;\n        }\n      },\n\n      get effectAllowed() {\n        return effectAllowed;\n      },\n\n      set effectAllowed(allowed) {\n        if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n          effectAllowed = allowed;\n        }\n      },\n\n      get items() {\n        return normalizeItems(dataTransfer, dataTransferImpl.items);\n      },\n\n      get files() {\n        if (isInProtectedMode(dataTransfer)) {\n          return createEmptyFileList();\n        } else {\n          return dataTransferImpl.files;\n        }\n      },\n\n      get types() {\n        return dataTransferImpl.types;\n      },\n\n      setDragImage: (image, x, y) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          setDragImage(dataTransfer, {\n            image,\n            x,\n            y\n          });\n          dataTransferImpl.setDragImage(image, x, y);\n        }\n      },\n      getData: format => {\n        if (isInProtectedMode(dataTransfer)) {\n          return '';\n        } else {\n          return dataTransferImpl.getData(format);\n        }\n      },\n      setData: (format, data) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          dataTransferImpl.setData(format, data);\n        }\n      },\n      clearData: format => {\n        if (isInReadWriteMode(dataTransfer)) {\n          dataTransferImpl.clearData(format);\n        }\n      }\n    };\n    setReadWriteMode(dataTransfer);\n    return dataTransfer;\n  };\n\n  const cloneDataTransfer = original => {\n    const clone = createDataTransfer();\n    const originalMode = getMode(original);\n    setReadOnlyMode(original);\n    setDragstartEvent(clone);\n    clone.dropEffect = original.dropEffect;\n    clone.effectAllowed = original.effectAllowed;\n    getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n    each$e(original.types, type => {\n      if (type !== 'Files') {\n        clone.setData(type, original.getData(type));\n      }\n    });\n    each$e(original.files, file => clone.items.add(file));\n    getEvent(original).each(type => {\n      setEvent(clone, type);\n    });\n    originalMode.each(mode => {\n      setMode$1(original, mode);\n      setMode$1(clone, mode);\n    });\n    return clone;\n  };\n\n  const getHtmlData = dataTransfer => {\n    const html = dataTransfer.getData('text/html');\n    return html === '' ? Optional.none() : Optional.some(html);\n  };\n\n  const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n\n  const internalMimeType = 'x-tinymce/html';\n  const internalHtmlMime = constant(internalMimeType);\n  const internalMark = '<!-- ' + internalMimeType + ' -->';\n\n  const mark = html => internalMark + html;\n\n  const unmark = html => html.replace(internalMark, '');\n\n  const isMarked = html => html.indexOf(internalMark) !== -1;\n\n  const isPlainText = text => {\n    return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n  };\n\n  const openContainer = (rootTag, rootAttrs) => {\n    let tag = '<' + rootTag;\n    const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n\n    if (attrs.length) {\n      tag += ' ' + attrs.join(' ');\n    }\n\n    return tag + '>';\n  };\n\n  const toBlockElements = (text, rootTag, rootAttrs) => {\n    const blocks = text.split(/\\n\\n/);\n    const tagOpen = openContainer(rootTag, rootAttrs);\n    const tagClose = '</' + rootTag + '>';\n    const paragraphs = map$3(blocks, p => {\n      return p.split(/\\n/).join('<br />');\n    });\n\n    const stitch = p => {\n      return tagOpen + p + tagClose;\n    };\n\n    return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n  };\n\n  const pasteBinDefaultContent = '%MCEPASTEBIN%';\n\n  const create$6 = (editor, lastRngCell) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const body = editor.getBody();\n    lastRngCell.set(selection.getRng());\n    const pasteBinElm = dom.add(editor.getBody(), 'div', {\n      'id': 'mcepastebin',\n      'class': 'mce-pastebin',\n      'contentEditable': true,\n      'data-mce-bogus': 'all',\n      'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n    }, pasteBinDefaultContent);\n\n    if (Env.browser.isFirefox()) {\n      dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n    }\n\n    dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n      e.stopPropagation();\n    });\n    pasteBinElm.focus();\n    selection.select(pasteBinElm, true);\n  };\n\n  const remove = (editor, lastRngCell) => {\n    const dom = editor.dom;\n\n    if (getEl(editor)) {\n      let pasteBinClone;\n      const lastRng = lastRngCell.get();\n\n      while (pasteBinClone = getEl(editor)) {\n        dom.remove(pasteBinClone);\n        dom.unbind(pasteBinClone);\n      }\n\n      if (lastRng) {\n        editor.selection.setRng(lastRng);\n      }\n    }\n\n    lastRngCell.set(null);\n  };\n\n  const getEl = editor => editor.dom.get('mcepastebin');\n\n  const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n\n  const getHtml = editor => {\n    const dom = editor.dom;\n\n    const copyAndRemove = (toElm, fromElm) => {\n      toElm.appendChild(fromElm);\n      dom.remove(fromElm, true);\n    };\n\n    const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n    each$e(pasteBinClones, pasteBinClone => {\n      copyAndRemove(pasteBinElm, pasteBinClone);\n    });\n    const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n\n    for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n      const cleanWrapper = dom.create('div');\n      pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n      copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n    }\n\n    return pasteBinElm ? pasteBinElm.innerHTML : '';\n  };\n\n  const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n\n  const PasteBin = editor => {\n    const lastRng = Cell(null);\n    return {\n      create: () => create$6(editor, lastRng),\n      remove: () => remove(editor, lastRng),\n      getEl: () => getEl(editor),\n      getHtml: () => getHtml(editor),\n      getLastRng: lastRng.get\n    };\n  };\n\n  const filter$1 = (content, items) => {\n    Tools.each(items, v => {\n      if (is$4(v, RegExp)) {\n        content = content.replace(v, '');\n      } else {\n        content = content.replace(v[0], v[1]);\n      }\n    });\n    return content;\n  };\n\n  const innerText = html => {\n    const schema = Schema();\n    const domParser = DomParser({}, schema);\n    let text = '';\n    const voidElements = schema.getVoidElements();\n    const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n    const blockElements = schema.getBlockElements();\n\n    const walk = node => {\n      const name = node.name,\n            currentNode = node;\n\n      if (name === 'br') {\n        text += '\\n';\n        return;\n      }\n\n      if (name === 'wbr') {\n        return;\n      }\n\n      if (voidElements[name]) {\n        text += ' ';\n      }\n\n      if (ignoreElements[name]) {\n        text += ' ';\n        return;\n      }\n\n      if (node.type === 3) {\n        text += node.value;\n      }\n\n      if (!(node.name in schema.getVoidElements())) {\n        let currentNode = node.firstChild;\n\n        if (currentNode) {\n          do {\n            walk(currentNode);\n          } while (currentNode = currentNode.next);\n        }\n      }\n\n      if (blockElements[name] && currentNode.next) {\n        text += '\\n';\n\n        if (name === 'p') {\n          text += '\\n';\n        }\n      }\n    };\n\n    html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n    walk(domParser.parse(html));\n    return text;\n  };\n\n  const trimHtml = html => {\n    const trimSpaces = (all, s1, s2) => {\n      if (!s1 && !s2) {\n        return ' ';\n      }\n\n      return nbsp;\n    };\n\n    html = filter$1(html, [/^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig, /<!--StartFragment-->|<!--EndFragment-->/g, [/( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g, trimSpaces], /<br class=\"Apple-interchange-newline\">/g, /<br>$/i]);\n    return html;\n  };\n\n  const createIdGenerator = prefix => {\n    let count = 0;\n    return () => {\n      return prefix + count++;\n    };\n  };\n\n  const getImageMimeType = ext => {\n    const lowerExt = ext.toLowerCase();\n    const mimeOverrides = {\n      jpg: 'jpeg',\n      jpe: 'jpeg',\n      jfi: 'jpeg',\n      jif: 'jpeg',\n      jfif: 'jpeg',\n      pjpeg: 'jpeg',\n      pjp: 'jpeg',\n      svg: 'svg+xml'\n    };\n    return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n  };\n\n  const preProcess = (editor, html) => {\n    const parser = DomParser({\n      sanitize: shouldSanitizeXss(editor),\n      sandbox_iframes: shouldSandboxIframes(editor)\n    }, editor.schema);\n    parser.addNodeFilter('meta', nodes => {\n      Tools.each(nodes, node => {\n        node.remove();\n      });\n    });\n    const fragment = parser.parse(html, {\n      forced_root_block: false,\n      isRootContent: true\n    });\n    return HtmlSerializer({\n      validate: true\n    }, editor.schema).serialize(fragment);\n  };\n\n  const processResult = (content, cancelled) => ({\n    content,\n    cancelled\n  });\n\n  const postProcessFilter = (editor, html, internal) => {\n    const tempBody = editor.dom.create('div', {\n      style: 'display:none'\n    }, html);\n    const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n    return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n  };\n\n  const filterContent = (editor, content, internal) => {\n    const preProcessArgs = firePastePreProcess(editor, content, internal);\n    const filteredContent = preProcess(editor, preProcessArgs.content);\n\n    if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n      return postProcessFilter(editor, filteredContent, internal);\n    } else {\n      return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n    }\n  };\n\n  const process = (editor, html, internal) => {\n    return filterContent(editor, html, internal);\n  };\n\n  const pasteHtml$1 = (editor, html) => {\n    editor.insertContent(html, {\n      merge: shouldPasteMergeFormats(editor),\n      paste: true\n    });\n    return true;\n  };\n\n  const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n\n  const isImageUrl = (editor, url) => {\n    return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${type.toLowerCase()}`));\n  };\n\n  const createImage = (editor, url, pasteHtmlFn) => {\n    editor.undoManager.extra(() => {\n      pasteHtmlFn(editor, url);\n    }, () => {\n      editor.insertContent('<img src=\"' + url + '\">');\n    });\n    return true;\n  };\n\n  const createLink = (editor, url, pasteHtmlFn) => {\n    editor.undoManager.extra(() => {\n      pasteHtmlFn(editor, url);\n    }, () => {\n      editor.execCommand('mceInsertLink', false, url);\n    });\n    return true;\n  };\n\n  const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n\n  const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n\n  const smartInsertContent = (editor, html) => {\n    Tools.each([linkSelection, insertImage, pasteHtml$1], action => {\n      return !action(editor, html, pasteHtml$1);\n    });\n  };\n\n  const insertContent = (editor, html, pasteAsText) => {\n    if (pasteAsText || !isSmartPasteEnabled(editor)) {\n      pasteHtml$1(editor, html);\n    } else {\n      smartInsertContent(editor, html);\n    }\n  };\n\n  const uniqueId = createIdGenerator('mceclip');\n\n  const createPasteDataTransfer = html => {\n    const dataTransfer = createDataTransfer();\n    setHtmlData(dataTransfer, html);\n    setReadOnlyMode(dataTransfer);\n    return dataTransfer;\n  };\n\n  const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n    const res = process(editor, content, internal);\n\n    if (!res.cancelled) {\n      const content = res.content;\n\n      const doPasteAction = () => insertContent(editor, content, pasteAsText);\n\n      if (shouldSimulateInputEvent) {\n        const args = fireBeforeInputEvent(editor, 'insertFromPaste', {\n          dataTransfer: createPasteDataTransfer(content)\n        });\n\n        if (!args.isDefaultPrevented()) {\n          doPasteAction();\n          fireInputEvent(editor, 'insertFromPaste');\n        }\n      } else {\n        doPasteAction();\n      }\n    }\n  };\n\n  const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n    const internal = internalFlag ? internalFlag : isMarked(html);\n    doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n  };\n\n  const pasteText = (editor, text, shouldSimulateInputEvent) => {\n    const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n    const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n    const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    doPaste(editor, html, false, true, shouldSimulateInputEvent);\n  };\n\n  const getDataTransferItems = dataTransfer => {\n    const items = {};\n\n    if (dataTransfer && dataTransfer.types) {\n      for (let i = 0; i < dataTransfer.types.length; i++) {\n        const contentType = dataTransfer.types[i];\n\n        try {\n          items[contentType] = dataTransfer.getData(contentType);\n        } catch (ex) {\n          items[contentType] = '';\n        }\n      }\n    }\n\n    return items;\n  };\n\n  const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n\n  const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n\n  const extractFilename = (editor, str) => {\n    const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n    return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n  };\n\n  const createBlobInfo = (editor, blobCache, file, base64) => {\n    const id = uniqueId();\n    const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n    const name = useFileName ? extractFilename(editor, file.name) : id;\n    const filename = useFileName ? file.name : undefined;\n    const blobInfo = blobCache.create(id, file, base64, name, filename);\n    blobCache.add(blobInfo);\n    return blobInfo;\n  };\n\n  const pasteImage = (editor, imageItem) => {\n    parseDataUri(imageItem.uri).each(({\n      data,\n      type,\n      base64Encoded\n    }) => {\n      const base64 = base64Encoded ? data : btoa(data);\n      const file = imageItem.file;\n      const blobCache = editor.editorUpload.blobCache;\n      const existingBlobInfo = blobCache.getByData(base64, type);\n      const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n      pasteHtml(editor, `<img src=\"${blobInfo.blobUri()}\">`, false, true);\n    });\n  };\n\n  const isClipboardEvent = event => event.type === 'paste';\n\n  const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n    return blobToDataUri(file).then(uri => ({\n      file,\n      uri\n    }));\n  }));\n\n  const isImage = editor => {\n    const allowedExtensions = getAllowedImageFileTypes(editor);\n    return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n      return getImageMimeType(extension) === file.type;\n    });\n  };\n\n  const getImagesFromDataTransfer = (editor, dataTransfer) => {\n    const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n      return item.kind === 'file' ? [item.getAsFile()] : [];\n    }) : [];\n    const files = dataTransfer.files ? from(dataTransfer.files) : [];\n    return filter$5(items.length > 0 ? items : files, isImage(editor));\n  };\n\n  const pasteImageData = (editor, e, rng) => {\n    const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n\n    if (shouldPasteDataImages(editor) && dataTransfer) {\n      const images = getImagesFromDataTransfer(editor, dataTransfer);\n\n      if (images.length > 0) {\n        e.preventDefault();\n        readFilesAsDataUris(images).then(fileResults => {\n          if (rng) {\n            editor.selection.setRng(rng);\n          }\n\n          each$e(fileResults, result => {\n            pasteImage(editor, result);\n          });\n        });\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const isBrokenAndroidClipboardEvent = e => {\n    var _a, _b;\n\n    return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n  };\n\n  const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n\n  const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n    let content = trimHtml(html);\n    const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n    const isPlainTextHtml = !isInternal && isPlainText(content);\n    const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n\n    if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n      plainTextMode = true;\n    }\n\n    if (plainTextMode || isAbsoluteUrl$1) {\n      if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n        content = clipboardContent['text/plain'];\n      } else {\n        content = innerText(content);\n      }\n    }\n\n    if (isDefaultPasteBinContent(content)) {\n      return;\n    }\n\n    if (plainTextMode) {\n      pasteText(editor, content, shouldSimulateInputEvent);\n    } else {\n      pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n    }\n  };\n\n  const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n    let keyboardPastePlainTextState;\n\n    const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n\n    editor.on('keydown', e => {\n      if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n        keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n      }\n    });\n    editor.on('paste', e => {\n      if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n        return;\n      }\n\n      const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n      keyboardPastePlainTextState = false;\n      const clipboardContent = getDataTransferItems(e.clipboardData);\n\n      if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n        return;\n      }\n\n      if (hasContentType(clipboardContent, 'text/html')) {\n        e.preventDefault();\n        insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n      } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n        e.preventDefault();\n        insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n      } else {\n        pasteBin.create();\n        Delay.setEditorTimeout(editor, () => {\n          const html = pasteBin.getHtml();\n          pasteBin.remove();\n          insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n        }, 0);\n      }\n    });\n  };\n\n  const registerDataImageFilter = editor => {\n    const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n\n    const isDataUri = src => startsWith(src, 'data:');\n\n    const isPasteInsert = args => {\n      var _a;\n\n      return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n    };\n\n    editor.parser.addNodeFilter('img', (nodes, name, args) => {\n      if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n        for (const node of nodes) {\n          const src = node.attr('src');\n\n          if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n            if (isWebKitFakeUrl(src)) {\n              node.remove();\n            } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n              node.remove();\n            }\n          }\n        }\n      }\n    });\n  };\n\n  const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n    registerEventHandlers(editor, pasteBin, pasteFormat);\n    registerDataImageFilter(editor);\n  };\n\n  const togglePlainTextPaste = (editor, pasteFormat) => {\n    if (pasteFormat.get() === 'text') {\n      pasteFormat.set('html');\n      firePastePlainTextToggle(editor, false);\n    } else {\n      pasteFormat.set('text');\n      firePastePlainTextToggle(editor, true);\n    }\n\n    editor.focus();\n  };\n\n  const register$1 = (editor, pasteFormat) => {\n    editor.addCommand('mceTogglePlainTextPaste', () => {\n      togglePlainTextPaste(editor, pasteFormat);\n    });\n    editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n      if (value.html) {\n        pasteHtml(editor, value.html, value.internal, false);\n      }\n\n      if (value.text) {\n        pasteText(editor, value.text, false);\n      }\n    });\n  };\n\n  const setHtml5Clipboard = (clipboardData, html, text) => {\n    if (clipboardData) {\n      try {\n        clipboardData.clearData();\n        clipboardData.setData('text/html', html);\n        clipboardData.setData('text/plain', text);\n        clipboardData.setData(internalHtmlMime(), html);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  };\n\n  const setClipboardData = (evt, data, fallback, done) => {\n    if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n      evt.preventDefault();\n      done();\n    } else {\n      fallback(data.html, done);\n    }\n  };\n\n  const fallback = editor => (html, done) => {\n    const {\n      dom,\n      selection\n    } = editor;\n    const outer = dom.create('div', {\n      'contenteditable': 'false',\n      'data-mce-bogus': 'all'\n    });\n    const inner = dom.create('div', {\n      contenteditable: 'true'\n    }, html);\n    dom.setStyles(outer, {\n      position: 'fixed',\n      top: '0',\n      left: '-3000px',\n      width: '1000px',\n      overflow: 'hidden'\n    });\n    outer.appendChild(inner);\n    dom.add(editor.getBody(), outer);\n    const range = selection.getRng();\n    inner.focus();\n    const offscreenRange = dom.createRng();\n    offscreenRange.selectNodeContents(inner);\n    selection.setRng(offscreenRange);\n    Delay.setEditorTimeout(editor, () => {\n      selection.setRng(range);\n      dom.remove(outer);\n      done();\n    }, 0);\n  };\n\n  const getData = editor => ({\n    html: mark(editor.selection.getContent({\n      contextual: true\n    })),\n    text: editor.selection.getContent({\n      format: 'text'\n    })\n  });\n\n  const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n\n  const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n\n  const cut = editor => evt => {\n    if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n      setClipboardData(evt, getData(editor), fallback(editor), () => {\n        if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n          const rng = editor.selection.getRng();\n          Delay.setEditorTimeout(editor, () => {\n            editor.selection.setRng(rng);\n            editor.execCommand('Delete');\n          }, 0);\n        } else {\n          editor.execCommand('Delete');\n        }\n      });\n    }\n  };\n\n  const copy = editor => evt => {\n    if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n      setClipboardData(evt, getData(editor), fallback(editor), noop);\n    }\n  };\n\n  const register = editor => {\n    editor.on('cut', cut(editor));\n    editor.on('copy', copy(editor));\n  };\n\n  const getCaretRangeFromEvent = (editor, e) => {\n    var _a, _b;\n\n    return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n  };\n\n  const isPlainTextFileUrl = content => {\n    const plainTextContent = content['text/plain'];\n    return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n  };\n\n  const setFocusedRange = (editor, rng) => {\n    editor.focus();\n\n    if (rng) {\n      editor.selection.setRng(rng);\n    }\n  };\n\n  const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n\n  const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n    const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n    const inSummary = !isNull(dom.getParent(target, 'summary'));\n\n    if (inSummary) {\n      return true;\n    } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n      const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n      return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n    } else {\n      return false;\n    }\n  };\n\n  const setupSummaryDeleteByDragFix = editor => {\n    editor.on('input', e => {\n      const hasNoSummary = el => isNull(el.querySelector('summary'));\n\n      if (e.inputType === 'deleteByDrag') {\n        const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n        each$e(brokenDetailElements, details => {\n          if (isBr$6(details.firstChild)) {\n            details.firstChild.remove();\n          }\n\n          const summary = editor.dom.create('summary');\n          summary.appendChild(createPaddingBr().dom);\n          details.prepend(summary);\n        });\n      }\n    });\n  };\n\n  const setup$a = (editor, draggingInternallyState) => {\n    if (shouldPasteBlockDrop(editor)) {\n      editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n        e.preventDefault();\n        e.stopPropagation();\n      });\n    }\n\n    if (!shouldPasteDataImages(editor)) {\n      editor.on('drop', e => {\n        const dataTransfer = e.dataTransfer;\n\n        if (dataTransfer && hasImage(dataTransfer)) {\n          e.preventDefault();\n        }\n      });\n    }\n\n    editor.on('drop', e => {\n      if (e.isDefaultPrevented()) {\n        return;\n      }\n\n      const rng = getCaretRangeFromEvent(editor, e);\n\n      if (isNullable(rng)) {\n        return;\n      }\n\n      const dropContent = getDataTransferItems(e.dataTransfer);\n      const internal = hasContentType(dropContent, internalHtmlMime());\n\n      if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n        return;\n      }\n\n      const internalContent = dropContent[internalHtmlMime()];\n      const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n      const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n      const isInternalDrop = draggingInternallyState.get();\n\n      if (isInternalDrop && !needsInternalDrop) {\n        return;\n      }\n\n      if (content) {\n        e.preventDefault();\n        Delay.setEditorTimeout(editor, () => {\n          editor.undoManager.transact(() => {\n            if (internalContent || isInternalDrop && needsInternalDrop) {\n              editor.execCommand('Delete');\n            }\n\n            setFocusedRange(editor, rng);\n            const trimmedContent = trimHtml(content);\n\n            if (dropContent['text/html']) {\n              pasteHtml(editor, trimmedContent, internal, true);\n            } else {\n              pasteText(editor, trimmedContent, true);\n            }\n          });\n        });\n      }\n    });\n    editor.on('dragstart', _e => {\n      draggingInternallyState.set(true);\n    });\n    editor.on('dragover dragend', e => {\n      if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n        e.preventDefault();\n        setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n      }\n\n      if (e.type === 'dragend') {\n        draggingInternallyState.set(false);\n      }\n    });\n    setupSummaryDeleteByDragFix(editor);\n  };\n\n  const setup$9 = editor => {\n    const processEvent = f => e => {\n      f(editor, e);\n    };\n\n    const preProcess = getPastePreProcess(editor);\n\n    if (isFunction(preProcess)) {\n      editor.on('PastePreProcess', processEvent(preProcess));\n    }\n\n    const postProcess = getPastePostProcess(editor);\n\n    if (isFunction(postProcess)) {\n      editor.on('PastePostProcess', processEvent(postProcess));\n    }\n  };\n\n  const addPreProcessFilter = (editor, filterFunc) => {\n    editor.on('PastePreProcess', e => {\n      e.content = filterFunc(editor, e.content, e.internal);\n    });\n  };\n\n  const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n\n  const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n\n  const removeWebKitStyles = (editor, content, internal) => {\n    const webKitStylesOption = getPasteWebkitStyles(editor);\n\n    if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n      return content;\n    }\n\n    const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n\n    if (webKitStyles && webKitStylesOption !== 'none') {\n      const dom = editor.dom,\n            node = editor.selection.getNode();\n      content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n        const inputStyles = dom.parseStyle(dom.decode(value));\n        const outputStyles = {};\n\n        for (let i = 0; i < webKitStyles.length; i++) {\n          const inputValue = inputStyles[webKitStyles[i]];\n          let compareInput = inputValue;\n          let currentValue = dom.getStyle(node, webKitStyles[i], true);\n\n          if (/color/.test(webKitStyles[i])) {\n            compareInput = rgbToHex(compareInput);\n            currentValue = rgbToHex(currentValue);\n          }\n\n          if (currentValue !== compareInput) {\n            outputStyles[webKitStyles[i]] = inputValue;\n          }\n        }\n\n        const outputStyle = dom.serializeStyle(outputStyles, 'span');\n\n        if (outputStyle) {\n          return before + ' style=\"' + outputStyle + '\"' + after;\n        }\n\n        return before + after;\n      });\n    } else {\n      content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n    }\n\n    content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n      return before + ' style=\"' + value + '\"' + after;\n    });\n    return content;\n  };\n\n  const setup$8 = editor => {\n    if (Env.browser.isChromium() || Env.browser.isSafari()) {\n      addPreProcessFilter(editor, removeWebKitStyles);\n    }\n  };\n\n  const setup$7 = editor => {\n    const draggingInternallyState = Cell(false);\n    const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n    const pasteBin = PasteBin(editor);\n    setup$8(editor);\n    register$1(editor, pasteFormat);\n    setup$9(editor);\n    editor.on('PreInit', () => {\n      register(editor);\n      setup$a(editor, draggingInternallyState);\n      registerEventsAndFilters(editor, pasteBin, pasteFormat);\n    });\n  };\n\n  const preventSummaryToggle = editor => {\n    editor.on('click', e => {\n      if (editor.dom.getParent(e.target, 'details')) {\n        e.preventDefault();\n      }\n    });\n  };\n\n  const filterDetails = editor => {\n    editor.parser.addNodeFilter('details', elms => {\n      const initialStateOption = getDetailsInitialState(editor);\n      each$e(elms, details => {\n        if (initialStateOption === 'expanded') {\n          details.attr('open', 'open');\n        } else if (initialStateOption === 'collapsed') {\n          details.attr('open', null);\n        }\n      });\n    });\n    editor.serializer.addNodeFilter('details', elms => {\n      const serializedStateOption = getDetailsSerializedState(editor);\n      each$e(elms, details => {\n        if (serializedStateOption === 'expanded') {\n          details.attr('open', 'open');\n        } else if (serializedStateOption === 'collapsed') {\n          details.attr('open', null);\n        }\n      });\n    });\n  };\n\n  const setup$6 = editor => {\n    preventSummaryToggle(editor);\n    filterDetails(editor);\n  };\n\n  const isBr = isBr$6;\n  const isText = isText$a;\n\n  const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n\n  const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n\n  const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n\n  const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n\n  const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n\n  const findEdgeCaretCandidate = (startNode, scope, forward) => {\n    const walker = new DomTreeWalker(startNode, scope);\n    const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n    let result = startNode;\n\n    for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n      if (isCaretCandidate$3(current)) {\n        result = current;\n      }\n    }\n\n    return result;\n  };\n\n  const findClosestBlockRange = (startRng, rootNode, schema) => {\n    const startPos = CaretPosition.fromRangeStart(startRng);\n    const clickNode = startPos.getNode();\n    const scope = getClosestScope(clickNode, rootNode, schema);\n    const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n    const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n    const rng = document.createRange();\n    getClosestCef(startNode, scope).fold(() => {\n      if (isText(startNode)) {\n        rng.setStart(startNode, 0);\n      } else {\n        rng.setStartBefore(startNode);\n      }\n    }, cef => rng.setStartBefore(cef.dom));\n    getClosestCef(endNode, scope).fold(() => {\n      if (isText(endNode)) {\n        rng.setEnd(endNode, endNode.data.length);\n      } else {\n        rng.setEndAfter(endNode);\n      }\n    }, cef => rng.setEndAfter(cef.dom));\n    return rng;\n  };\n\n  const onTripleClickSelect = editor => {\n    const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n    editor.selection.setRng(normalize(rng));\n  };\n\n  const setup$5 = editor => {\n    editor.on('mousedown', e => {\n      if (e.detail >= 3) {\n        e.preventDefault();\n        onTripleClickSelect(editor);\n      }\n    });\n  };\n\n  var FakeCaretPosition;\n\n  (function (FakeCaretPosition) {\n    FakeCaretPosition['Before'] = 'before';\n    FakeCaretPosition['After'] = 'after';\n  })(FakeCaretPosition || (FakeCaretPosition = {}));\n\n  const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n\n  const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n\n  const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n\n  const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n\n  const isOverlapping = (r1, r2) => {\n    const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n    return collidesY(r1, r2) && overlap > 0.5;\n  };\n\n  const splitRectsPerAxis = (rects, y) => {\n    const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n    return boundingClientRectFromRects(intersectingRects).fold(() => [[], rects], boundingRect => {\n      const {\n        pass: horizontal,\n        fail: vertical\n      } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n      return [horizontal, vertical];\n    });\n  };\n\n  const clientInfo = (rect, clientX) => {\n    return {\n      node: rect.node,\n      position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n    };\n  };\n\n  const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n\n  const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n    const caretCandidateRect = rect => {\n      if (isCaretCandidate$3(rect.node)) {\n        return Optional.some(rect);\n      } else if (isElement$6(rect.node)) {\n        return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n      } else {\n        return Optional.none();\n      }\n    };\n\n    const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n      return caretCandidateRect(sndClosest).filter(rect => {\n        const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n        return deltaDistance < 2 && isText$a(rect.node);\n      });\n    };\n\n    const findClosestCaretCandidateNodeRect = (rects, distance) => {\n      const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n      return findMap(sortedRects, caretCandidateRect).map(closest => {\n        if (findCloserTextNode && !isText$a(closest.node) && sortedRects.length > 1) {\n          return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n        } else {\n          return closest;\n        }\n      });\n    };\n\n    const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n    const {\n      pass: above,\n      fail: below\n    } = partition$2(verticalRects, rect => rect.top < clientY);\n    return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n  };\n\n  const traverseUp = (rootElm, scope, clientX, clientY) => {\n    const helper = (scope, prevScope) => {\n      const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n\n      const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n      return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n        const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n        return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n      }).orThunk(() => {\n        const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n        return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n      });\n    };\n\n    return helper(scope, Optional.none());\n  };\n\n  const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n    const rootElm = SugarElement.fromDom(root);\n    const ownerDoc = documentOrOwner(rootElm);\n    const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n    const element = elementAtPoint.getOr(rootElm);\n    return traverseUp(rootElm, element, clientX, clientY);\n  };\n\n  const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n  const getAbsolutePosition = elm => {\n    var _a, _b;\n\n    const clientRect = elm.getBoundingClientRect();\n    const doc = elm.ownerDocument;\n    const docElem = doc.documentElement;\n    const win = doc.defaultView;\n    return {\n      top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n      left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n    };\n  };\n\n  const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n    left: 0,\n    top: 0\n  };\n\n  const getScrollPosition = editor => {\n    const body = editor.getBody();\n    return editor.inline ? {\n      left: body.scrollLeft,\n      top: body.scrollTop\n    } : {\n      left: 0,\n      top: 0\n    };\n  };\n\n  const getBodyScroll = editor => {\n    const body = editor.getBody(),\n          docElm = editor.getDoc().documentElement;\n    const inlineScroll = {\n      left: body.scrollLeft,\n      top: body.scrollTop\n    };\n    const iframeScroll = {\n      left: body.scrollLeft || docElm.scrollLeft,\n      top: body.scrollTop || docElm.scrollTop\n    };\n    return editor.inline ? inlineScroll : iframeScroll;\n  };\n\n  const getMousePosition = (editor, event) => {\n    if (event.target.ownerDocument !== editor.getDoc()) {\n      const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n      const scrollPosition = getBodyScroll(editor);\n      return {\n        left: event.pageX - iframePosition.left + scrollPosition.left,\n        top: event.pageY - iframePosition.top + scrollPosition.top\n      };\n    }\n\n    return {\n      left: event.pageX,\n      top: event.pageY\n    };\n  };\n\n  const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n    pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n    pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n  });\n\n  const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n  const getTargetProps = target => ({\n    target,\n    srcElement: target\n  });\n\n  const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({ ...mouseEvent,\n    dataTransfer,\n    type,\n    ...getTargetProps(target)\n  });\n\n  const makeDndEvent = (type, target, dataTransfer) => {\n    const fail = die('Function not supported on simulated event.');\n    const event = {\n      bubbles: true,\n      cancelBubble: false,\n      cancelable: true,\n      composed: false,\n      currentTarget: null,\n      defaultPrevented: false,\n      eventPhase: 0,\n      isTrusted: true,\n      returnValue: false,\n      timeStamp: 0,\n      type,\n      composedPath: fail,\n      initEvent: fail,\n      preventDefault: noop,\n      stopImmediatePropagation: noop,\n      stopPropagation: noop,\n      AT_TARGET: window.Event.AT_TARGET,\n      BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n      CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n      NONE: window.Event.NONE,\n      altKey: false,\n      button: 0,\n      buttons: 0,\n      clientX: 0,\n      clientY: 0,\n      ctrlKey: false,\n      metaKey: false,\n      movementX: 0,\n      movementY: 0,\n      offsetX: 0,\n      offsetY: 0,\n      pageX: 0,\n      pageY: 0,\n      relatedTarget: null,\n      screenX: 0,\n      screenY: 0,\n      shiftKey: false,\n      x: 0,\n      y: 0,\n      detail: 0,\n      view: null,\n      which: 0,\n      initUIEvent: fail,\n      initMouseEvent: fail,\n      getModifierState: fail,\n      dataTransfer,\n      ...getTargetProps(target)\n    };\n    return event;\n  };\n\n  const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n    const copy = cloneDataTransfer(dataTransfer);\n\n    if (eventType === 'dragstart') {\n      setDragstartEvent(copy);\n      setReadWriteMode(copy);\n    } else if (eventType === 'drop') {\n      setDropEvent(copy);\n      setReadOnlyMode(copy);\n    } else {\n      setDragendEvent(copy);\n      setProtectedMode(copy);\n    }\n\n    return copy;\n  };\n\n  const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n    const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n    return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n  };\n\n  const scrollPixelsPerInterval = 32;\n  const scrollIntervalValue = 100;\n  const mouseRangeToTriggerScrollInsideEditor = 8;\n  const mouseRangeToTriggerScrollOutsideEditor = 16;\n  const isContentEditableFalse$1 = isContentEditableFalse$b;\n  const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n\n  const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n\n  const isValidDropTarget = (editor, targetElement, dragElement) => {\n    if (isNullable(targetElement)) {\n      return false;\n    } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n      return false;\n    } else {\n      return editor.dom.isEditable(targetElement);\n    }\n  };\n\n  const createGhost = (editor, elm, width, height) => {\n    const dom = editor.dom;\n    const clonedElm = elm.cloneNode(true);\n    dom.setStyles(clonedElm, {\n      width,\n      height\n    });\n    dom.setAttrib(clonedElm, 'data-mce-selected', null);\n    const ghostElm = dom.create('div', {\n      'class': 'mce-drag-container',\n      'data-mce-bogus': 'all',\n      'unselectable': 'on',\n      'contenteditable': 'false'\n    });\n    dom.setStyles(ghostElm, {\n      position: 'absolute',\n      opacity: 0.5,\n      overflow: 'hidden',\n      border: 0,\n      padding: 0,\n      margin: 0,\n      width,\n      height\n    });\n    dom.setStyles(clonedElm, {\n      margin: 0,\n      boxSizing: 'border-box'\n    });\n    ghostElm.appendChild(clonedElm);\n    return ghostElm;\n  };\n\n  const appendGhostToBody = (ghostElm, bodyElm) => {\n    if (ghostElm.parentNode !== bodyElm) {\n      bodyElm.appendChild(ghostElm);\n    }\n  };\n\n  const scrollEditor = (direction, amount) => win => () => {\n    const current = direction === 'left' ? win.scrollX : win.scrollY;\n    win.scroll({\n      [direction]: current + amount,\n      behavior: 'smooth'\n    });\n  };\n\n  const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n  const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n  const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n  const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n\n  const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n    let overflowX = 0,\n        overflowY = 0;\n    ghostElm.style.left = position.pageX + 'px';\n    ghostElm.style.top = position.pageY + 'px';\n\n    if (position.pageX + width > maxX) {\n      overflowX = position.pageX + width - maxX;\n    }\n\n    if (position.pageY + height > maxY) {\n      overflowY = position.pageY + height - maxY;\n    }\n\n    ghostElm.style.width = width - overflowX + 'px';\n    ghostElm.style.height = height - overflowY + 'px';\n    const clientHeight = contentAreaContainer.clientHeight;\n    const clientWidth = contentAreaContainer.clientWidth;\n    const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n    const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n    state.on(state => {\n      state.intervalId.clear();\n\n      if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n        if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n          state.intervalId.set(scrollDown(win));\n        } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n          state.intervalId.set(scrollUp(win));\n        } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n          state.intervalId.set(scrollRight(win));\n        } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n          state.intervalId.set(scrollLeft(win));\n        } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n          state.intervalId.set(scrollDown(window));\n        } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n          state.intervalId.set(scrollUp(window));\n        } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n          state.intervalId.set(scrollRight(window));\n        } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n          state.intervalId.set(scrollLeft(window));\n        }\n      }\n    });\n  };\n\n  const removeElement = elm => {\n    if (elm && elm.parentNode) {\n      elm.parentNode.removeChild(elm);\n    }\n  };\n\n  const removeElementWithPadding = (dom, elm) => {\n    const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n    removeElement(elm);\n\n    if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n      fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n    }\n  };\n\n  const isLeftMouseButtonPressed = e => e.button === 0;\n\n  const applyRelPos = (state, position) => ({\n    pageX: position.pageX - state.relX,\n    pageY: position.pageY + 5\n  });\n\n  const start = (state, editor) => e => {\n    if (isLeftMouseButtonPressed(e)) {\n      const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n\n      if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n        const elmPos = editor.dom.getPos(ceElm);\n        const bodyElm = editor.getBody();\n        const docElm = editor.getDoc().documentElement;\n        state.set({\n          element: ceElm,\n          dataTransfer: createDataTransfer(),\n          dragging: false,\n          screenX: e.screenX,\n          screenY: e.screenY,\n          maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n          maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n          relX: e.pageX - elmPos.x,\n          relY: e.pageY - elmPos.y,\n          width: ceElm.offsetWidth,\n          height: ceElm.offsetHeight,\n          ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n          intervalId: repeatable(scrollIntervalValue)\n        });\n      }\n    }\n  };\n\n  const placeCaretAt = (editor, clientX, clientY) => {\n    editor._selectionOverrides.hideFakeCaret();\n\n    closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n      const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n\n      if (range) {\n        editor.selection.setRng(range);\n      } else {\n        editor.selection.placeCaretAt(clientX, clientY);\n      }\n    });\n  };\n\n  const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n    if (type === 'dragstart') {\n      setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n    }\n\n    const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n    const args = editor.dispatch(type, event);\n    return args;\n  };\n\n  const move = (state, editor) => {\n    const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n    editor.on('remove', throttledPlaceCaretAt.cancel);\n    const state_ = state;\n    return e => state.on(state => {\n      const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n\n      if (!state.dragging && movement > 10) {\n        const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n\n        if (isNonNullable(args.dataTransfer)) {\n          state.dataTransfer = args.dataTransfer;\n        }\n\n        if (args.isDefaultPrevented()) {\n          return;\n        }\n\n        state.dragging = true;\n        editor.focus();\n      }\n\n      if (state.dragging) {\n        const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n        const targetPos = applyRelPos(state, calc(editor, e));\n        appendGhostToBody(state.ghost, editor.getBody());\n        moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n        throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n      }\n    });\n  };\n\n  const getRawTarget = selection => {\n    const sel = selection.getSel();\n\n    if (isNonNullable(sel)) {\n      const rng = sel.getRangeAt(0);\n      const startContainer = rng.startContainer;\n      return isText$a(startContainer) ? startContainer.parentNode : startContainer;\n    } else {\n      return null;\n    }\n  };\n\n  const drop = (state, editor) => e => {\n    state.on(state => {\n      var _a;\n\n      state.intervalId.clear();\n\n      if (state.dragging) {\n        if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n          const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n          const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n\n          if (!args.isDefaultPrevented()) {\n            editor.undoManager.transact(() => {\n              removeElementWithPadding(editor.dom, state.element);\n              getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n\n              editor._selectionOverrides.hideFakeCaret();\n            });\n          }\n        }\n\n        dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n      }\n    });\n    removeDragState(state);\n  };\n\n  const stopDragging = (state, editor, e) => {\n    state.on(state => {\n      state.intervalId.clear();\n\n      if (state.dragging) {\n        e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n      }\n    });\n    removeDragState(state);\n  };\n\n  const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n\n  const removeDragState = state => {\n    state.on(state => {\n      state.intervalId.clear();\n      removeElement(state.ghost);\n    });\n    state.clear();\n  };\n\n  const bindFakeDragEvents = editor => {\n    const state = value$2();\n    const pageDom = DOMUtils.DOM;\n    const rootDocument = document;\n    const dragStartHandler = start(state, editor);\n    const dragHandler = move(state, editor);\n    const dropHandler = drop(state, editor);\n    const dragEndHandler = stop(state, editor);\n    editor.on('mousedown', dragStartHandler);\n    editor.on('mousemove', dragHandler);\n    editor.on('mouseup', dropHandler);\n    pageDom.bind(rootDocument, 'mousemove', dragHandler);\n    pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n    editor.on('remove', () => {\n      pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n      pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n    });\n    editor.on('keydown', e => {\n      if (e.keyCode === VK.ESC) {\n        stopDragging(state, editor, Optional.none());\n      }\n    });\n  };\n\n  const blockUnsupportedFileDrop = editor => {\n    const preventFileDrop = e => {\n      if (!e.isDefaultPrevented()) {\n        const dataTransfer = e.dataTransfer;\n\n        if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n          e.preventDefault();\n\n          if (e.type === 'drop') {\n            displayError(editor, 'Dropped file type is not supported');\n          }\n        }\n      }\n    };\n\n    const preventFileDropIfUIElement = e => {\n      if (isUIElement(editor, e.target)) {\n        preventFileDrop(e);\n      }\n    };\n\n    const setup = () => {\n      const pageDom = DOMUtils.DOM;\n      const dom = editor.dom;\n      const doc = document;\n      const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n      const eventNames = ['drop', 'dragover'];\n      each$e(eventNames, name => {\n        pageDom.bind(doc, name, preventFileDropIfUIElement);\n        dom.bind(editorRoot, name, preventFileDrop);\n      });\n      editor.on('remove', () => {\n        each$e(eventNames, name => {\n          pageDom.unbind(doc, name, preventFileDropIfUIElement);\n          dom.unbind(editorRoot, name, preventFileDrop);\n        });\n      });\n    };\n\n    editor.on('init', () => {\n      Delay.setEditorTimeout(editor, setup, 0);\n    });\n  };\n\n  const init$2 = editor => {\n    bindFakeDragEvents(editor);\n\n    if (shouldBlockUnsupportedDrop(editor)) {\n      blockUnsupportedFileDrop(editor);\n    }\n  };\n\n  const setup$4 = editor => {\n    const renderFocusCaret = first$1(() => {\n      if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n        const rng = editor.selection.getRng();\n\n        if (rng.collapsed) {\n          const caretRange = renderRangeCaret(editor, rng, false);\n          editor.selection.setRng(caretRange);\n        }\n      }\n    }, 0);\n    editor.on('focus', () => {\n      renderFocusCaret.throttle();\n    });\n    editor.on('blur', () => {\n      renderFocusCaret.cancel();\n    });\n  };\n\n  const setup$3 = editor => {\n    editor.on('init', () => {\n      editor.on('focusin', e => {\n        const target = e.target;\n\n        if (isMedia$2(target)) {\n          const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n          const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n\n          if (editor.selection.getNode() !== node) {\n            selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n          }\n        }\n      });\n    });\n  };\n\n  const isContentEditableFalse = isContentEditableFalse$b;\n\n  const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n\n  const SelectionOverrides = editor => {\n    const selection = editor.selection,\n          dom = editor.dom;\n    const rootNode = editor.getBody();\n    const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n    const realSelectionId = 'sel-' + dom.uniqueId();\n    const elementSelectionAttr = 'data-mce-selected';\n    let selectedElement;\n\n    const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n\n    const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n\n    const setRange = range => {\n      if (range) {\n        selection.setRng(range);\n      }\n    };\n\n    const showCaret = (direction, node, before, scrollIntoView = true) => {\n      const e = editor.dispatch('ShowCaret', {\n        target: node,\n        direction,\n        before\n      });\n\n      if (e.isDefaultPrevented()) {\n        return null;\n      }\n\n      if (scrollIntoView) {\n        selection.scrollIntoView(node, direction === -1);\n      }\n\n      return fakeCaret.show(before, node);\n    };\n\n    const showBlockCaretContainer = blockCaretContainer => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n\n    const registerEvents = () => {\n      editor.on('click', e => {\n        if (!dom.isEditable(e.target)) {\n          e.preventDefault();\n          editor.focus();\n        }\n      });\n      editor.on('blur NewBlock', removeElementSelection);\n      editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n      editor.on('tap', e => {\n        const targetElm = e.target;\n        const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n\n        if (isContentEditableFalse(contentEditableRoot)) {\n          e.preventDefault();\n          selectNode(editor, contentEditableRoot).each(setElementSelection);\n        } else if (isFakeSelectionTargetElement(targetElm)) {\n          selectNode(editor, targetElm).each(setElementSelection);\n        }\n      }, true);\n      editor.on('mousedown', e => {\n        const targetElm = e.target;\n\n        if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n          return;\n        }\n\n        if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n          return;\n        }\n\n        removeElementSelection();\n        hideFakeCaret();\n        const closestContentEditable = getContentEditableRoot(editor, targetElm);\n\n        if (isContentEditableFalse(closestContentEditable)) {\n          e.preventDefault();\n          selectNode(editor, closestContentEditable).each(setElementSelection);\n        } else {\n          closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n            e.preventDefault();\n            const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n            setRange(range);\n\n            if (isHTMLElement(closestContentEditable)) {\n              closestContentEditable.focus();\n            } else {\n              editor.getBody().focus();\n            }\n          });\n        }\n      });\n      editor.on('keypress', e => {\n        if (VK.modifierPressed(e)) {\n          return;\n        }\n\n        if (isContentEditableFalse(selection.getNode())) {\n          e.preventDefault();\n        }\n      });\n      editor.on('GetSelectionRange', e => {\n        let rng = e.range;\n\n        if (selectedElement) {\n          if (!selectedElement.parentNode) {\n            selectedElement = null;\n            return;\n          }\n\n          rng = rng.cloneRange();\n          rng.selectNode(selectedElement);\n          e.range = rng;\n        }\n      });\n      editor.on('SetSelectionRange', e => {\n        e.range = normalizeVoidElementSelection(e.range);\n        const rng = setElementSelection(e.range, e.forward);\n\n        if (rng) {\n          e.range = rng;\n        }\n      });\n\n      const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n\n      editor.on('AfterSetSelectionRange', e => {\n        const rng = e.range;\n        const parent = rng.startContainer.parentElement;\n\n        if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n          hideFakeCaret();\n        }\n\n        if (!isFakeSelectionElement(parent)) {\n          removeElementSelection();\n        }\n      });\n      init$2(editor);\n      setup$4(editor);\n      setup$3(editor);\n    };\n\n    const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n\n    const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n\n    const normalizeVoidElementSelection = rng => {\n      const voidElements = editor.schema.getVoidElements();\n      const newRng = dom.createRng();\n      const startContainer = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endContainer = rng.endContainer;\n      const endOffset = rng.endOffset;\n\n      if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n        if (startOffset === 0) {\n          newRng.setStartBefore(startContainer);\n        } else {\n          newRng.setStartAfter(startContainer);\n        }\n      } else {\n        newRng.setStart(startContainer, startOffset);\n      }\n\n      if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n        if (endOffset === 0) {\n          newRng.setEndBefore(endContainer);\n        } else {\n          newRng.setEndAfter(endContainer);\n        }\n      } else {\n        newRng.setEnd(endContainer, endOffset);\n      }\n\n      return newRng;\n    };\n\n    const setupOffscreenSelection = (node, targetClone) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = editor.getDoc();\n      const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n        const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n        set$3(newContainer, 'id', realSelectionId);\n        append$1(body, newContainer);\n        return newContainer;\n      });\n      const newRange = dom.createRng();\n      empty(realSelectionContainer);\n      append(realSelectionContainer, [SugarElement.fromText(nbsp, doc), SugarElement.fromDom(targetClone), SugarElement.fromText(nbsp, doc)]);\n      newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n      newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n      setAll(realSelectionContainer, {\n        top: dom.getPos(node, editor.getBody()).y + 'px'\n      });\n      focus$1(realSelectionContainer);\n      const sel = selection.getSel();\n\n      if (sel) {\n        sel.removeAllRanges();\n        sel.addRange(newRange);\n      }\n\n      return newRange;\n    };\n\n    const selectElement = elm => {\n      const targetClone = elm.cloneNode(true);\n      const e = editor.dispatch('ObjectSelected', {\n        target: elm,\n        targetClone\n      });\n\n      if (e.isDefaultPrevented()) {\n        return null;\n      }\n\n      const range = setupOffscreenSelection(elm, e.targetClone);\n      const nodeElm = SugarElement.fromDom(elm);\n      each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${elementSelectionAttr}]`), elm => {\n        if (!eq(nodeElm, elm)) {\n          remove$a(elm, elementSelectionAttr);\n        }\n      });\n\n      if (!dom.getAttrib(elm, elementSelectionAttr)) {\n        elm.setAttribute(elementSelectionAttr, '1');\n      }\n\n      selectedElement = elm;\n      hideFakeCaret();\n      return range;\n    };\n\n    const setElementSelection = (range, forward) => {\n      if (!range) {\n        return null;\n      }\n\n      if (range.collapsed) {\n        if (!isRangeInCaretContainer(range)) {\n          const dir = forward ? 1 : -1;\n          const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n          const beforeNode = caretPosition.getNode(!forward);\n\n          if (isNonNullable(beforeNode)) {\n            if (isFakeCaretTarget(beforeNode)) {\n              return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n            }\n\n            if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n              const rng = dom.createRng();\n              rng.setStart(beforeNode, 0);\n              rng.setEnd(beforeNode, 0);\n              return rng;\n            }\n          }\n\n          const afterNode = caretPosition.getNode(forward);\n\n          if (isNonNullable(afterNode)) {\n            if (isFakeCaretTarget(afterNode)) {\n              return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n            }\n\n            if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n              const rng = dom.createRng();\n              rng.setStart(afterNode, 1);\n              rng.setEnd(afterNode, 1);\n              return rng;\n            }\n          }\n        }\n\n        return null;\n      }\n\n      let startContainer = range.startContainer;\n      let startOffset = range.startOffset;\n      const endOffset = range.endOffset;\n\n      if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n        startContainer = startContainer.parentNode;\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n\n      if (!isElement$6(startContainer)) {\n        return null;\n      }\n\n      if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n        const node = startContainer.childNodes[startOffset];\n\n        if (isFakeSelectionTargetElement(node)) {\n          return selectElement(node);\n        }\n      }\n\n      return null;\n    };\n\n    const removeElementSelection = () => {\n      if (selectedElement) {\n        selectedElement.removeAttribute(elementSelectionAttr);\n      }\n\n      descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n      selectedElement = null;\n    };\n\n    const destroy = () => {\n      fakeCaret.destroy();\n      selectedElement = null;\n    };\n\n    const hideFakeCaret = () => {\n      fakeCaret.hide();\n    };\n\n    if (!isRtc(editor)) {\n      registerEvents();\n    }\n\n    return {\n      showCaret,\n      showBlockCaretContainer,\n      hideFakeCaret,\n      destroy\n    };\n  };\n\n  const getNormalizedTextOffset = (container, offset) => {\n    let normalizedOffset = offset;\n\n    for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {\n      normalizedOffset += node.data.length;\n    }\n\n    return normalizedOffset;\n  };\n\n  const generatePath = (dom, root, node, offset, normalized) => {\n    if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n      return [];\n    }\n\n    const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n    let current = node;\n\n    while (current !== root && current.parentNode) {\n      p.push(dom.nodeIndex(current, normalized));\n      current = current.parentNode;\n    }\n\n    return current === root ? p.reverse() : [];\n  };\n\n  const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n    const start = generatePath(dom, root, startNode, startOffset, normalized);\n    const end = generatePath(dom, root, endNode, endOffset, normalized);\n    return {\n      start,\n      end\n    };\n  };\n\n  const resolvePath = (root, path) => {\n    const nodePath = path.slice();\n    const offset = nodePath.pop();\n\n    if (!isNumber(offset)) {\n      return Optional.none();\n    } else {\n      const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n      return resolvedNode.bind(node => {\n        if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            node,\n            offset\n          });\n        }\n      });\n    }\n  };\n\n  const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n    node: startNode,\n    offset: startOffset\n  }) => resolvePath(root, range.end).map(({\n    node: endNode,\n    offset: endOffset\n  }) => {\n    const rng = document.createRange();\n    rng.setStart(startNode, startOffset);\n    rng.setEnd(endNode, endOffset);\n    return rng;\n  }));\n\n  const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n\n  const cleanEmptyNodes = (dom, node, isRoot) => {\n    if (node && dom.isEmpty(node) && !isRoot(node)) {\n      const parent = node.parentNode;\n      dom.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));\n      cleanEmptyNodes(dom, parent, isRoot);\n    }\n  };\n\n  const deleteRng = (dom, rng, isRoot, clean = true) => {\n    const startParent = rng.startContainer.parentNode;\n    const endParent = rng.endContainer.parentNode;\n    rng.deleteContents();\n\n    if (clean && !isRoot(rng.startContainer)) {\n      if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {\n        dom.remove(rng.startContainer);\n      }\n\n      if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {\n        dom.remove(rng.endContainer);\n      }\n\n      cleanEmptyNodes(dom, startParent, isRoot);\n\n      if (startParent !== endParent) {\n        cleanEmptyNodes(dom, endParent, isRoot);\n      }\n    }\n  };\n\n  const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n\n  const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n    const dynamicPatterns = patternSet.dynamicPatternsLookup({\n      text: beforeText,\n      block\n    });\n    return { ...patternSet,\n      blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n      inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n    };\n  };\n\n  const getBeforeText = (dom, block, node, offset) => {\n    const rng = dom.createRng();\n    rng.setStart(block, 0);\n    rng.setEnd(node, offset);\n    return rng.toString();\n  };\n\n  const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n\n  const stripPattern = (dom, block, pattern) => {\n    const firstTextNode = textAfter(block, 0, block);\n    firstTextNode.each(spot => {\n      const node = spot.container;\n      scanRight(node, pattern.start.length, block).each(end => {\n        const rng = dom.createRng();\n        rng.setStart(node, 0);\n        rng.setEnd(end.container, end.offset);\n        deleteRng(dom, rng, e => e === block);\n      });\n      const text = SugarElement.fromDom(node);\n      const textContent = get$3(text);\n\n      if (startsWithSingleSpace(textContent)) {\n        set(text, textContent.slice(1));\n      }\n    });\n  };\n\n  const applyPattern$1 = (editor, match) => {\n    const dom = editor.dom;\n    const pattern = match.pattern;\n    const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n\n    const isBlockFormatName = (name, formatter) => {\n      const formatSet = formatter.get(name);\n      return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n    };\n\n    getParentBlock(editor, rng).each(block => {\n      if (pattern.type === 'block-format') {\n        if (isBlockFormatName(pattern.format, editor.formatter)) {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.formatter.apply(pattern.format);\n          });\n        }\n      } else if (pattern.type === 'block-command') {\n        editor.undoManager.transact(() => {\n          stripPattern(editor.dom, block, pattern);\n          editor.execCommand(pattern.cmd, false, pattern.value);\n        });\n      }\n    });\n    return true;\n  };\n\n  const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n\n  const findPattern$1 = (patterns, text) => {\n    const sortedPatterns = sortPatterns$1(patterns);\n    const nuText = text.replace(nbsp, ' ');\n    return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n  };\n\n  const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {\n    var _a;\n\n    const dom = editor.dom;\n    const forcedRootBlock = getForcedRootBlock(editor);\n\n    if (!dom.is(block, forcedRootBlock)) {\n      return [];\n    }\n\n    const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n    return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {\n      if (Tools.trim(blockText).length === pattern.start.length) {\n        return [];\n      }\n\n      return [{\n        pattern,\n        range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n      }];\n    }).getOr([]);\n  };\n\n  const applyMatches$1 = (editor, matches) => {\n    if (matches.length === 0) {\n      return;\n    }\n\n    const bookmark = editor.selection.getBookmark();\n    each$e(matches, match => applyPattern$1(editor, match));\n    editor.selection.moveToBookmark(bookmark);\n  };\n\n  const newMarker = (dom, id) => dom.create('span', {\n    'data-mce-type': 'bookmark',\n    id\n  });\n\n  const rangeFromMarker = (dom, marker) => {\n    const rng = dom.createRng();\n    rng.setStartAfter(marker.start);\n    rng.setEndBefore(marker.end);\n    return rng;\n  };\n\n  const createMarker = (dom, markerPrefix, pathRange) => {\n    const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n    const startNode = rng.startContainer;\n    const endNode = rng.endContainer;\n    const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n    const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n    const startParentNode = textStart.parentNode;\n    const endParentNode = textEnd.parentNode;\n    return {\n      prefix: markerPrefix,\n      end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n      start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n    };\n  };\n\n  const removeMarker = (dom, marker, isRoot) => {\n    cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n    cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n  };\n\n  const isReplacementPattern = pattern => pattern.start.length === 0;\n\n  const matchesPattern = patternContent => (element, offset) => {\n    const text = element.data;\n    const searchText = text.substring(0, offset);\n    const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n    const startIndex = searchText.lastIndexOf(patternContent);\n\n    if (startIndex !== -1) {\n      return startIndex + patternContent.length;\n    } else if (startEndIndex !== -1) {\n      return startEndIndex + 1;\n    } else {\n      return -1;\n    }\n  };\n\n  const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n    const startPattern = pattern.start;\n    const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n    return startSpot.bind(spot => {\n      var _a, _b;\n\n      const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n      const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n\n      if (isCompleteMatch) {\n        const rng = dom.createRng();\n        rng.setStart(spot.container, spot.offset - startPattern.length);\n        rng.setEnd(spot.container, spot.offset);\n        return Optional.some(rng);\n      } else {\n        const offset = spot.offset - startPattern.length;\n        return scanLeft(spot.container, offset, block).map(nextSpot => {\n          const rng = dom.createRng();\n          rng.setStart(nextSpot.container, nextSpot.offset);\n          rng.setEnd(spot.container, spot.offset);\n          return rng;\n        }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n      }\n    });\n  };\n\n  const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n    if (pattern.start.length === 0 && !requireGap) {\n      const rng = dom.createRng();\n      rng.setStart(node, offset);\n      rng.setEnd(node, offset);\n      return Optional.some(rng);\n    }\n\n    return textBefore(node, offset, block).bind(spot => {\n      const start = findPatternStartFromSpot(dom, pattern, block, spot);\n      return start.bind(startRange => {\n        var _a;\n\n        if (requireGap) {\n          if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n            return Optional.none();\n          } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n            return Optional.none();\n          }\n        }\n\n        return Optional.some(startRange);\n      });\n    });\n  };\n\n  const findPattern = (editor, block, details, normalizedMatches) => {\n    const dom = editor.dom;\n    const root = dom.getRoot();\n    const pattern = details.pattern;\n    const endNode = details.position.container;\n    const endOffset = details.position.offset;\n    return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n      const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n\n      if (isReplacementPattern(pattern)) {\n        return Optional.some({\n          matches: [{\n            pattern,\n            startRng: endPathRng,\n            endRng: endPathRng\n          }],\n          position: spot\n        });\n      } else {\n        const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n        const results = resultsOpt.getOr({\n          matches: [],\n          position: spot\n        });\n        const pos = results.position;\n        const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n        return start.map(startRng => {\n          const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n          return {\n            matches: results.matches.concat([{\n              pattern,\n              startRng: startPathRng,\n              endRng: endPathRng\n            }]),\n            position: point(startRng.startContainer, startRng.startOffset)\n          };\n        });\n      }\n    });\n  };\n\n  const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n    const dom = editor.dom;\n    return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n      const text = getBeforeText(dom, block, node, offset);\n\n      for (let i = 0; i < patterns.length; i++) {\n        const pattern = patterns[i];\n\n        if (!endsWith(text, pattern.end)) {\n          continue;\n        }\n\n        const patternsWithoutCurrent = patterns.slice();\n        patternsWithoutCurrent.splice(i, 1);\n        const result = findPattern(editor, block, {\n          pattern,\n          remainingPatterns: patternsWithoutCurrent,\n          position: endSpot\n        }, normalizedMatches);\n\n        if (result.isNone() && offset > 0) {\n          return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n        }\n\n        if (result.isSome()) {\n          return result;\n        }\n      }\n\n      return Optional.none();\n    });\n  };\n\n  const applyPattern = (editor, pattern, patternRange) => {\n    editor.selection.setRng(patternRange);\n\n    if (pattern.type === 'inline-format') {\n      each$e(pattern.format, format => {\n        editor.formatter.apply(format);\n      });\n    } else {\n      editor.execCommand(pattern.cmd, false, pattern.value);\n    }\n  };\n\n  const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n    const markerRange = rangeFromMarker(editor.dom, marker);\n    deleteRng(editor.dom, markerRange, isRoot);\n    applyPattern(editor, pattern, markerRange);\n  };\n\n  const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n    const dom = editor.dom;\n    const markerEndRange = rangeFromMarker(dom, endMarker);\n    const markerStartRange = rangeFromMarker(dom, startMarker);\n    deleteRng(dom, markerStartRange, isRoot);\n    deleteRng(dom, markerEndRange, isRoot);\n    const patternMarker = {\n      prefix: startMarker.prefix,\n      start: startMarker.end,\n      end: endMarker.start\n    };\n    const patternRange = rangeFromMarker(dom, patternMarker);\n    applyPattern(editor, pattern, patternRange);\n  };\n\n  const addMarkers = (dom, matches) => {\n    const markerPrefix = generate$1('mce_textpattern');\n    const matchesWithEnds = foldr(matches, (acc, match) => {\n      const endMarker = createMarker(dom, markerPrefix + `_end${acc.length}`, match.endRng);\n      return acc.concat([{ ...match,\n        endMarker\n      }]);\n    }, []);\n    return foldr(matchesWithEnds, (acc, match) => {\n      const idx = matchesWithEnds.length - acc.length - 1;\n      const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${idx}`, match.startRng);\n      return acc.concat([{ ...match,\n        startMarker\n      }]);\n    }, []);\n  };\n\n  const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n\n  const getBestMatches = (matches, matchesWithSortedPatterns) => {\n    const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n\n    if (matches.length === matchesWithSortedPatterns.length) {\n      if (hasSameMatches) {\n        return matches;\n      } else {\n        return matchesWithSortedPatterns;\n      }\n    }\n\n    return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n  };\n\n  const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {\n    const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n    const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n    return getBestMatches(matches, matchesWithSortedPatterns);\n  };\n\n  const applyMatches = (editor, matches) => {\n    if (matches.length === 0) {\n      return;\n    }\n\n    const dom = editor.dom;\n    const bookmark = editor.selection.getBookmark();\n    const matchesWithMarkers = addMarkers(dom, matches);\n    each$e(matchesWithMarkers, match => {\n      const block = dom.getParent(match.startMarker.start, dom.isBlock);\n\n      const isRoot = node => node === block;\n\n      if (isReplacementPattern(match.pattern)) {\n        applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n      } else {\n        applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n      }\n\n      removeMarker(dom, match.endMarker, isRoot);\n      removeMarker(dom, match.startMarker, isRoot);\n    });\n    editor.selection.moveToBookmark(bookmark);\n  };\n\n  const handleEnter = (editor, patternSet) => {\n    const rng = editor.selection.getRng();\n    return getParentBlock(editor, rng).map(block => {\n      var _a;\n\n      const offset = Math.max(0, rng.startOffset);\n      const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n      const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n      const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n\n      if (blockMatches.length > 0 || inlineMatches.length > 0) {\n        editor.undoManager.add();\n        editor.undoManager.extra(() => {\n          editor.execCommand('mceInsertNewLine');\n        }, () => {\n          insert$5(editor);\n          applyMatches(editor, inlineMatches);\n          applyMatches$1(editor, blockMatches);\n          const range = editor.selection.getRng();\n          const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n          editor.execCommand('mceInsertNewLine');\n          spot.each(s => {\n            const node = s.container;\n\n            if (node.data.charAt(s.offset - 1) === zeroWidth) {\n              node.deleteData(s.offset - 1, 1);\n              cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n            }\n          });\n        });\n        return true;\n      }\n\n      return false;\n    }).getOr(false);\n  };\n\n  const handleInlineKey = (editor, patternSet) => {\n    const rng = editor.selection.getRng();\n    getParentBlock(editor, rng).map(block => {\n      const offset = Math.max(0, rng.startOffset - 1);\n      const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n      const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n      const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n\n      if (inlineMatches.length > 0) {\n        editor.undoManager.transact(() => {\n          applyMatches(editor, inlineMatches);\n        });\n      }\n    });\n  };\n\n  const checkKeyEvent = (codes, event, predicate) => {\n    for (let i = 0; i < codes.length; i++) {\n      if (predicate(codes[i], event)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n    return code === event.keyCode && !VK.modifierPressed(event);\n  });\n\n  const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n    return chr.charCodeAt(0) === event.charCode;\n  });\n\n  const setup$2 = editor => {\n    const charCodes = [',', '.', ';', ':', '!', '?'];\n    const keyCodes = [32];\n\n    const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));\n\n    const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n\n    editor.on('keydown', e => {\n      if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {\n        const patternSet = getPatternSet();\n        const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n\n        if (hasPatterns && handleEnter(editor, patternSet)) {\n          e.preventDefault();\n        }\n      }\n    }, true);\n\n    const handleInlineTrigger = () => {\n      if (editor.selection.isCollapsed()) {\n        const patternSet = getPatternSet();\n        const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n\n        if (hasPatterns) {\n          handleInlineKey(editor, patternSet);\n        }\n      }\n    };\n\n    editor.on('keyup', e => {\n      if (checkKeyCode(keyCodes, e)) {\n        handleInlineTrigger();\n      }\n    });\n    editor.on('keypress', e => {\n      if (checkCharCode(charCodes, e)) {\n        Delay.setEditorTimeout(editor, handleInlineTrigger);\n      }\n    });\n  };\n\n  const setup$1 = editor => {\n    setup$2(editor);\n  };\n\n  const Quirks = editor => {\n    const each = Tools.each;\n    const BACKSPACE = VK.BACKSPACE,\n          DELETE = VK.DELETE,\n          dom = editor.dom,\n          selection = editor.selection,\n          parser = editor.parser;\n    const browser = Env.browser;\n    const isGecko = browser.isFirefox();\n    const isWebKit = browser.isChromium() || browser.isSafari();\n    const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n\n    const setEditorCommandState = (cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {}\n    };\n\n    const isDefaultPrevented = e => {\n      return e.isDefaultPrevented();\n    };\n\n    const emptyEditorWhenDeleting = () => {\n      const serializeRng = rng => {\n        const body = dom.create('body');\n        const contents = rng.cloneContents();\n        body.appendChild(contents);\n        return selection.serializer.serialize(body, {\n          format: 'html'\n        });\n      };\n\n      const allContentsSelected = rng => {\n        const selection = serializeRng(rng);\n        const allRng = dom.createRng();\n        allRng.selectNode(editor.getBody());\n        const allSelection = serializeRng(allRng);\n        return selection === allSelection;\n      };\n\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n\n        if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n          const isCollapsed = editor.selection.isCollapsed();\n          const body = editor.getBody();\n\n          if (isCollapsed && !isEmpty$2(SugarElement.fromDom(body))) {\n            return;\n          }\n\n          if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n            return;\n          }\n\n          e.preventDefault();\n          editor.setContent('');\n\n          if (body.firstChild && dom.isBlock(body.firstChild)) {\n            editor.selection.setCursorLocation(body.firstChild, 0);\n          } else {\n            editor.selection.setCursorLocation(body, 0);\n          }\n\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const selectAll = () => {\n      editor.shortcuts.add('meta+a', null, 'SelectAll');\n    };\n\n    const documentElementEditingFocus = () => {\n      if (!editor.inline) {\n        dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n          let rng;\n\n          if (e.target === editor.getDoc().documentElement) {\n            rng = selection.getRng();\n            editor.getBody().focus();\n\n            if (e.type === 'mousedown') {\n              if (isCaretContainer$2(rng.startContainer)) {\n                return;\n              }\n\n              selection.placeCaretAt(e.clientX, e.clientY);\n            } else {\n              selection.setRng(rng);\n            }\n          }\n        });\n      }\n    };\n\n    const removeHrOnBackspace = () => {\n      editor.on('keydown', e => {\n        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n          if (!editor.getBody().getElementsByTagName('hr').length) {\n            return;\n          }\n\n          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n            const node = selection.getNode();\n            const previousSibling = node.previousSibling;\n\n            if (node.nodeName === 'HR') {\n              dom.remove(node);\n              e.preventDefault();\n              return;\n            }\n\n            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n              dom.remove(previousSibling);\n              e.preventDefault();\n            }\n          }\n        }\n      });\n    };\n\n    const focusBody = () => {\n      if (!Range.prototype.getClientRects) {\n        editor.on('mousedown', e => {\n          if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n            const body = editor.getBody();\n            body.blur();\n            Delay.setEditorTimeout(editor, () => {\n              body.focus();\n            });\n          }\n        });\n      }\n    };\n\n    const selectControlElements = () => {\n      const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n      editor.on('click', e => {\n        const target = e.target;\n\n        if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n          e.preventDefault();\n          editor.selection.select(target);\n          editor.nodeChanged();\n        }\n\n        if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n          e.preventDefault();\n          selection.select(target);\n        }\n      });\n    };\n\n    const removeStylesWhenDeletingAcrossBlockElements = () => {\n      const getAttributeApplyFunction = () => {\n        const template = dom.getAttribs(selection.getStart().cloneNode(false));\n        return () => {\n          const target = selection.getStart();\n\n          if (target !== editor.getBody()) {\n            dom.setAttrib(target, 'style', null);\n            each(template, attr => {\n              target.setAttributeNode(attr.cloneNode(true));\n            });\n          }\n        };\n      };\n\n      const isSelectionAcrossElements = () => {\n        return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n      };\n\n      editor.on('keypress', e => {\n        let applyAttributes;\n\n        if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n          applyAttributes = getAttributeApplyFunction();\n          editor.getDoc().execCommand('delete', false);\n          applyAttributes();\n          e.preventDefault();\n          return false;\n        } else {\n          return true;\n        }\n      });\n      dom.bind(editor.getDoc(), 'cut', e => {\n        if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n          const applyAttributes = getAttributeApplyFunction();\n          Delay.setEditorTimeout(editor, () => {\n            applyAttributes();\n          });\n        }\n      });\n    };\n\n    const disableBackspaceIntoATable = () => {\n      editor.on('keydown', e => {\n        if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n          if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n            const previousSibling = selection.getNode().previousSibling;\n\n            if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n              e.preventDefault();\n              return false;\n            }\n          }\n        }\n\n        return true;\n      });\n    };\n\n    const removeBlockQuoteOnBackSpace = () => {\n      editor.on('keydown', e => {\n        if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n          return;\n        }\n\n        let rng = selection.getRng();\n        const container = rng.startContainer;\n        const offset = rng.startOffset;\n        const root = dom.getRoot();\n        let parent = container;\n\n        if (!rng.collapsed || offset !== 0) {\n          return;\n        }\n\n        while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n          parent = parent.parentNode;\n        }\n\n        if (parent.nodeName === 'BLOCKQUOTE') {\n          editor.formatter.toggle('blockquote', undefined, parent);\n          rng = dom.createRng();\n          rng.setStart(container, 0);\n          rng.setEnd(container, 0);\n          selection.setRng(rng);\n        }\n      });\n    };\n\n    const setGeckoEditingOptions = () => {\n      const setOpts = () => {\n        setEditorCommandState('StyleWithCSS', false);\n        setEditorCommandState('enableInlineTableEditing', false);\n\n        if (!getObjectResizing(editor)) {\n          setEditorCommandState('enableObjectResizing', false);\n        }\n      };\n\n      if (!isReadOnly$1(editor)) {\n        editor.on('BeforeExecCommand mousedown', setOpts);\n      }\n    };\n\n    const addBrAfterLastLinks = () => {\n      const fixLinks = () => {\n        each(dom.select('a:not([data-mce-block])'), node => {\n          var _a;\n\n          let parentNode = node.parentNode;\n          const root = dom.getRoot();\n\n          if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n            while (parentNode && !dom.isBlock(parentNode)) {\n              if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                return;\n              }\n\n              parentNode = parentNode.parentNode;\n            }\n\n            dom.add(parentNode, 'br', {\n              'data-mce-bogus': 1\n            });\n          }\n        });\n      };\n\n      editor.on('SetContent ExecCommand', e => {\n        if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n          fixLinks();\n        }\n      });\n    };\n\n    const setDefaultBlockType = () => {\n      editor.on('init', () => {\n        setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n      });\n    };\n\n    const isAllContentSelected = editor => {\n      const body = editor.getBody();\n      const rng = editor.selection.getRng();\n      return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n    };\n\n    const normalizeSelection = () => {\n      editor.on('keyup focusin mouseup', e => {\n        if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n          selection.normalize();\n        }\n      }, true);\n    };\n\n    const showBrokenImageIcon = () => {\n      editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n    };\n\n    const restoreFocusOnKeyDown = () => {\n      if (!editor.inline) {\n        editor.on('keydown', () => {\n          if (document.activeElement === document.body) {\n            editor.getWin().focus();\n          }\n        });\n      }\n    };\n\n    const bodyHeight = () => {\n      if (!editor.inline) {\n        editor.contentStyles.push('body {min-height: 150px}');\n        editor.on('click', e => {\n          let rng;\n\n          if (e.target.nodeName === 'HTML') {\n            rng = editor.selection.getRng();\n            editor.getBody().focus();\n            editor.selection.setRng(rng);\n            editor.selection.normalize();\n            editor.nodeChanged();\n          }\n        });\n      }\n    };\n\n    const blockCmdArrowNavigation = () => {\n      if (isMac) {\n        editor.on('keydown', e => {\n          if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n            e.preventDefault();\n            const selection = editor.selection.getSel();\n            selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n          }\n        });\n      }\n    };\n\n    const tapLinksAndImages = () => {\n      editor.on('click', e => {\n        let elm = e.target;\n\n        do {\n          if (elm.tagName === 'A') {\n            e.preventDefault();\n            return;\n          }\n        } while (elm = elm.parentNode);\n      });\n      editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n    };\n\n    const blockFormSubmitInsideEditor = () => {\n      editor.on('init', () => {\n        editor.dom.bind(editor.getBody(), 'submit', e => {\n          e.preventDefault();\n        });\n      });\n    };\n\n    const removeAppleInterchangeBrs = () => {\n      parser.addNodeFilter('br', nodes => {\n        let i = nodes.length;\n\n        while (i--) {\n          if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n            nodes[i].remove();\n          }\n        }\n      });\n    };\n\n    const refreshContentEditable = noop;\n\n    const isHidden = () => {\n      if (!isGecko || editor.removed) {\n        return false;\n      }\n\n      const sel = editor.selection.getSel();\n      return !sel || !sel.rangeCount || sel.rangeCount === 0;\n    };\n\n    const setupRtc = () => {\n      if (isWebKit) {\n        documentElementEditingFocus();\n        selectControlElements();\n        blockFormSubmitInsideEditor();\n        selectAll();\n\n        if (isiOS) {\n          restoreFocusOnKeyDown();\n          bodyHeight();\n          tapLinksAndImages();\n        }\n      }\n\n      if (isGecko) {\n        focusBody();\n        setGeckoEditingOptions();\n        showBrokenImageIcon();\n        blockCmdArrowNavigation();\n      }\n    };\n\n    const dropDragEndEvent = () => {\n      editor.on('drop', event => {\n        var _a;\n\n        const data = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n\n        if (isString(data) && /^<img[^>]*>$/.test(data)) {\n          editor.dispatch('dragend', new window.DragEvent('dragend', event));\n        }\n      });\n    };\n\n    const setup = () => {\n      removeBlockQuoteOnBackSpace();\n      emptyEditorWhenDeleting();\n\n      if (!Env.windowsPhone) {\n        normalizeSelection();\n      }\n\n      if (isWebKit) {\n        documentElementEditingFocus();\n        selectControlElements();\n        setDefaultBlockType();\n        blockFormSubmitInsideEditor();\n        disableBackspaceIntoATable();\n        removeAppleInterchangeBrs();\n\n        if (isiOS) {\n          restoreFocusOnKeyDown();\n          bodyHeight();\n          tapLinksAndImages();\n        } else {\n          selectAll();\n        }\n      }\n\n      if (isGecko) {\n        removeHrOnBackspace();\n        focusBody();\n        removeStylesWhenDeletingAcrossBlockElements();\n        setGeckoEditingOptions();\n        addBrAfterLastLinks();\n        showBrokenImageIcon();\n        blockCmdArrowNavigation();\n        disableBackspaceIntoATable();\n        dropDragEndEvent();\n      }\n    };\n\n    if (isRtc(editor)) {\n      setupRtc();\n    } else {\n      setup();\n    }\n\n    return {\n      refreshContentEditable,\n      isHidden\n    };\n  };\n\n  const DOM$6 = DOMUtils.DOM;\n\n  const appendStyle = (editor, text) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    const container = getStyleContainer(getRootNode(body));\n    const style = SugarElement.fromTag('style');\n    set$3(style, 'type', 'text/css');\n    append$1(style, SugarElement.fromText(text));\n    append$1(container, style);\n    editor.on('remove', () => {\n      remove$5(style);\n    });\n  };\n\n  const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n\n  const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n\n  const mkParserSettings = editor => {\n    const getOption = editor.options.get;\n    const blobCache = editor.editorUpload.blobCache;\n    return removeUndefined({\n      allow_conditional_comments: getOption('allow_conditional_comments'),\n      allow_html_data_urls: getOption('allow_html_data_urls'),\n      allow_svg_data_urls: getOption('allow_svg_data_urls'),\n      allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n      allow_script_urls: getOption('allow_script_urls'),\n      allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n      convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n      convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n      fix_list_elements: getOption('fix_list_elements'),\n      font_size_legacy_values: getOption('font_size_legacy_values'),\n      forced_root_block: getOption('forced_root_block'),\n      forced_root_block_attrs: getOption('forced_root_block_attrs'),\n      preserve_cdata: getOption('preserve_cdata'),\n      inline_styles: getOption('inline_styles'),\n      root_name: getRootName(editor),\n      sandbox_iframes: getOption('sandbox_iframes'),\n      sanitize: getOption('xss_sanitization'),\n      validate: true,\n      blob_cache: blobCache,\n      document: editor.getDoc()\n    });\n  };\n\n  const mkSchemaSettings = editor => {\n    const getOption = editor.options.get;\n    return removeUndefined({\n      custom_elements: getOption('custom_elements'),\n      extended_valid_elements: getOption('extended_valid_elements'),\n      invalid_elements: getOption('invalid_elements'),\n      invalid_styles: getOption('invalid_styles'),\n      schema: getOption('schema'),\n      valid_children: getOption('valid_children'),\n      valid_classes: getOption('valid_classes'),\n      valid_elements: getOption('valid_elements'),\n      valid_styles: getOption('valid_styles'),\n      verify_html: getOption('verify_html'),\n      padd_empty_block_inline_children: getOption('format_empty_lines')\n    });\n  };\n\n  const mkSerializerSettings = editor => {\n    const getOption = editor.options.get;\n    return { ...mkParserSettings(editor),\n      ...mkSchemaSettings(editor),\n      ...removeUndefined({\n        remove_trailing_brs: getOption('remove_trailing_brs'),\n        pad_empty_with_br: getOption('pad_empty_with_br'),\n        url_converter: getOption('url_converter'),\n        url_converter_scope: getOption('url_converter_scope'),\n        element_format: getOption('element_format'),\n        entities: getOption('entities'),\n        entity_encoding: getOption('entity_encoding'),\n        indent: getOption('indent'),\n        indent_after: getOption('indent_after'),\n        indent_before: getOption('indent_before')\n      })\n    };\n  };\n\n  const createParser = editor => {\n    const parser = DomParser(mkParserSettings(editor), editor.schema);\n    parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n      const dom = editor.dom;\n      const internalName = 'data-mce-' + name;\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        let value = node.attr(name);\n\n        if (value && !node.attr(internalName)) {\n          if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n            continue;\n          }\n\n          if (name === 'style') {\n            value = dom.serializeStyle(dom.parseStyle(value), node.name);\n\n            if (!value.length) {\n              value = null;\n            }\n\n            node.attr(internalName, value);\n            node.attr(name, value);\n          } else if (name === 'tabindex') {\n            node.attr(internalName, value);\n            node.attr(name, null);\n          } else {\n            node.attr(internalName, editor.convertURL(value, name, node.name));\n          }\n        }\n      }\n    });\n    parser.addNodeFilter('script', nodes => {\n      let i = nodes.length;\n\n      while (i--) {\n        const node = nodes[i];\n        const type = node.attr('type') || 'no/type';\n\n        if (type.indexOf('mce-') !== 0) {\n          node.attr('type', 'mce-' + type);\n        }\n      }\n    });\n\n    if (shouldPreserveCData(editor)) {\n      parser.addNodeFilter('#cdata', nodes => {\n        var _a;\n\n        let i = nodes.length;\n\n        while (i--) {\n          const node = nodes[i];\n          node.type = 8;\n          node.name = '#comment';\n          node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n        }\n      });\n    }\n\n    parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n      let i = nodes.length;\n      const nonEmptyElements = editor.schema.getNonEmptyElements();\n\n      while (i--) {\n        const node = nodes[i];\n\n        if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n          node.append(new AstNode('br', 1));\n        }\n      }\n    });\n    return parser;\n  };\n\n  const autoFocus = editor => {\n    const autoFocus = getAutoFocus(editor);\n\n    if (autoFocus) {\n      Delay.setEditorTimeout(editor, () => {\n        let focusEditor;\n\n        if (autoFocus === true) {\n          focusEditor = editor;\n        } else {\n          focusEditor = editor.editorManager.get(autoFocus);\n        }\n\n        if (focusEditor && !focusEditor.destroyed) {\n          focusEditor.focus();\n          focusEditor.selection.scrollIntoView();\n        }\n      }, 100);\n    }\n  };\n\n  const moveSelectionToFirstCaretPosition = editor => {\n    const root = editor.dom.getRoot();\n\n    if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n      firstPositionIn(root).each(pos => {\n        const node = pos.getNode();\n        const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n        editor.selection.setRng(caretPos.toRange());\n      });\n    }\n  };\n\n  const initEditor = editor => {\n    editor.bindPendingEventDelegates();\n    editor.initialized = true;\n    fireInit(editor);\n    editor.focus(true);\n    moveSelectionToFirstCaretPosition(editor);\n    editor.nodeChanged({\n      initial: true\n    });\n    const initInstanceCallback = getInitInstanceCallback(editor);\n\n    if (isFunction(initInstanceCallback)) {\n      initInstanceCallback.call(editor, editor);\n    }\n\n    autoFocus(editor);\n  };\n\n  const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n\n  const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n    const {\n      pass: bundledCss,\n      fail: normalCss\n    } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n    const bundledPromises = bundledCss.map(url => {\n      const css = tinymce.Resource.get(toContentSkinResourceName(url));\n\n      if (isString(css)) {\n        return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n      }\n\n      return Promise.resolve();\n    });\n    const promises = [...bundledPromises, getStyleSheetLoader$1(editor).loadAll(normalCss)];\n\n    if (editor.inline) {\n      return promises;\n    } else {\n      return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n    }\n  };\n\n  const loadContentCss = editor => {\n    const styleSheetLoader = getStyleSheetLoader$1(editor);\n    const fontCss = getFontCss(editor);\n    const css = editor.contentCSS;\n\n    const removeCss = () => {\n      styleSheetLoader.unloadAll(css);\n\n      if (!editor.inline) {\n        editor.ui.styleSheetLoader.unloadAll(fontCss);\n      }\n    };\n\n    const loaded = () => {\n      if (editor.removed) {\n        removeCss();\n      } else {\n        editor.on('remove', removeCss);\n      }\n    };\n\n    if (editor.contentStyles.length > 0) {\n      let contentCssText = '';\n      Tools.each(editor.contentStyles, style => {\n        contentCssText += style + '\\r\\n';\n      });\n      editor.dom.addStyle(contentCssText);\n    }\n\n    const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n    const contentStyle = getContentStyle(editor);\n\n    if (contentStyle) {\n      appendStyle(editor, contentStyle);\n    }\n\n    return allStylesheets;\n  };\n\n  const preInit = editor => {\n    const doc = editor.getDoc(),\n          body = editor.getBody();\n    firePreInit(editor);\n\n    if (!shouldBrowserSpellcheck(editor)) {\n      doc.body.spellcheck = false;\n      DOM$6.setAttrib(body, 'spellcheck', 'false');\n    }\n\n    editor.quirks = Quirks(editor);\n    firePostRender(editor);\n    const directionality = getDirectionality(editor);\n\n    if (directionality !== undefined) {\n      body.dir = directionality;\n    }\n\n    const protect = getProtect(editor);\n\n    if (protect) {\n      editor.on('BeforeSetContent', e => {\n        Tools.each(protect, pattern => {\n          e.content = e.content.replace(pattern, str => {\n            return '<!--mce:protected ' + escape(str) + '-->';\n          });\n        });\n      });\n    }\n\n    editor.on('SetContent', () => {\n      editor.addVisual(editor.getBody());\n    });\n    editor.on('compositionstart compositionend', e => {\n      editor.composing = e.type === 'compositionstart';\n    });\n  };\n\n  const loadInitialContent = editor => {\n    if (!isRtc(editor)) {\n      editor.load({\n        initial: true,\n        format: 'html'\n      });\n    }\n\n    editor.startContent = editor.getContent({\n      format: 'raw'\n    });\n  };\n\n  const initEditorWithInitialContent = editor => {\n    if (editor.removed !== true) {\n      loadInitialContent(editor);\n      initEditor(editor);\n    }\n  };\n\n  const startProgress = editor => {\n    let canceled = false;\n    const progressTimeout = setTimeout(() => {\n      if (!canceled) {\n        editor.setProgressState(true);\n      }\n    }, 500);\n    return () => {\n      clearTimeout(progressTimeout);\n      canceled = true;\n      editor.setProgressState(false);\n    };\n  };\n\n  const contentBodyLoaded = editor => {\n    const targetElm = editor.getElement();\n    let doc = editor.getDoc();\n\n    if (editor.inline) {\n      DOM$6.addClass(targetElm, 'mce-content-body');\n      editor.contentDocument = doc = document;\n      editor.contentWindow = window;\n      editor.bodyElement = targetElm;\n      editor.contentAreaContainer = targetElm;\n    }\n\n    const body = editor.getBody();\n    body.disabled = true;\n    editor.readonly = isReadOnly$1(editor);\n    editor._editableRoot = hasEditableRoot$1(editor);\n\n    if (!editor.readonly && editor.hasEditableRoot()) {\n      if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n        body.style.position = 'relative';\n      }\n\n      body.contentEditable = 'true';\n    }\n\n    body.disabled = false;\n    editor.editorUpload = EditorUpload(editor);\n    editor.schema = Schema(mkSchemaSettings(editor));\n    editor.dom = DOMUtils(doc, {\n      keep_values: true,\n      url_converter: editor.convertURL,\n      url_converter_scope: editor,\n      update_styles: true,\n      root_element: editor.inline ? editor.getBody() : null,\n      collect: editor.inline,\n      schema: editor.schema,\n      contentCssCors: shouldUseContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor),\n      onSetAttrib: e => {\n        editor.dispatch('SetAttrib', e);\n      },\n      force_hex_color: shouldForceHexColor(editor)\n    });\n    editor.parser = createParser(editor);\n    editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n    editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n    editor.annotator = Annotator(editor);\n    editor.formatter = Formatter(editor);\n    editor.undoManager = UndoManager(editor);\n    editor._nodeChangeDispatcher = new NodeChange(editor);\n    editor._selectionOverrides = SelectionOverrides(editor);\n    setup$p(editor);\n    setup$6(editor);\n    setup$n(editor);\n\n    if (!isRtc(editor)) {\n      setup$5(editor);\n      setup$1(editor);\n    }\n\n    const caret = setup$b(editor);\n    setup$q(editor, caret);\n    setup$o(editor);\n    setup$r(editor);\n    setup$7(editor);\n    const setupRtcThunk = setup$t(editor);\n    preInit(editor);\n    setupRtcThunk.fold(() => {\n      const cancelProgress = startProgress(editor);\n      loadContentCss(editor).then(() => {\n        initEditorWithInitialContent(editor);\n        cancelProgress();\n      });\n    }, setupRtc => {\n      editor.setProgressState(true);\n      loadContentCss(editor).then(() => {\n        setupRtc().then(_rtcMode => {\n          editor.setProgressState(false);\n          initEditorWithInitialContent(editor);\n          bindEvents(editor);\n        }, err => {\n          editor.notificationManager.open({\n            type: 'error',\n            text: String(err)\n          });\n          initEditorWithInitialContent(editor);\n          bindEvents(editor);\n        });\n      });\n    });\n  };\n\n  const filter = always;\n\n  const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n\n  const DOM$5 = DOMUtils.DOM;\n\n  const createIframeElement = (id, title, customAttrs, tabindex) => {\n    const iframe = SugarElement.fromTag('iframe');\n    tabindex.each(t => set$3(iframe, 'tabindex', t));\n    setAll$1(iframe, customAttrs);\n    setAll$1(iframe, {\n      id: id + '_ifr',\n      frameBorder: '0',\n      allowTransparency: 'true',\n      title\n    });\n    add$2(iframe, 'tox-edit-area__iframe');\n    return iframe;\n  };\n\n  const getIframeHtml = editor => {\n    let iframeHTML = getDocType(editor) + '<html><head>';\n\n    if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n      iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n    }\n\n    iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n    const bodyId = getBodyId(editor);\n    const bodyClass = getBodyClass(editor);\n    const translatedAriaText = editor.translate(getIframeAriaText(editor));\n\n    if (getContentSecurityPolicy(editor)) {\n      iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n    }\n\n    iframeHTML += '</head>' + `<body id=\"${bodyId}\" class=\"mce-content-body ${bodyClass}\" data-id=\"${editor.id}\" aria-label=\"${translatedAriaText}\">` + '<br>' + '</body></html>';\n    return iframeHTML;\n  };\n\n  const createIframe = (editor, boxInfo) => {\n    const iframeTitle = editor.translate('Rich Text Area');\n    const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n    const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n\n    ifr.onload = () => {\n      ifr.onload = null;\n      editor.dispatch('load');\n    };\n\n    editor.contentAreaContainer = boxInfo.iframeContainer;\n    editor.iframeElement = ifr;\n    editor.iframeHTML = getIframeHtml(editor);\n    DOM$5.add(boxInfo.iframeContainer, ifr);\n  };\n\n  const setupIframeBody = editor => {\n    const iframe = editor.iframeElement;\n\n    const ready = () => {\n      editor.contentDocument = iframe.contentDocument;\n      contentBodyLoaded(editor);\n    };\n\n    if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n      const doc = editor.getDoc();\n      doc.open();\n      doc.write(editor.iframeHTML);\n      doc.close();\n      ready();\n    } else {\n      const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n        binder.unbind();\n        ready();\n      });\n      iframe.srcdoc = editor.iframeHTML;\n    }\n  };\n\n  const init$1 = (editor, boxInfo) => {\n    createIframe(editor, boxInfo);\n\n    if (boxInfo.editorContainer) {\n      boxInfo.editorContainer.style.display = editor.orgDisplay;\n      editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n    }\n\n    editor.getElement().style.display = 'none';\n    DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n    editor.getElement().style.visibility = editor.orgVisibility;\n    setupIframeBody(editor);\n  };\n\n  const DOM$4 = DOMUtils.DOM;\n\n  const initPlugin = (editor, initializedPlugins, plugin) => {\n    const Plugin = PluginManager.get(plugin);\n    const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n    plugin = Tools.trim(plugin);\n\n    if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n      if (editor.plugins[plugin]) {\n        return;\n      }\n\n      try {\n        const pluginInstance = Plugin(editor, pluginUrl) || {};\n        editor.plugins[plugin] = pluginInstance;\n\n        if (isFunction(pluginInstance.init)) {\n          pluginInstance.init(editor, pluginUrl);\n          initializedPlugins.push(plugin);\n        }\n      } catch (e) {\n        pluginInitError(editor, plugin, e);\n      }\n    }\n  };\n\n  const trimLegacyPrefix = name => {\n    return name.replace(/^\\-/, '');\n  };\n\n  const initPlugins = editor => {\n    const initializedPlugins = [];\n    each$e(getPlugins(editor), name => {\n      initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n    });\n  };\n\n  const initIcons = editor => {\n    const iconPackName = Tools.trim(getIconPackName(editor));\n    const currentIcons = editor.ui.registry.getAll().icons;\n    const loadIcons = { ...IconManager.get('default').icons,\n      ...IconManager.get(iconPackName).icons\n    };\n    each$d(loadIcons, (svgData, icon) => {\n      if (!has$2(currentIcons, icon)) {\n        editor.ui.registry.addIcon(icon, svgData);\n      }\n    });\n  };\n\n  const initTheme = editor => {\n    const theme = getTheme(editor);\n\n    if (isString(theme)) {\n      const Theme = ThemeManager.get(theme);\n      editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n\n      if (isFunction(editor.theme.init)) {\n        editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n      }\n    } else {\n      editor.theme = {};\n    }\n  };\n\n  const initModel = editor => {\n    const model = getModel(editor);\n    const Model = ModelManager.get(model);\n    editor.model = Model(editor, ModelManager.urls[model]);\n  };\n\n  const renderFromLoadedTheme = editor => {\n    const render = editor.theme.renderUI;\n    return render ? render() : renderThemeFalse(editor);\n  };\n\n  const renderFromThemeFunc = editor => {\n    const elm = editor.getElement();\n    const theme = getTheme(editor);\n    const info = theme(editor, elm);\n\n    if (info.editorContainer.nodeType) {\n      info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n    }\n\n    if (info.iframeContainer && info.iframeContainer.nodeType) {\n      info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n    }\n\n    info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n    return info;\n  };\n\n  const createThemeFalseResult = (element, iframe) => {\n    return {\n      editorContainer: element,\n      iframeContainer: iframe,\n      api: {}\n    };\n  };\n\n  const renderThemeFalseIframe = targetElement => {\n    const iframeContainer = DOM$4.create('div');\n    DOM$4.insertAfter(iframeContainer, targetElement);\n    return createThemeFalseResult(iframeContainer, iframeContainer);\n  };\n\n  const renderThemeFalse = editor => {\n    const targetElement = editor.getElement();\n    return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n  };\n\n  const renderThemeUi = editor => {\n    const elm = editor.getElement();\n    editor.orgDisplay = elm.style.display;\n\n    if (isString(getTheme(editor))) {\n      return renderFromLoadedTheme(editor);\n    } else if (isFunction(getTheme(editor))) {\n      return renderFromThemeFunc(editor);\n    } else {\n      return renderThemeFalse(editor);\n    }\n  };\n\n  const augmentEditorUiApi = (editor, api) => {\n    const uiApiFacade = {\n      show: Optional.from(api.show).getOr(noop),\n      hide: Optional.from(api.hide).getOr(noop),\n      isEnabled: Optional.from(api.isEnabled).getOr(always),\n      setEnabled: state => {\n        if (!editor.mode.isReadOnly()) {\n          Optional.from(api.setEnabled).each(f => f(state));\n        }\n      }\n    };\n    editor.ui = { ...editor.ui,\n      ...uiApiFacade\n    };\n  };\n\n  const init = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (editor) {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = yield renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      editor.editorContainer = renderInfo.editorContainer;\n      appendContentCssFromSettings(editor);\n\n      if (editor.inline) {\n        contentBodyLoaded(editor);\n      } else {\n        init$1(editor, {\n          editorContainer: renderInfo.editorContainer,\n          iframeContainer: renderInfo.iframeContainer\n        });\n      }\n    });\n\n    return function init(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  const DOM$3 = DOMUtils.DOM;\n\n  const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n\n  const loadLanguage = (scriptLoader, editor) => {\n    const languageCode = getLanguageCode(editor);\n    const languageUrl = getLanguageUrl(editor);\n\n    if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n      const url = isNotEmpty(languageUrl) ? languageUrl : `${editor.editorManager.baseURL}/langs/${languageCode}.js`;\n      scriptLoader.add(url).catch(() => {\n        languageLoadError(editor, url, languageCode);\n      });\n    }\n  };\n\n  const loadTheme = (editor, suffix) => {\n    const theme = getTheme(editor);\n\n    if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n      const themeUrl = getThemeUrl(editor);\n      const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${theme}/theme${suffix}.js`;\n      ThemeManager.load(theme, url).catch(() => {\n        themeLoadError(editor, url, theme);\n      });\n    }\n  };\n\n  const loadModel = (editor, suffix) => {\n    const model = getModel(editor);\n\n    if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n      const modelUrl = getModelUrl(editor);\n      const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${model}/model${suffix}.js`;\n      ModelManager.load(model, url).catch(() => {\n        modelLoadError(editor, url, model);\n      });\n    }\n  };\n\n  const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n    url,\n    name: Optional.none()\n  }));\n\n  const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n    url: `${editor.editorManager.baseURL}/icons/${name}/icons${suffix}.js`,\n    name: Optional.some(name)\n  }));\n\n  const loadIcons = (scriptLoader, editor, suffix) => {\n    const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n    const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n    each$e(cat([defaultIconsUrl, customIconsUrl]), urlMeta => {\n      scriptLoader.add(urlMeta.url).catch(() => {\n        iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n      });\n    });\n  };\n\n  const loadPlugins = (editor, suffix) => {\n    const loadPlugin = (name, url) => {\n      PluginManager.load(name, url).catch(() => {\n        pluginLoadError(editor, url, name);\n      });\n    };\n\n    each$d(getExternalPlugins$1(editor), (url, name) => {\n      loadPlugin(name, url);\n      editor.options.set('plugins', getPlugins(editor).concat(name));\n    });\n    each$e(getPlugins(editor), plugin => {\n      plugin = Tools.trim(plugin);\n\n      if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n        loadPlugin(plugin, `plugins/${plugin}/plugin${suffix}.js`);\n      }\n    });\n  };\n\n  const isThemeLoaded = editor => {\n    const theme = getTheme(editor);\n    return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n  };\n\n  const isModelLoaded = editor => {\n    const model = getModel(editor);\n    return isNonNullable(ModelManager.get(model));\n  };\n\n  const loadScripts = (editor, suffix) => {\n    const scriptLoader = ScriptLoader.ScriptLoader;\n\n    const initEditor = () => {\n      if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n        init(editor);\n      }\n    };\n\n    loadTheme(editor, suffix);\n    loadModel(editor, suffix);\n    loadLanguage(scriptLoader, editor);\n    loadIcons(scriptLoader, editor, suffix);\n    loadPlugins(editor, suffix);\n    scriptLoader.loadQueue().then(initEditor, initEditor);\n  };\n\n  const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n    contentCssCors: hasContentCssCors(editor),\n    referrerPolicy: getReferrerPolicy(editor)\n  });\n\n  const render = editor => {\n    const id = editor.id;\n    I18n.setCode(getLanguageCode(editor));\n\n    const readyHandler = () => {\n      DOM$3.unbind(window, 'ready', readyHandler);\n      editor.render();\n    };\n\n    if (!EventUtils.Event.domLoaded) {\n      DOM$3.bind(window, 'ready', readyHandler);\n      return;\n    }\n\n    if (!editor.getElement()) {\n      return;\n    }\n\n    const element = SugarElement.fromDom(editor.getElement());\n    const snapshot = clone$4(element);\n    editor.on('remove', () => {\n      eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n      setAll$1(element, snapshot);\n    });\n    editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n\n    if (!isInline$1(editor)) {\n      editor.orgVisibility = editor.getElement().style.visibility;\n      editor.getElement().style.visibility = 'hidden';\n    } else {\n      editor.inline = true;\n    }\n\n    const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n\n    if (form) {\n      editor.formElement = form;\n\n      if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n        DOM$3.insertAfter(DOM$3.create('input', {\n          type: 'hidden',\n          name: id\n        }), id);\n        editor.hasHiddenInput = true;\n      }\n\n      editor.formEventDelegate = e => {\n        editor.dispatch(e.type, e);\n      };\n\n      DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n      editor.on('reset', () => {\n        editor.resetContent();\n      });\n\n      if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n        form._mceOldSubmit = form.submit;\n\n        form.submit = () => {\n          editor.editorManager.triggerSave();\n          editor.setDirty(false);\n          return form._mceOldSubmit(form);\n        };\n      }\n    }\n\n    editor.windowManager = WindowManager(editor);\n    editor.notificationManager = NotificationManager(editor);\n\n    if (isEncodingXml(editor)) {\n      editor.on('GetContent', e => {\n        if (e.save) {\n          e.content = DOM$3.encode(e.content);\n        }\n      });\n    }\n\n    if (shouldAddFormSubmitTrigger(editor)) {\n      editor.on('submit', () => {\n        if (editor.initialized) {\n          editor.save();\n        }\n      });\n    }\n\n    if (shouldAddUnloadTrigger(editor)) {\n      editor._beforeUnload = () => {\n        if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n          editor.save({\n            format: 'raw',\n            no_events: true,\n            set_dirty: false\n          });\n        }\n      };\n\n      editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n    }\n\n    editor.editorManager.add(editor);\n    loadScripts(editor, editor.suffix);\n  };\n\n  const setEditableRoot = (editor, state) => {\n    if (editor._editableRoot !== state) {\n      editor._editableRoot = state;\n\n      if (!editor.readonly) {\n        editor.getBody().contentEditable = String(editor.hasEditableRoot());\n        editor.nodeChanged();\n      }\n\n      fireEditableRootStateChange(editor, state);\n    }\n  };\n\n  const hasEditableRoot = editor => editor._editableRoot;\n\n  const sectionResult = (sections, settings) => ({\n    sections: constant(sections),\n    options: constant(settings)\n  });\n\n  const deviceDetection = detect$2().deviceType;\n  const isPhone = deviceDetection.isPhone();\n  const isTablet = deviceDetection.isTablet();\n\n  const normalizePlugins = plugins => {\n    if (isNullable(plugins)) {\n      return [];\n    } else {\n      const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n      const trimmedPlugins = map$3(pluginNames, trim$4);\n      return filter$5(trimmedPlugins, isNotEmpty);\n    }\n  };\n\n  const extractSections = (keys, options) => {\n    const result = bifilter(options, (value, key) => {\n      return contains$2(keys, key);\n    });\n    return sectionResult(result.t, result.f);\n  };\n\n  const getSection = (sectionResult, name, defaults = {}) => {\n    const sections = sectionResult.sections();\n    const sectionOptions = get$a(sections, name).getOr({});\n    return Tools.extend({}, defaults, sectionOptions);\n  };\n\n  const hasSection = (sectionResult, name) => {\n    return has$2(sectionResult.sections(), name);\n  };\n\n  const getSectionConfig = (sectionResult, name) => {\n    return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n  };\n\n  const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n    const defaultMobileOptions = {\n      table_grid: false,\n      object_resizing: false,\n      resize: false,\n      toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n      toolbar_sticky: false\n    };\n    const defaultPhoneOptions = {\n      menubar: false\n    };\n    return { ...defaultMobileOptions,\n      ...(isPhone ? defaultPhoneOptions : {})\n    };\n  };\n\n  const getExternalPlugins = (overrideOptions, options) => {\n    var _a;\n\n    const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n\n    if (overrideOptions && overrideOptions.external_plugins) {\n      return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n    } else {\n      return userDefinedExternalPlugins;\n    }\n  };\n\n  const combinePlugins = (forcedPlugins, plugins) => [...normalizePlugins(forcedPlugins), ...normalizePlugins(plugins)];\n\n  const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n    if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n      return mobilePlugins;\n    } else {\n      return desktopPlugins;\n    }\n  };\n\n  const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n    const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n    const desktopPlugins = normalizePlugins(options.plugins);\n    const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n    const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n    const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n    const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n    return Tools.extend(options, {\n      forced_plugins: forcedPlugins,\n      plugins: combinedPlugins\n    });\n  };\n\n  const isOnMobile = (isMobileDevice, sectionResult) => {\n    return isMobileDevice && hasSection(sectionResult, 'mobile');\n  };\n\n  const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n    var _a;\n\n    const deviceOverrideOptions = isMobileDevice ? {\n      mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone)\n    } : {};\n    const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n    const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, {\n      external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options())\n    });\n    return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n  };\n\n  const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n  const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n  const registerExecCommands$3 = editor => {\n    const toggleFormat = (name, value) => {\n      editor.formatter.toggle(name, value);\n      editor.nodeChanged();\n    };\n\n    const toggleAlign = align => () => {\n      each$e('left,center,right,justify'.split(','), name => {\n        if (align !== name) {\n          editor.formatter.remove('align' + name);\n        }\n      });\n\n      if (align !== 'none') {\n        toggleFormat('align' + align);\n      }\n    };\n\n    editor.editorCommands.addCommands({\n      JustifyLeft: toggleAlign('left'),\n      JustifyCenter: toggleAlign('center'),\n      JustifyRight: toggleAlign('right'),\n      JustifyFull: toggleAlign('justify'),\n      JustifyNone: toggleAlign('none')\n    });\n  };\n\n  const registerQueryStateCommands$1 = editor => {\n    const alignStates = name => () => {\n      const selection = editor.selection;\n      const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n      return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n    };\n\n    editor.editorCommands.addCommands({\n      JustifyLeft: alignStates('alignleft'),\n      JustifyCenter: alignStates('aligncenter'),\n      JustifyRight: alignStates('alignright'),\n      JustifyFull: alignStates('alignjustify')\n    }, 'state');\n  };\n\n  const registerCommands$b = editor => {\n    registerExecCommands$3(editor);\n    registerQueryStateCommands$1(editor);\n  };\n\n  const registerCommands$a = editor => {\n    editor.editorCommands.addCommands({\n      'Cut,Copy,Paste': command => {\n        const doc = editor.getDoc();\n        let failed;\n\n        try {\n          doc.execCommand(command);\n        } catch (ex) {\n          failed = true;\n        }\n\n        if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n          failed = true;\n        }\n\n        if (failed || !doc.queryCommandSupported(command)) {\n          let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n\n          if (Env.os.isMacOS() || Env.os.isiOS()) {\n            msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n          }\n\n          editor.notificationManager.open({\n            text: msg,\n            type: 'error'\n          });\n        }\n      }\n    });\n  };\n\n  const trimOrPadLeftRight = (dom, rng, html, schema) => {\n    const root = SugarElement.fromDom(dom.getRoot());\n\n    if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n      html = html.replace(/^ /, '&nbsp;');\n    } else {\n      html = html.replace(/^&nbsp;/, ' ');\n    }\n\n    if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n      html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n    } else {\n      html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n    }\n\n    return html;\n  };\n\n  const processValue$1 = value => {\n    if (typeof value !== 'string') {\n      const details = Tools.extend({\n        paste: value.paste,\n        data: {\n          paste: value.paste\n        }\n      }, value);\n      return {\n        content: value.content,\n        details\n      };\n    }\n\n    return {\n      content: value,\n      details: {}\n    };\n  };\n\n  const trimOrPad = (editor, value) => {\n    const selection = editor.selection;\n    const dom = editor.dom;\n\n    if (/^ | $/.test(value)) {\n      return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n    } else {\n      return value;\n    }\n  };\n\n  const insertAtCaret = (editor, value) => {\n    if (editor.selection.isEditable()) {\n      const {\n        content,\n        details\n      } = processValue$1(value);\n      preProcessSetContent(editor, { ...details,\n        content: trimOrPad(editor, content),\n        format: 'html',\n        set: false,\n        selection: true\n      }).each(args => {\n        const insertedContent = insertContent$1(editor, args.content, details);\n        postProcessSetContent(editor, insertedContent, args);\n        editor.addVisual();\n      });\n    }\n  };\n\n  const registerCommands$9 = editor => {\n    editor.editorCommands.addCommands({\n      mceCleanup: () => {\n        const bm = editor.selection.getBookmark();\n        editor.setContent(editor.getContent());\n        editor.selection.moveToBookmark(bm);\n      },\n      insertImage: (_command, _ui, value) => {\n        insertAtCaret(editor, editor.dom.createHTML('img', {\n          src: value\n        }));\n      },\n      insertHorizontalRule: () => {\n        editor.execCommand('mceInsertContent', false, '<hr>');\n      },\n      insertText: (_command, _ui, value) => {\n        insertAtCaret(editor, editor.dom.encode(value));\n      },\n      insertHTML: (_command, _ui, value) => {\n        insertAtCaret(editor, value);\n      },\n      mceInsertContent: (_command, _ui, value) => {\n        insertAtCaret(editor, value);\n      },\n      mceSetContent: (_command, _ui, value) => {\n        editor.setContent(value);\n      },\n      mceReplaceContent: (_command, _ui, value) => {\n        editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({\n          format: 'text'\n        })));\n      },\n      mceNewDocument: () => {\n        editor.setContent(getNewDocumentContent(editor));\n      }\n    });\n  };\n\n  const legacyPropNames = {\n    'font-size': 'size',\n    'font-family': 'face'\n  };\n  const isFont = isTag('font');\n\n  const getSpecifiedFontProp = (propName, rootElm, elm) => {\n    const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n      if (isFont(elm)) {\n        return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n      } else {\n        return Optional.none();\n      }\n    });\n\n    const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n\n    return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n  };\n\n  const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n\n  const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n\n  const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n\n  const getFontSize = getFontProp('font-size');\n  const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n  const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n    const container = caret.container();\n    return Optional.from(isText$a(container) ? container.parentNode : container);\n  });\n\n  const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n    const root = editor.getBody();\n    const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n    return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n  });\n\n  const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n\n  const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n  const fromFontSizeNumber = (editor, value) => {\n    if (/^[0-9.]+$/.test(value)) {\n      const fontSizeNumber = parseInt(value, 10);\n\n      if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n        const fontSizes = getFontStyleValues(editor);\n        const fontClasses = getFontSizeClasses(editor);\n\n        if (fontClasses.length > 0) {\n          return fontClasses[fontSizeNumber - 1] || value;\n        } else {\n          return fontSizes[fontSizeNumber - 1] || value;\n        }\n      } else {\n        return value;\n      }\n    } else {\n      return value;\n    }\n  };\n\n  const normalizeFontNames = font => {\n    const fonts = font.split(/\\s*,\\s*/);\n    return map$3(fonts, font => {\n      if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n        return `'${font}'`;\n      } else {\n        return font;\n      }\n    }).join(',');\n  };\n\n  const fontNameAction = (editor, value) => {\n    const font = fromFontSizeNumber(editor, value);\n    editor.formatter.toggle('fontname', {\n      value: normalizeFontNames(font)\n    });\n    editor.nodeChanged();\n  };\n\n  const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n\n  const fontSizeAction = (editor, value) => {\n    editor.formatter.toggle('fontsize', {\n      value: fromFontSizeNumber(editor, value)\n    });\n    editor.nodeChanged();\n  };\n\n  const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n  const lineHeightQuery = editor => mapRange(editor, elm => {\n    const root = SugarElement.fromDom(editor.getBody());\n    const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n\n    const computedStyle = () => {\n      const lineHeight = parseFloat(get$7(elm, 'line-height'));\n      const fontSize = parseFloat(get$7(elm, 'font-size'));\n      return String(lineHeight / fontSize);\n    };\n\n    return specifiedStyle.getOrThunk(computedStyle);\n  }).getOr('');\n\n  const lineHeightAction = (editor, lineHeight) => {\n    editor.formatter.toggle('lineheight', {\n      value: String(lineHeight)\n    });\n    editor.nodeChanged();\n  };\n\n  const registerExecCommands$2 = editor => {\n    const toggleFormat = (name, value) => {\n      editor.formatter.toggle(name, value);\n      editor.nodeChanged();\n    };\n\n    editor.editorCommands.addCommands({\n      'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n        toggleFormat(command);\n      },\n      'ForeColor,HiliteColor': (command, _ui, value) => {\n        toggleFormat(command, {\n          value\n        });\n      },\n      'BackColor': (_command, _ui, value) => {\n        toggleFormat('hilitecolor', {\n          value\n        });\n      },\n      'FontName': (_command, _ui, value) => {\n        fontNameAction(editor, value);\n      },\n      'FontSize': (_command, _ui, value) => {\n        fontSizeAction(editor, value);\n      },\n      'LineHeight': (_command, _ui, value) => {\n        lineHeightAction(editor, value);\n      },\n      'Lang': (command, _ui, lang) => {\n        var _a;\n\n        toggleFormat(command, {\n          value: lang.code,\n          customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n        });\n      },\n      'RemoveFormat': command => {\n        editor.formatter.remove(command);\n      },\n      'mceBlockQuote': () => {\n        toggleFormat('blockquote');\n      },\n      'FormatBlock': (_command, _ui, value) => {\n        toggleFormat(isString(value) ? value : 'p');\n      },\n      'mceToggleFormat': (_command, _ui, value) => {\n        toggleFormat(value);\n      }\n    });\n  };\n\n  const registerQueryValueCommands = editor => {\n    const isFormatMatch = name => editor.formatter.match(name);\n\n    editor.editorCommands.addCommands({\n      'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n      'mceBlockQuote': () => isFormatMatch('blockquote')\n    }, 'state');\n    editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n    editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n    editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n  };\n\n  const registerCommands$8 = editor => {\n    registerExecCommands$2(editor);\n    registerQueryValueCommands(editor);\n  };\n\n  const registerCommands$7 = editor => {\n    editor.editorCommands.addCommands({\n      mceAddUndoLevel: () => {\n        editor.undoManager.add();\n      },\n      mceEndUndoLevel: () => {\n        editor.undoManager.add();\n      },\n      Undo: () => {\n        editor.undoManager.undo();\n      },\n      Redo: () => {\n        editor.undoManager.redo();\n      }\n    });\n  };\n\n  const registerCommands$6 = editor => {\n    editor.editorCommands.addCommands({\n      Indent: () => {\n        indent(editor);\n      },\n      Outdent: () => {\n        outdent(editor);\n      }\n    });\n    editor.editorCommands.addCommands({\n      Outdent: () => canOutdent(editor)\n    }, 'state');\n  };\n\n  const registerCommands$5 = editor => {\n    const applyLinkToSelection = (_command, _ui, value) => {\n      const linkDetails = isString(value) ? {\n        href: value\n      } : value;\n      const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n\n      if (isObject(linkDetails) && isString(linkDetails.href)) {\n        linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n\n        if (!anchor || !linkDetails.href) {\n          editor.formatter.remove('link');\n        }\n\n        if (linkDetails.href) {\n          editor.formatter.apply('link', linkDetails, anchor);\n        }\n      }\n    };\n\n    editor.editorCommands.addCommands({\n      unlink: () => {\n        if (editor.selection.isEditable()) {\n          if (editor.selection.isCollapsed()) {\n            const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n\n            if (elm) {\n              editor.dom.remove(elm, true);\n            }\n\n            return;\n          }\n\n          editor.formatter.remove('link');\n        }\n      },\n      mceInsertLink: applyLinkToSelection,\n      createLink: applyLinkToSelection\n    });\n  };\n\n  const registerExecCommands$1 = editor => {\n    editor.editorCommands.addCommands({\n      'InsertUnorderedList,InsertOrderedList': command => {\n        editor.getDoc().execCommand(command);\n        const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n\n        if (listElm) {\n          const listParent = listElm.parentNode;\n\n          if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.split(listParent, listElm);\n            editor.selection.moveToBookmark(bm);\n          }\n        }\n      }\n    });\n  };\n\n  const registerQueryStateCommands = editor => {\n    editor.editorCommands.addCommands({\n      'InsertUnorderedList,InsertOrderedList': command => {\n        const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n        return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n      }\n    }, 'state');\n  };\n\n  const registerCommands$4 = editor => {\n    registerExecCommands$1(editor);\n    registerQueryStateCommands(editor);\n  };\n\n  const getTopParentBlock = (editor, node, root, container) => {\n    const dom = editor.dom;\n\n    const selector = node => dom.isBlock(node) && node.parentElement === root;\n\n    const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n    return Optional.from(topParentBlock).map(SugarElement.fromDom);\n  };\n\n  const insert = (editor, before) => {\n    const dom = editor.dom;\n    const rng = editor.selection.getRng();\n    const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n    const container = before ? rng.startContainer : rng.endContainer;\n    const root = getEditableRoot(dom, container);\n\n    if (!root || !root.isContentEditable) {\n      return;\n    }\n\n    const insertFn = before ? before$3 : after$4;\n    const newBlockName = getForcedRootBlock(editor);\n    getTopParentBlock(editor, node, root, container).each(parentBlock => {\n      const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n      insertFn(parentBlock, SugarElement.fromDom(newBlock));\n      editor.selection.setCursorLocation(newBlock, 0);\n      editor.dispatch('NewBlock', {\n        newBlock\n      });\n      fireInputEvent(editor, 'insertParagraph');\n    });\n  };\n\n  const insertBefore = editor => insert(editor, true);\n\n  const insertAfter = editor => insert(editor, false);\n\n  const registerCommands$3 = editor => {\n    editor.editorCommands.addCommands({\n      InsertNewBlockBefore: () => {\n        insertBefore(editor);\n      },\n      InsertNewBlockAfter: () => {\n        insertAfter(editor);\n      }\n    });\n  };\n\n  const registerCommands$2 = editor => {\n    editor.editorCommands.addCommands({\n      insertParagraph: () => {\n        insertBreak(blockbreak, editor);\n      },\n      mceInsertNewLine: (_command, _ui, value) => {\n        insert$1(editor, value);\n      },\n      InsertLineBreak: (_command, _ui, _value) => {\n        insertBreak(linebreak, editor);\n      }\n    });\n  };\n\n  const registerCommands$1 = editor => {\n    editor.editorCommands.addCommands({\n      mceSelectNodeDepth: (_command, _ui, value) => {\n        let counter = 0;\n        editor.dom.getParent(editor.selection.getNode(), node => {\n          if (isElement$6(node) && counter++ === value) {\n            editor.selection.select(node);\n            return false;\n          } else {\n            return true;\n          }\n        }, editor.getBody());\n      },\n      mceSelectNode: (_command, _ui, value) => {\n        editor.selection.select(value);\n      },\n      selectAll: () => {\n        const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n\n        if (editingHost) {\n          const rng = editor.dom.createRng();\n          rng.selectNodeContents(editingHost);\n          editor.selection.setRng(rng);\n        }\n      }\n    });\n  };\n\n  const registerExecCommands = editor => {\n    editor.editorCommands.addCommands({\n      mceRemoveNode: (_command, _ui, value) => {\n        const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n\n        if (node !== editor.getBody()) {\n          const bm = editor.selection.getBookmark();\n          editor.dom.remove(node, true);\n          editor.selection.moveToBookmark(bm);\n        }\n      },\n      mcePrint: () => {\n        editor.getWin().print();\n      },\n      mceFocus: (_command, _ui, value) => {\n        focus(editor, value === true);\n      },\n      mceToggleVisualAid: () => {\n        editor.hasVisual = !editor.hasVisual;\n        editor.addVisual();\n      }\n    });\n  };\n\n  const registerCommands = editor => {\n    registerCommands$b(editor);\n    registerCommands$a(editor);\n    registerCommands$7(editor);\n    registerCommands$1(editor);\n    registerCommands$9(editor);\n    registerCommands$5(editor);\n    registerCommands$6(editor);\n    registerCommands$3(editor);\n    registerCommands$2(editor);\n    registerCommands$4(editor);\n    registerCommands$8(editor);\n    registerExecCommands(editor);\n  };\n\n  const selectionSafeCommands = ['toggleview'];\n\n  const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n\n  class EditorCommands {\n    constructor(editor) {\n      this.commands = {\n        state: {},\n        exec: {},\n        value: {}\n      };\n      this.editor = editor;\n    }\n\n    execCommand(command, ui = false, value, args) {\n      const editor = this.editor;\n      const lowerCaseCommand = command.toLowerCase();\n      const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n\n      if (editor.removed) {\n        return false;\n      }\n\n      if (lowerCaseCommand !== 'mcefocus') {\n        if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n          editor.focus();\n        } else {\n          restore(editor);\n        }\n      }\n\n      const eventArgs = editor.dispatch('BeforeExecCommand', {\n        command,\n        ui,\n        value\n      });\n\n      if (eventArgs.isDefaultPrevented()) {\n        return false;\n      }\n\n      const func = this.commands.exec[lowerCaseCommand];\n\n      if (isFunction(func)) {\n        func(lowerCaseCommand, ui, value);\n        editor.dispatch('ExecCommand', {\n          command,\n          ui,\n          value\n        });\n        return true;\n      }\n\n      return false;\n    }\n\n    queryCommandState(command) {\n      if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n        return false;\n      }\n\n      const lowerCaseCommand = command.toLowerCase();\n      const func = this.commands.state[lowerCaseCommand];\n\n      if (isFunction(func)) {\n        return func(lowerCaseCommand);\n      }\n\n      return false;\n    }\n\n    queryCommandValue(command) {\n      if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n        return '';\n      }\n\n      const lowerCaseCommand = command.toLowerCase();\n      const func = this.commands.value[lowerCaseCommand];\n\n      if (isFunction(func)) {\n        return func(lowerCaseCommand);\n      }\n\n      return '';\n    }\n\n    addCommands(commandList, type = 'exec') {\n      const commands = this.commands;\n      each$d(commandList, (callback, command) => {\n        each$e(command.toLowerCase().split(','), command => {\n          commands[type][command] = callback;\n        });\n      });\n    }\n\n    addCommand(command, callback, scope) {\n      const lowerCaseCommand = command.toLowerCase();\n\n      this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n    }\n\n    queryCommandSupported(command) {\n      const lowerCaseCommand = command.toLowerCase();\n\n      if (this.commands.exec[lowerCaseCommand]) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    addQueryStateHandler(command, callback, scope) {\n      this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n    }\n\n    addQueryValueHandler(command, callback, scope) {\n      this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n    }\n\n  }\n\n  const internalContentEditableAttr = 'data-mce-contenteditable';\n\n  const toggleClass = (elm, cls, state) => {\n    if (has(elm, cls) && !state) {\n      remove$7(elm, cls);\n    } else if (state) {\n      add$2(elm, cls);\n    }\n  };\n\n  const setEditorCommandState = (editor, cmd, state) => {\n    try {\n      editor.getDoc().execCommand(cmd, false, String(state));\n    } catch (ex) {}\n  };\n\n  const setContentEditable = (elm, state) => {\n    elm.dom.contentEditable = state ? 'true' : 'false';\n  };\n\n  const switchOffContentEditableTrue = elm => {\n    each$e(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n      set$3(elm, internalContentEditableAttr, 'true');\n      setContentEditable(elm, false);\n    });\n  };\n\n  const switchOnContentEditableTrue = elm => {\n    each$e(descendants(elm, `*[${internalContentEditableAttr}=\"true\"]`), elm => {\n      remove$a(elm, internalContentEditableAttr);\n      setContentEditable(elm, true);\n    });\n  };\n\n  const removeFakeSelection = editor => {\n    Optional.from(editor.selection.getNode()).each(elm => {\n      elm.removeAttribute('data-mce-selected');\n    });\n  };\n\n  const restoreFakeSelection = editor => {\n    editor.selection.setRng(editor.selection.getRng());\n  };\n\n  const toggleReadOnly = (editor, state) => {\n    const body = SugarElement.fromDom(editor.getBody());\n    toggleClass(body, 'mce-content-readonly', state);\n\n    if (state) {\n      editor.selection.controlSelection.hideResizeRect();\n\n      editor._selectionOverrides.hideFakeCaret();\n\n      removeFakeSelection(editor);\n      editor.readonly = true;\n      setContentEditable(body, false);\n      switchOffContentEditableTrue(body);\n    } else {\n      editor.readonly = false;\n\n      if (editor.hasEditableRoot()) {\n        setContentEditable(body, true);\n      }\n\n      switchOnContentEditableTrue(body);\n      setEditorCommandState(editor, 'StyleWithCSS', false);\n      setEditorCommandState(editor, 'enableInlineTableEditing', false);\n      setEditorCommandState(editor, 'enableObjectResizing', false);\n\n      if (hasEditorOrUiFocus(editor)) {\n        editor.focus();\n      }\n\n      restoreFakeSelection(editor);\n      editor.nodeChanged();\n    }\n  };\n\n  const isReadOnly = editor => editor.readonly;\n\n  const registerFilters = editor => {\n    editor.parser.addAttributeFilter('contenteditable', nodes => {\n      if (isReadOnly(editor)) {\n        each$e(nodes, node => {\n          node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n          node.attr('contenteditable', 'false');\n        });\n      }\n    });\n    editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n      if (isReadOnly(editor)) {\n        each$e(nodes, node => {\n          node.attr('contenteditable', node.attr(internalContentEditableAttr));\n        });\n      }\n    });\n    editor.serializer.addTempAttr(internalContentEditableAttr);\n  };\n\n  const registerReadOnlyContentFilters = editor => {\n    if (editor.serializer) {\n      registerFilters(editor);\n    } else {\n      editor.on('PreInit', () => {\n        registerFilters(editor);\n      });\n    }\n  };\n\n  const isClickEvent = e => e.type === 'click';\n\n  const allowedEvents = ['copy'];\n\n  const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n\n  const getAnchorHrefOpt = (editor, elm) => {\n    const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n\n    return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n  };\n\n  const processReadonlyEvents = (editor, e) => {\n    if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n      const elm = SugarElement.fromDom(e.target);\n      getAnchorHrefOpt(editor, elm).each(href => {\n        e.preventDefault();\n\n        if (/^#/.test(href)) {\n          const targetEl = editor.dom.select(`${href},[name=\"${removeLeading(href, '#')}\"]`);\n\n          if (targetEl.length) {\n            editor.selection.scrollIntoView(targetEl[0], true);\n          }\n        } else {\n          window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n        }\n      });\n    } else if (isReadOnlyAllowedEvent(e)) {\n      editor.dispatch(e.type, e);\n    }\n  };\n\n  const registerReadOnlySelectionBlockers = editor => {\n    editor.on('ShowCaret', e => {\n      if (isReadOnly(editor)) {\n        e.preventDefault();\n      }\n    });\n    editor.on('ObjectSelected', e => {\n      if (isReadOnly(editor)) {\n        e.preventDefault();\n      }\n    });\n  };\n\n  const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n\n  class EventDispatcher {\n    static isNative(name) {\n      return !!nativeEvents[name.toLowerCase()];\n    }\n\n    constructor(settings) {\n      this.bindings = {};\n      this.settings = settings || {};\n      this.scope = this.settings.scope || this;\n      this.toggleEvent = this.settings.toggleEvent || never;\n    }\n\n    fire(name, args) {\n      return this.dispatch(name, args);\n    }\n\n    dispatch(name, args) {\n      const lcName = name.toLowerCase();\n      const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n\n      if (this.settings.beforeFire) {\n        this.settings.beforeFire(event);\n      }\n\n      const handlers = this.bindings[lcName];\n\n      if (handlers) {\n        for (let i = 0, l = handlers.length; i < l; i++) {\n          const callback = handlers[i];\n\n          if (callback.removed) {\n            continue;\n          }\n\n          if (callback.once) {\n            this.off(lcName, callback.func);\n          }\n\n          if (event.isImmediatePropagationStopped()) {\n            return event;\n          }\n\n          if (callback.func.call(this.scope, event) === false) {\n            event.preventDefault();\n            return event;\n          }\n        }\n      }\n\n      return event;\n    }\n\n    on(name, callback, prepend, extra) {\n      if (callback === false) {\n        callback = never;\n      }\n\n      if (callback) {\n        const wrappedCallback = {\n          func: callback,\n          removed: false\n        };\n\n        if (extra) {\n          Tools.extend(wrappedCallback, extra);\n        }\n\n        const names = name.toLowerCase().split(' ');\n        let i = names.length;\n\n        while (i--) {\n          const currentName = names[i];\n          let handlers = this.bindings[currentName];\n\n          if (!handlers) {\n            handlers = [];\n            this.toggleEvent(currentName, true);\n          }\n\n          if (prepend) {\n            handlers = [wrappedCallback, ...handlers];\n          } else {\n            handlers = [...handlers, wrappedCallback];\n          }\n\n          this.bindings[currentName] = handlers;\n        }\n      }\n\n      return this;\n    }\n\n    off(name, callback) {\n      if (name) {\n        const names = name.toLowerCase().split(' ');\n        let i = names.length;\n\n        while (i--) {\n          const currentName = names[i];\n          let handlers = this.bindings[currentName];\n\n          if (!currentName) {\n            each$d(this.bindings, (_value, bindingName) => {\n              this.toggleEvent(bindingName, false);\n              delete this.bindings[bindingName];\n            });\n            return this;\n          }\n\n          if (handlers) {\n            if (!callback) {\n              handlers.length = 0;\n            } else {\n              const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n              handlers = filteredHandlers.fail;\n              this.bindings[currentName] = handlers;\n              each$e(filteredHandlers.pass, handler => {\n                handler.removed = true;\n              });\n            }\n\n            if (!handlers.length) {\n              this.toggleEvent(name, false);\n              delete this.bindings[currentName];\n            }\n          }\n        }\n      } else {\n        each$d(this.bindings, (_value, name) => {\n          this.toggleEvent(name, false);\n        });\n        this.bindings = {};\n      }\n\n      return this;\n    }\n\n    once(name, callback, prepend) {\n      return this.on(name, callback, prepend, {\n        once: true\n      });\n    }\n\n    has(name) {\n      name = name.toLowerCase();\n      const binding = this.bindings[name];\n      return !(!binding || binding.length === 0);\n    }\n\n  }\n\n  const getEventDispatcher = obj => {\n    if (!obj._eventDispatcher) {\n      obj._eventDispatcher = new EventDispatcher({\n        scope: obj,\n        toggleEvent: (name, state) => {\n          if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n            obj.toggleNativeEvent(name, state);\n          }\n        }\n      });\n    }\n\n    return obj._eventDispatcher;\n  };\n\n  const Observable = {\n    fire(name, args, bubble) {\n      return this.dispatch(name, args, bubble);\n    },\n\n    dispatch(name, args, bubble) {\n      const self = this;\n\n      if (self.removed && name !== 'remove' && name !== 'detach') {\n        return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n      }\n\n      const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n\n      if (bubble !== false && self.parent) {\n        let parent = self.parent();\n\n        while (parent && !dispatcherArgs.isPropagationStopped()) {\n          parent.dispatch(name, dispatcherArgs, false);\n          parent = parent.parent ? parent.parent() : undefined;\n        }\n      }\n\n      return dispatcherArgs;\n    },\n\n    on(name, callback, prepend) {\n      return getEventDispatcher(this).on(name, callback, prepend);\n    },\n\n    off(name, callback) {\n      return getEventDispatcher(this).off(name, callback);\n    },\n\n    once(name, callback) {\n      return getEventDispatcher(this).once(name, callback);\n    },\n\n    hasEventListeners(name) {\n      return getEventDispatcher(this).has(name);\n    }\n\n  };\n  const DOM$2 = DOMUtils.DOM;\n  let customEventRootDelegates;\n\n  const getEventTarget = (editor, eventName) => {\n    if (eventName === 'selectionchange') {\n      return editor.getDoc();\n    }\n\n    if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n      return editor.getDoc().documentElement;\n    }\n\n    const eventRoot = getEventRoot(editor);\n\n    if (eventRoot) {\n      if (!editor.eventRoot) {\n        editor.eventRoot = DOM$2.select(eventRoot)[0];\n      }\n\n      return editor.eventRoot;\n    }\n\n    return editor.getBody();\n  };\n\n  const isListening = editor => !editor.hidden && !isReadOnly(editor);\n\n  const fireEvent = (editor, eventName, e) => {\n    if (isListening(editor)) {\n      editor.dispatch(eventName, e);\n    } else if (isReadOnly(editor)) {\n      processReadonlyEvents(editor, e);\n    }\n  };\n\n  const bindEventDelegate = (editor, eventName) => {\n    if (!editor.delegates) {\n      editor.delegates = {};\n    }\n\n    if (editor.delegates[eventName] || editor.removed) {\n      return;\n    }\n\n    const eventRootElm = getEventTarget(editor, eventName);\n\n    if (getEventRoot(editor)) {\n      if (!customEventRootDelegates) {\n        customEventRootDelegates = {};\n        editor.editorManager.on('removeEditor', () => {\n          if (!editor.editorManager.activeEditor) {\n            if (customEventRootDelegates) {\n              each$d(customEventRootDelegates, (_value, name) => {\n                editor.dom.unbind(getEventTarget(editor, name));\n              });\n              customEventRootDelegates = null;\n            }\n          }\n        });\n      }\n\n      if (customEventRootDelegates[eventName]) {\n        return;\n      }\n\n      const delegate = e => {\n        const target = e.target;\n        const editors = editor.editorManager.get();\n        let i = editors.length;\n\n        while (i--) {\n          const body = editors[i].getBody();\n\n          if (body === target || DOM$2.isChildOf(target, body)) {\n            fireEvent(editors[i], eventName, e);\n          }\n        }\n      };\n\n      customEventRootDelegates[eventName] = delegate;\n      DOM$2.bind(eventRootElm, eventName, delegate);\n    } else {\n      const delegate = e => {\n        fireEvent(editor, eventName, e);\n      };\n\n      DOM$2.bind(eventRootElm, eventName, delegate);\n      editor.delegates[eventName] = delegate;\n    }\n  };\n\n  const EditorObservable = { ...Observable,\n\n    bindPendingEventDelegates() {\n      const self = this;\n      Tools.each(self._pendingNativeEvents, name => {\n        bindEventDelegate(self, name);\n      });\n    },\n\n    toggleNativeEvent(name, state) {\n      const self = this;\n\n      if (name === 'focus' || name === 'blur') {\n        return;\n      }\n\n      if (self.removed) {\n        return;\n      }\n\n      if (state) {\n        if (self.initialized) {\n          bindEventDelegate(self, name);\n        } else {\n          if (!self._pendingNativeEvents) {\n            self._pendingNativeEvents = [name];\n          } else {\n            self._pendingNativeEvents.push(name);\n          }\n        }\n      } else if (self.initialized && self.delegates) {\n        self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n        delete self.delegates[name];\n      }\n    },\n\n    unbindAllNativeEvents() {\n      const self = this;\n      const body = self.getBody();\n      const dom = self.dom;\n\n      if (self.delegates) {\n        each$d(self.delegates, (value, name) => {\n          self.dom.unbind(getEventTarget(self, name), name, value);\n        });\n        delete self.delegates;\n      }\n\n      if (!self.inline && body && dom) {\n        body.onload = null;\n        dom.unbind(self.getWin());\n        dom.unbind(self.getDoc());\n      }\n\n      if (dom) {\n        dom.unbind(body);\n        dom.unbind(self.getContainer());\n      }\n    }\n\n  };\n\n  const stringListProcessor = value => {\n    if (isString(value)) {\n      return {\n        value: value.split(/[ ,]/),\n        valid: true\n      };\n    } else if (isArrayOf(value, isString)) {\n      return {\n        value,\n        valid: true\n      };\n    } else {\n      return {\n        valid: false,\n        message: `The value must be a string[] or a comma/space separated string.`\n      };\n    }\n  };\n\n  const getBuiltInProcessor = type => {\n    const validator = (() => {\n      switch (type) {\n        case 'array':\n          return isArray$1;\n\n        case 'boolean':\n          return isBoolean;\n\n        case 'function':\n          return isFunction;\n\n        case 'number':\n          return isNumber;\n\n        case 'object':\n          return isObject;\n\n        case 'string':\n          return isString;\n\n        case 'string[]':\n          return stringListProcessor;\n\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n\n        case 'regexp':\n          return val => is$4(val, RegExp);\n\n        default:\n          return always;\n      }\n    })();\n\n    return value => processValue(value, validator, `The value must be a ${type}.`);\n  };\n\n  const isBuiltInSpec = spec => isString(spec.processor);\n\n  const getErrorMessage = (message, result) => {\n    const additionalText = isEmpty$3(result.message) ? '' : `. ${result.message}`;\n    return message + additionalText;\n  };\n\n  const isValidResult = result => result.valid;\n\n  const processValue = (value, processor, message = '') => {\n    const result = processor(value);\n\n    if (isBoolean(result)) {\n      return result ? {\n        value: value,\n        valid: true\n      } : {\n        valid: false,\n        message\n      };\n    } else {\n      return result;\n    }\n  };\n\n  const processDefaultValue = (name, defaultValue, processor) => {\n    if (!isUndefined(defaultValue)) {\n      const result = processValue(defaultValue, processor);\n\n      if (isValidResult(result)) {\n        return result.value;\n      } else {\n        console.error(getErrorMessage(`Invalid default value passed for the \"${name}\" option`, result));\n      }\n    }\n\n    return undefined;\n  };\n\n  const create$5 = (editor, initialOptions) => {\n    const registry = {};\n    const values = {};\n\n    const setValue = (name, value, processor) => {\n      const result = processValue(value, processor);\n\n      if (isValidResult(result)) {\n        values[name] = result.value;\n        return true;\n      } else {\n        console.warn(getErrorMessage(`Invalid value passed for the ${name} option`, result));\n        return false;\n      }\n    };\n\n    const register = (name, spec) => {\n      const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n      const defaultValue = processDefaultValue(name, spec.default, processor);\n      registry[name] = { ...spec,\n        default: defaultValue,\n        processor\n      };\n      const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n      initValue.each(value => setValue(name, value, processor));\n    };\n\n    const isRegistered = name => has$2(registry, name);\n\n    const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n\n    const set = (name, value) => {\n      if (!isRegistered(name)) {\n        console.warn(`\"${name}\" is not a registered option. Ensure the option has been registered before setting a value.`);\n        return false;\n      } else {\n        const spec = registry[name];\n\n        if (spec.immutable) {\n          console.error(`\"${name}\" is an immutable option and cannot be updated`);\n          return false;\n        } else {\n          return setValue(name, value, spec.processor);\n        }\n      }\n    };\n\n    const unset = name => {\n      const registered = isRegistered(name);\n\n      if (registered) {\n        delete values[name];\n      }\n\n      return registered;\n    };\n\n    const isSet = name => has$2(values, name);\n\n    return {\n      register,\n      isRegistered,\n      get,\n      set,\n      unset,\n      isSet\n    };\n  };\n\n  const defaultModes = ['design', 'readonly'];\n\n  const switchToMode = (editor, activeMode, availableModes, mode) => {\n    const oldMode = availableModes[activeMode.get()];\n    const newMode = availableModes[mode];\n\n    try {\n      newMode.activate();\n    } catch (e) {\n      console.error(`problem while activating editor mode ${mode}:`, e);\n      return;\n    }\n\n    oldMode.deactivate();\n\n    if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n      toggleReadOnly(editor, newMode.editorReadOnly);\n    }\n\n    activeMode.set(mode);\n    fireSwitchMode(editor, mode);\n  };\n\n  const setMode = (editor, availableModes, activeMode, mode) => {\n    if (mode === activeMode.get()) {\n      return;\n    } else if (!has$2(availableModes, mode)) {\n      throw new Error(`Editor mode '${mode}' is invalid`);\n    }\n\n    if (editor.initialized) {\n      switchToMode(editor, activeMode, availableModes, mode);\n    } else {\n      editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n    }\n  };\n\n  const registerMode = (availableModes, mode, api) => {\n    if (contains$2(defaultModes, mode)) {\n      throw new Error(`Cannot override default mode ${mode}`);\n    }\n\n    return { ...availableModes,\n      [mode]: { ...api,\n        deactivate: () => {\n          try {\n            api.deactivate();\n          } catch (e) {\n            console.error(`problem while deactivating editor mode ${mode}:`, e);\n          }\n        }\n      }\n    };\n  };\n\n  const create$4 = editor => {\n    const activeMode = Cell('design');\n    const availableModes = Cell({\n      design: {\n        activate: noop,\n        deactivate: noop,\n        editorReadOnly: false\n      },\n      readonly: {\n        activate: noop,\n        deactivate: noop,\n        editorReadOnly: true\n      }\n    });\n    registerReadOnlyContentFilters(editor);\n    registerReadOnlySelectionBlockers(editor);\n    return {\n      isReadOnly: () => isReadOnly(editor),\n      set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n      get: () => activeMode.get(),\n      register: (mode, api) => {\n        availableModes.set(registerMode(availableModes.get(), mode, api));\n      }\n    };\n  };\n\n  const each$2 = Tools.each,\n        explode = Tools.explode;\n  const keyCodeLookup = {\n    f1: 112,\n    f2: 113,\n    f3: 114,\n    f4: 115,\n    f5: 116,\n    f6: 117,\n    f7: 118,\n    f8: 119,\n    f9: 120,\n    f10: 121,\n    f11: 122,\n    f12: 123\n  };\n  const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n\n  const isModifier = key => key in modifierNames;\n\n  const parseShortcut = pattern => {\n    const shortcut = {};\n    const isMac = Env.os.isMacOS() || Env.os.isiOS();\n    each$2(explode(pattern.toLowerCase(), '+'), value => {\n      if (isModifier(value)) {\n        shortcut[value] = true;\n      } else {\n        if (/^[0-9]{2,}$/.test(value)) {\n          shortcut.keyCode = parseInt(value, 10);\n        } else {\n          shortcut.charCode = value.charCodeAt(0);\n          shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n        }\n      }\n    });\n    const id = [shortcut.keyCode];\n    let key;\n\n    for (key in modifierNames) {\n      if (shortcut[key]) {\n        id.push(key);\n      } else {\n        shortcut[key] = false;\n      }\n    }\n\n    shortcut.id = id.join(',');\n\n    if (shortcut.access) {\n      shortcut.alt = true;\n\n      if (isMac) {\n        shortcut.ctrl = true;\n      } else {\n        shortcut.shift = true;\n      }\n    }\n\n    if (shortcut.meta) {\n      if (isMac) {\n        shortcut.meta = true;\n      } else {\n        shortcut.ctrl = true;\n        shortcut.meta = false;\n      }\n    }\n\n    return shortcut;\n  };\n\n  class Shortcuts {\n    constructor(editor) {\n      this.shortcuts = {};\n      this.pendingPatterns = [];\n      this.editor = editor;\n      const self = this;\n      editor.on('keyup keypress keydown', e => {\n        if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n          each$2(self.shortcuts, shortcut => {\n            if (self.matchShortcut(e, shortcut)) {\n              self.pendingPatterns = shortcut.subpatterns.slice(0);\n\n              if (e.type === 'keydown') {\n                self.executeShortcutAction(shortcut);\n              }\n            }\n          });\n\n          if (self.matchShortcut(e, self.pendingPatterns[0])) {\n            if (self.pendingPatterns.length === 1) {\n              if (e.type === 'keydown') {\n                self.executeShortcutAction(self.pendingPatterns[0]);\n              }\n            }\n\n            self.pendingPatterns.shift();\n          }\n        }\n      });\n    }\n\n    add(pattern, desc, cmdFunc, scope) {\n      const self = this;\n      const func = self.normalizeCommandFunc(cmdFunc);\n      each$2(explode(Tools.trim(pattern)), pattern => {\n        const shortcut = self.createShortcut(pattern, desc, func, scope);\n        self.shortcuts[shortcut.id] = shortcut;\n      });\n      return true;\n    }\n\n    remove(pattern) {\n      const shortcut = this.createShortcut(pattern);\n\n      if (this.shortcuts[shortcut.id]) {\n        delete this.shortcuts[shortcut.id];\n        return true;\n      }\n\n      return false;\n    }\n\n    normalizeCommandFunc(cmdFunc) {\n      const self = this;\n      const cmd = cmdFunc;\n\n      if (typeof cmd === 'string') {\n        return () => {\n          self.editor.execCommand(cmd, false, null);\n        };\n      } else if (Tools.isArray(cmd)) {\n        return () => {\n          self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n        };\n      } else {\n        return cmd;\n      }\n    }\n\n    createShortcut(pattern, desc, cmdFunc, scope) {\n      const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n      shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n        func: cmdFunc,\n        scope: scope || this.editor\n      });\n      return Tools.extend(shortcuts[0], {\n        desc: this.editor.translate(desc),\n        subpatterns: shortcuts.slice(1)\n      });\n    }\n\n    hasModifier(e) {\n      return e.altKey || e.ctrlKey || e.metaKey;\n    }\n\n    isFunctionKey(e) {\n      return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n    }\n\n    matchShortcut(e, shortcut) {\n      if (!shortcut) {\n        return false;\n      }\n\n      if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n        return false;\n      }\n\n      if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n        return false;\n      }\n\n      if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n        e.preventDefault();\n        return true;\n      }\n\n      return false;\n    }\n\n    executeShortcutAction(shortcut) {\n      return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n    }\n\n  }\n\n  const create$3 = () => {\n    const buttons = {};\n    const menuItems = {};\n    const popups = {};\n    const icons = {};\n    const contextMenus = {};\n    const contextToolbars = {};\n    const sidebars = {};\n    const views = {};\n\n    const add = (collection, type) => (name, spec) => {\n      collection[name.toLowerCase()] = { ...spec,\n        type\n      };\n    };\n\n    const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n\n    return {\n      addButton: add(buttons, 'button'),\n      addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n      addToggleButton: add(buttons, 'togglebutton'),\n      addMenuButton: add(buttons, 'menubutton'),\n      addSplitButton: add(buttons, 'splitbutton'),\n      addMenuItem: add(menuItems, 'menuitem'),\n      addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n      addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n      addAutocompleter: add(popups, 'autocompleter'),\n      addContextMenu: add(contextMenus, 'contextmenu'),\n      addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n      addContextForm: add(contextToolbars, 'contextform'),\n      addSidebar: add(sidebars, 'sidebar'),\n      addView: add(views, 'views'),\n      addIcon,\n      getAll: () => ({\n        buttons,\n        menuItems,\n        icons,\n        popups,\n        contextMenus,\n        contextToolbars,\n        sidebars,\n        views\n      })\n    };\n  };\n\n  const registry = () => {\n    const bridge = create$3();\n    return {\n      addAutocompleter: bridge.addAutocompleter,\n      addButton: bridge.addButton,\n      addContextForm: bridge.addContextForm,\n      addContextMenu: bridge.addContextMenu,\n      addContextToolbar: bridge.addContextToolbar,\n      addIcon: bridge.addIcon,\n      addMenuButton: bridge.addMenuButton,\n      addMenuItem: bridge.addMenuItem,\n      addNestedMenuItem: bridge.addNestedMenuItem,\n      addSidebar: bridge.addSidebar,\n      addSplitButton: bridge.addSplitButton,\n      addToggleButton: bridge.addToggleButton,\n      addGroupToolbarButton: bridge.addGroupToolbarButton,\n      addToggleMenuItem: bridge.addToggleMenuItem,\n      addView: bridge.addView,\n      getAll: bridge.getAll\n    };\n  };\n\n  const DOM$1 = DOMUtils.DOM;\n  const extend = Tools.extend,\n        each$1 = Tools.each;\n\n  class Editor {\n    constructor(id, options, editorManager) {\n      this.plugins = {};\n      this.contentCSS = [];\n      this.contentStyles = [];\n      this.loadedCSS = {};\n      this.isNotDirty = false;\n      this.composing = false;\n      this.destroyed = false;\n      this.hasHiddenInput = false;\n      this.iframeElement = null;\n      this.initialized = false;\n      this.readonly = false;\n      this.removed = false;\n      this.startContent = '';\n      this._pendingNativeEvents = [];\n      this._skinLoaded = false;\n      this._editableRoot = true;\n      this.editorManager = editorManager;\n      this.documentBaseUrl = editorManager.documentBaseURL;\n      extend(this, EditorObservable);\n      const self = this;\n      this.id = id;\n      this.hidden = false;\n      const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n      this.options = create$5(self, normalizedOptions);\n      register$7(self);\n      const getOption = this.options.get;\n\n      if (getOption('deprecation_warnings')) {\n        logWarnings(options, normalizedOptions);\n      }\n\n      const suffix = getOption('suffix');\n\n      if (suffix) {\n        editorManager.suffix = suffix;\n      }\n\n      this.suffix = editorManager.suffix;\n      const baseUrl = getOption('base_url');\n\n      if (baseUrl) {\n        editorManager._setBaseUrl(baseUrl);\n      }\n\n      this.baseUri = editorManager.baseURI;\n      const referrerPolicy = getReferrerPolicy(self);\n\n      if (referrerPolicy) {\n        ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n\n        DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n      }\n\n      const contentCssCors = hasContentCssCors(self);\n\n      if (isNonNullable(contentCssCors)) {\n        DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n      }\n\n      AddOnManager.languageLoad = getOption('language_load');\n      AddOnManager.baseURL = editorManager.baseURL;\n      this.setDirty(false);\n      this.documentBaseURI = new URI(getDocumentBaseUrl(self), {\n        base_uri: this.baseUri\n      });\n      this.baseURI = this.baseUri;\n      this.inline = isInline$1(self);\n      this.hasVisual = isVisualAidsEnabled(self);\n      this.shortcuts = new Shortcuts(this);\n      this.editorCommands = new EditorCommands(this);\n      registerCommands(this);\n      const cacheSuffix = getOption('cache_suffix');\n\n      if (cacheSuffix) {\n        Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n      }\n\n      this.ui = {\n        registry: registry(),\n        styleSheetLoader: undefined,\n        show: noop,\n        hide: noop,\n        setEnabled: noop,\n        isEnabled: always\n      };\n      this.mode = create$4(self);\n      editorManager.dispatch('SetupEditor', {\n        editor: this\n      });\n      const setupCallback = getSetupCallback(self);\n\n      if (isFunction(setupCallback)) {\n        setupCallback.call(self, self);\n      }\n    }\n\n    render() {\n      render(this);\n    }\n\n    focus(skipFocus) {\n      this.execCommand('mceFocus', false, skipFocus);\n    }\n\n    hasFocus() {\n      return hasFocus(this);\n    }\n\n    translate(text) {\n      return I18n.translate(text);\n    }\n\n    getParam(name, defaultVal, type) {\n      const options = this.options;\n\n      if (!options.isRegistered(name)) {\n        if (isNonNullable(type)) {\n          options.register(name, {\n            processor: type,\n            default: defaultVal\n          });\n        } else {\n          options.register(name, {\n            processor: always,\n            default: defaultVal\n          });\n        }\n      }\n\n      return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n    }\n\n    hasPlugin(name, loaded) {\n      const hasPlugin = contains$2(getPlugins(this), name);\n\n      if (hasPlugin) {\n        return loaded ? PluginManager.get(name) !== undefined : true;\n      } else {\n        return false;\n      }\n    }\n\n    nodeChanged(args) {\n      this._nodeChangeDispatcher.nodeChanged(args);\n    }\n\n    addCommand(name, callback, scope) {\n      this.editorCommands.addCommand(name, callback, scope);\n    }\n\n    addQueryStateHandler(name, callback, scope) {\n      this.editorCommands.addQueryStateHandler(name, callback, scope);\n    }\n\n    addQueryValueHandler(name, callback, scope) {\n      this.editorCommands.addQueryValueHandler(name, callback, scope);\n    }\n\n    addShortcut(pattern, desc, cmdFunc, scope) {\n      this.shortcuts.add(pattern, desc, cmdFunc, scope);\n    }\n\n    execCommand(cmd, ui, value, args) {\n      return this.editorCommands.execCommand(cmd, ui, value, args);\n    }\n\n    queryCommandState(cmd) {\n      return this.editorCommands.queryCommandState(cmd);\n    }\n\n    queryCommandValue(cmd) {\n      return this.editorCommands.queryCommandValue(cmd);\n    }\n\n    queryCommandSupported(cmd) {\n      return this.editorCommands.queryCommandSupported(cmd);\n    }\n\n    show() {\n      const self = this;\n\n      if (self.hidden) {\n        self.hidden = false;\n\n        if (self.inline) {\n          self.getBody().contentEditable = 'true';\n        } else {\n          DOM$1.show(self.getContainer());\n          DOM$1.hide(self.id);\n        }\n\n        self.load();\n        self.dispatch('show');\n      }\n    }\n\n    hide() {\n      const self = this;\n\n      if (!self.hidden) {\n        self.save();\n\n        if (self.inline) {\n          self.getBody().contentEditable = 'false';\n\n          if (self === self.editorManager.focusedEditor) {\n            self.editorManager.focusedEditor = null;\n          }\n        } else {\n          DOM$1.hide(self.getContainer());\n          DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n        }\n\n        self.hidden = true;\n        self.dispatch('hide');\n      }\n    }\n\n    isHidden() {\n      return this.hidden;\n    }\n\n    setProgressState(state, time) {\n      this.dispatch('ProgressState', {\n        state,\n        time\n      });\n    }\n\n    load(args = {}) {\n      const self = this;\n      const elm = self.getElement();\n\n      if (self.removed) {\n        return '';\n      }\n\n      if (elm) {\n        const loadArgs = { ...args,\n          load: true\n        };\n        const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n        const html = self.setContent(value, loadArgs);\n\n        if (!loadArgs.no_events) {\n          self.dispatch('LoadContent', { ...loadArgs,\n            element: elm\n          });\n        }\n\n        return html;\n      } else {\n        return '';\n      }\n    }\n\n    save(args = {}) {\n      const self = this;\n      let elm = self.getElement();\n\n      if (!elm || !self.initialized || self.removed) {\n        return '';\n      }\n\n      const getArgs = { ...args,\n        save: true,\n        element: elm\n      };\n      let html = self.getContent(getArgs);\n      const saveArgs = { ...getArgs,\n        content: html\n      };\n\n      if (!saveArgs.no_events) {\n        self.dispatch('SaveContent', saveArgs);\n      }\n\n      if (saveArgs.format === 'raw') {\n        self.dispatch('RawSaveContent', saveArgs);\n      }\n\n      html = saveArgs.content;\n\n      if (!isTextareaOrInput(elm)) {\n        if (args.is_removing || !self.inline) {\n          elm.innerHTML = html;\n        }\n\n        const form = DOM$1.getParent(self.id, 'form');\n\n        if (form) {\n          each$1(form.elements, elm => {\n            if (elm.name === self.id) {\n              elm.value = html;\n              return false;\n            } else {\n              return true;\n            }\n          });\n        }\n      } else {\n        elm.value = html;\n      }\n\n      saveArgs.element = getArgs.element = elm = null;\n\n      if (saveArgs.set_dirty !== false) {\n        self.setDirty(false);\n      }\n\n      return html;\n    }\n\n    setContent(content, args) {\n      return setContent(this, content, args);\n    }\n\n    getContent(args) {\n      return getContent(this, args);\n    }\n\n    insertContent(content, args) {\n      if (args) {\n        content = extend({\n          content\n        }, args);\n      }\n\n      this.execCommand('mceInsertContent', false, content);\n    }\n\n    resetContent(initialContent) {\n      if (initialContent === undefined) {\n        setContent(this, this.startContent, {\n          format: 'raw'\n        });\n      } else {\n        setContent(this, initialContent);\n      }\n\n      this.undoManager.reset();\n      this.setDirty(false);\n      this.nodeChanged();\n    }\n\n    isDirty() {\n      return !this.isNotDirty;\n    }\n\n    setDirty(state) {\n      const oldState = !this.isNotDirty;\n      this.isNotDirty = !state;\n\n      if (state && state !== oldState) {\n        this.dispatch('dirty');\n      }\n    }\n\n    getContainer() {\n      const self = this;\n\n      if (!self.container) {\n        self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n      }\n\n      return self.container;\n    }\n\n    getContentAreaContainer() {\n      return this.contentAreaContainer;\n    }\n\n    getElement() {\n      if (!this.targetElm) {\n        this.targetElm = DOM$1.get(this.id);\n      }\n\n      return this.targetElm;\n    }\n\n    getWin() {\n      const self = this;\n\n      if (!self.contentWindow) {\n        const elm = self.iframeElement;\n\n        if (elm) {\n          self.contentWindow = elm.contentWindow;\n        }\n      }\n\n      return self.contentWindow;\n    }\n\n    getDoc() {\n      const self = this;\n\n      if (!self.contentDocument) {\n        const win = self.getWin();\n\n        if (win) {\n          self.contentDocument = win.document;\n        }\n      }\n\n      return self.contentDocument;\n    }\n\n    getBody() {\n      var _a, _b;\n\n      const doc = this.getDoc();\n      return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n    }\n\n    convertURL(url, name, elm) {\n      const self = this,\n            getOption = self.options.get;\n      const urlConverterCallback = getUrlConverterCallback(self);\n\n      if (isFunction(urlConverterCallback)) {\n        return urlConverterCallback.call(self, url, elm, true, name);\n      }\n\n      if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n        return url;\n      }\n\n      const urlObject = new URI(url);\n\n      if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n        return url;\n      }\n\n      if (getOption('relative_urls')) {\n        return self.documentBaseURI.toRelative(url);\n      }\n\n      url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n      return url;\n    }\n\n    addVisual(elm) {\n      addVisual(this, elm);\n    }\n\n    setEditableRoot(state) {\n      setEditableRoot(this, state);\n    }\n\n    hasEditableRoot() {\n      return hasEditableRoot(this);\n    }\n\n    remove() {\n      remove$1(this);\n    }\n\n    destroy(automatic) {\n      destroy(this, automatic);\n    }\n\n    uploadImages() {\n      return this.editorUpload.uploadImages();\n    }\n\n    _scanForImages() {\n      return this.editorUpload.scanForImages();\n    }\n\n  }\n\n  const DOM = DOMUtils.DOM;\n  const each = Tools.each;\n  let boundGlobalEvents = false;\n  let beforeUnloadDelegate;\n  let editors = [];\n\n  const globalEventDelegate = e => {\n    const type = e.type;\n    each(EditorManager.get(), editor => {\n      switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n      }\n    });\n  };\n\n  const toggleGlobalEvents = state => {\n    if (state !== boundGlobalEvents) {\n      const DOM = DOMUtils.DOM;\n\n      if (state) {\n        DOM.bind(window, 'resize', globalEventDelegate);\n        DOM.bind(window, 'scroll', globalEventDelegate);\n      } else {\n        DOM.unbind(window, 'resize', globalEventDelegate);\n        DOM.unbind(window, 'scroll', globalEventDelegate);\n      }\n\n      boundGlobalEvents = state;\n    }\n  };\n\n  const removeEditorFromList = targetEditor => {\n    const oldEditors = editors;\n    editors = filter$5(editors, editor => {\n      return targetEditor !== editor;\n    });\n\n    if (EditorManager.activeEditor === targetEditor) {\n      EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n    }\n\n    if (EditorManager.focusedEditor === targetEditor) {\n      EditorManager.focusedEditor = null;\n    }\n\n    return oldEditors.length !== editors.length;\n  };\n\n  const purgeDestroyedEditor = editor => {\n    if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n      removeEditorFromList(editor);\n      editor.unbindAllNativeEvents();\n      editor.destroy(true);\n      editor.removed = true;\n    }\n  };\n\n  const isQuirksMode = document.compatMode !== 'CSS1Compat';\n  const EditorManager = { ...Observable,\n    baseURI: null,\n    baseURL: null,\n    defaultOptions: {},\n    documentBaseURL: null,\n    suffix: null,\n    majorVersion: '6',\n    minorVersion: '8.2',\n    releaseDate: '2023-12-11',\n    i18n: I18n,\n    activeEditor: null,\n    focusedEditor: null,\n\n    setup() {\n      const self = this;\n      let baseURL = '';\n      let suffix = '';\n      let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n\n      if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n        documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n\n        if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n          documentBaseURL += '/';\n        }\n      }\n\n      const preInit = window.tinymce || window.tinyMCEPreInit;\n\n      if (preInit) {\n        baseURL = preInit.base || preInit.baseURL;\n        suffix = preInit.suffix;\n      } else {\n        const scripts = document.getElementsByTagName('script');\n\n        for (let i = 0; i < scripts.length; i++) {\n          const src = scripts[i].src || '';\n\n          if (src === '') {\n            continue;\n          }\n\n          const srcScript = src.substring(src.lastIndexOf('/'));\n\n          if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n            if (srcScript.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n            break;\n          }\n        }\n\n        if (!baseURL && document.currentScript) {\n          const src = document.currentScript.src;\n\n          if (src.indexOf('.min') !== -1) {\n            suffix = '.min';\n          }\n\n          baseURL = src.substring(0, src.lastIndexOf('/'));\n        }\n      }\n\n      self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n      self.documentBaseURL = documentBaseURL;\n      self.baseURI = new URI(self.baseURL);\n      self.suffix = suffix;\n      setup$w(self);\n    },\n\n    overrideDefaults(defaultOptions) {\n      const baseUrl = defaultOptions.base_url;\n\n      if (baseUrl) {\n        this._setBaseUrl(baseUrl);\n      }\n\n      const suffix = defaultOptions.suffix;\n\n      if (suffix) {\n        this.suffix = suffix;\n      }\n\n      this.defaultOptions = defaultOptions;\n      const pluginBaseUrls = defaultOptions.plugin_base_urls;\n\n      if (pluginBaseUrls !== undefined) {\n        each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n          AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n        });\n      }\n    },\n\n    init(options) {\n      const self = this;\n      let result;\n      const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n\n      const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n\n      const createId = elm => {\n        let id = elm.id;\n\n        if (!id) {\n          id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n          elm.setAttribute('id', id);\n        }\n\n        return id;\n      };\n\n      const execCallback = name => {\n        const callback = options[name];\n\n        if (!callback) {\n          return;\n        }\n\n        return callback.apply(self, []);\n      };\n\n      const findTargets = options => {\n        if (Env.browser.isIE() || Env.browser.isEdge()) {\n          initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n          return [];\n        } else if (isQuirksMode) {\n          initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n          return [];\n        } else if (isString(options.selector)) {\n          return DOM.select(options.selector);\n        } else if (isNonNullable(options.target)) {\n          return [options.target];\n        } else {\n          return [];\n        }\n      };\n\n      let provideResults = editors => {\n        result = editors;\n      };\n\n      const initEditors = () => {\n        let initCount = 0;\n        const editors = [];\n        let targets;\n\n        const createEditor = (id, options, targetElm) => {\n          const editor = new Editor(id, options, self);\n          editors.push(editor);\n          editor.on('init', () => {\n            if (++initCount === targets.length) {\n              provideResults(editors);\n            }\n          });\n          editor.targetElm = editor.targetElm || targetElm;\n          editor.render();\n        };\n\n        DOM.unbind(window, 'ready', initEditors);\n        execCallback('onpageload');\n        targets = unique$1(findTargets(options));\n        Tools.each(targets, elm => {\n          purgeDestroyedEditor(self.get(elm.id));\n        });\n        targets = Tools.grep(targets, elm => {\n          return !self.get(elm.id);\n        });\n\n        if (targets.length === 0) {\n          provideResults([]);\n        } else {\n          each(targets, elm => {\n            if (isInvalidInlineTarget(options, elm)) {\n              initError('Could not initialize inline editor on invalid inline target element', elm);\n            } else {\n              createEditor(createId(elm), options, elm);\n            }\n          });\n        }\n      };\n\n      DOM.bind(window, 'ready', initEditors);\n      return new Promise(resolve => {\n        if (result) {\n          resolve(result);\n        } else {\n          provideResults = editors => {\n            resolve(editors);\n          };\n        }\n      });\n    },\n\n    get(id) {\n      if (arguments.length === 0) {\n        return editors.slice(0);\n      } else if (isString(id)) {\n        return find$2(editors, editor => {\n          return editor.id === id;\n        }).getOr(null);\n      } else if (isNumber(id)) {\n        return editors[id] ? editors[id] : null;\n      } else {\n        return null;\n      }\n    },\n\n    add(editor) {\n      const self = this;\n      const existingEditor = self.get(editor.id);\n\n      if (existingEditor === editor) {\n        return editor;\n      }\n\n      if (existingEditor === null) {\n        editors.push(editor);\n      }\n\n      toggleGlobalEvents(true);\n      self.activeEditor = editor;\n      self.dispatch('AddEditor', {\n        editor\n      });\n\n      if (!beforeUnloadDelegate) {\n        beforeUnloadDelegate = e => {\n          const event = self.dispatch('BeforeUnload');\n\n          if (event.returnValue) {\n            e.preventDefault();\n            e.returnValue = event.returnValue;\n            return event.returnValue;\n          }\n        };\n\n        window.addEventListener('beforeunload', beforeUnloadDelegate);\n      }\n\n      return editor;\n    },\n\n    createEditor(id, options) {\n      return this.add(new Editor(id, options, this));\n    },\n\n    remove(selector) {\n      const self = this;\n      let editor;\n\n      if (!selector) {\n        for (let i = editors.length - 1; i >= 0; i--) {\n          self.remove(editors[i]);\n        }\n\n        return;\n      }\n\n      if (isString(selector)) {\n        each(DOM.select(selector), elm => {\n          editor = self.get(elm.id);\n\n          if (editor) {\n            self.remove(editor);\n          }\n        });\n        return;\n      }\n\n      editor = selector;\n\n      if (isNull(self.get(editor.id))) {\n        return null;\n      }\n\n      if (removeEditorFromList(editor)) {\n        self.dispatch('RemoveEditor', {\n          editor\n        });\n      }\n\n      if (editors.length === 0) {\n        window.removeEventListener('beforeunload', beforeUnloadDelegate);\n      }\n\n      editor.remove();\n      toggleGlobalEvents(editors.length > 0);\n      return editor;\n    },\n\n    execCommand(cmd, ui, value) {\n      var _a;\n\n      const self = this;\n      const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n\n      switch (cmd) {\n        case 'mceAddEditor':\n          {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n\n            return true;\n          }\n\n        case 'mceRemoveEditor':\n          {\n            const editor = self.get(editorId);\n\n            if (editor) {\n              editor.remove();\n            }\n\n            return true;\n          }\n\n        case 'mceToggleEditor':\n          {\n            const editor = self.get(editorId);\n\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n\n            return true;\n          }\n      }\n\n      if (self.activeEditor) {\n        return self.activeEditor.execCommand(cmd, ui, value);\n      }\n\n      return false;\n    },\n\n    triggerSave: () => {\n      each(editors, editor => {\n        editor.save();\n      });\n    },\n    addI18n: (code, items) => {\n      I18n.add(code, items);\n    },\n    translate: text => {\n      return I18n.translate(text);\n    },\n\n    setActive(editor) {\n      const activeEditor = this.activeEditor;\n\n      if (this.activeEditor !== editor) {\n        if (activeEditor) {\n          activeEditor.dispatch('deactivate', {\n            relatedTarget: editor\n          });\n        }\n\n        editor.dispatch('activate', {\n          relatedTarget: activeEditor\n        });\n      }\n\n      this.activeEditor = editor;\n    },\n\n    _setBaseUrl(baseUrl) {\n      this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n      this.baseURI = new URI(this.baseURL);\n    }\n\n  };\n  EditorManager.setup();\n\n  const setup = () => {\n    const dataValue = value$2();\n\n    const FakeClipboardItem = items => ({\n      items,\n      types: keys(items),\n      getType: type => get$a(items, type).getOrUndefined()\n    });\n\n    const write = data => {\n      dataValue.set(data);\n    };\n\n    const read = () => dataValue.get().getOrUndefined();\n\n    const clear = dataValue.clear;\n    return {\n      FakeClipboardItem,\n      write,\n      read,\n      clear\n    };\n  };\n\n  const FakeClipboard = setup();\n  const min = Math.min,\n        max = Math.max,\n        round = Math.round;\n\n  const relativePosition = (rect, targetRect, rel) => {\n    let x = targetRect.x;\n    let y = targetRect.y;\n    const w = rect.w;\n    const h = rect.h;\n    const targetW = targetRect.w;\n    const targetH = targetRect.h;\n    const relChars = (rel || '').split('');\n\n    if (relChars[0] === 'b') {\n      y += targetH;\n    }\n\n    if (relChars[1] === 'r') {\n      x += targetW;\n    }\n\n    if (relChars[0] === 'c') {\n      y += round(targetH / 2);\n    }\n\n    if (relChars[1] === 'c') {\n      x += round(targetW / 2);\n    }\n\n    if (relChars[3] === 'b') {\n      y -= h;\n    }\n\n    if (relChars[4] === 'r') {\n      x -= w;\n    }\n\n    if (relChars[3] === 'c') {\n      y -= round(h / 2);\n    }\n\n    if (relChars[4] === 'c') {\n      x -= round(w / 2);\n    }\n\n    return create$2(x, y, w, h);\n  };\n\n  const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n    for (let i = 0; i < rels.length; i++) {\n      const pos = relativePosition(rect, targetRect, rels[i]);\n\n      if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n        return rels[i];\n      }\n    }\n\n    return null;\n  };\n\n  const inflate = (rect, w, h) => {\n    return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n  };\n\n  const intersect = (rect, cropRect) => {\n    const x1 = max(rect.x, cropRect.x);\n    const y1 = max(rect.y, cropRect.y);\n    const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n    const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n\n    if (x2 - x1 < 0 || y2 - y1 < 0) {\n      return null;\n    }\n\n    return create$2(x1, y1, x2 - x1, y2 - y1);\n  };\n\n  const clamp = (rect, clampRect, fixedSize) => {\n    let x1 = rect.x;\n    let y1 = rect.y;\n    let x2 = rect.x + rect.w;\n    let y2 = rect.y + rect.h;\n    const cx2 = clampRect.x + clampRect.w;\n    const cy2 = clampRect.y + clampRect.h;\n    const underflowX1 = max(0, clampRect.x - x1);\n    const underflowY1 = max(0, clampRect.y - y1);\n    const overflowX2 = max(0, x2 - cx2);\n    const overflowY2 = max(0, y2 - cy2);\n    x1 += underflowX1;\n    y1 += underflowY1;\n\n    if (fixedSize) {\n      x2 += underflowX1;\n      y2 += underflowY1;\n      x1 -= overflowX2;\n      y1 -= overflowY2;\n    }\n\n    x2 -= overflowX2;\n    y2 -= overflowY2;\n    return create$2(x1, y1, x2 - x1, y2 - y1);\n  };\n\n  const create$2 = (x, y, w, h) => {\n    return {\n      x,\n      y,\n      w,\n      h\n    };\n  };\n\n  const fromClientRect = clientRect => {\n    return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n  };\n\n  const Rect = {\n    inflate,\n    relativePosition,\n    findBestRelativePosition,\n    intersect,\n    clamp,\n    create: create$2,\n    fromClientRect\n  };\n\n  const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n    let done = false;\n    let timer = null;\n\n    const complete = completer => (...args) => {\n      if (!done) {\n        done = true;\n\n        if (timer !== null) {\n          clearTimeout(timer);\n          timer = null;\n        }\n\n        completer.apply(null, args);\n      }\n    };\n\n    const resolve = complete(resolveCb);\n    const reject = complete(rejectCb);\n\n    const start = (...args) => {\n      if (!done && timer === null) {\n        timer = setTimeout(() => reject.apply(null, args), timeout);\n      }\n    };\n\n    return {\n      start,\n      resolve,\n      reject\n    };\n  };\n\n  const create$1 = () => {\n    const tasks = {};\n    const resultFns = {};\n    const resources = {};\n\n    const load = (id, url) => {\n      const loadErrMsg = `Script at URL \"${url}\" failed to load`;\n      const runErrMsg = `Script at URL \"${url}\" did not call \\`tinymce.Resource.add('${id}', data)\\` within 1 second`;\n\n      if (tasks[id] !== undefined) {\n        return tasks[id];\n      } else {\n        const task = new Promise((resolve, reject) => {\n          const waiter = awaiter(resolve, reject);\n          resultFns[id] = waiter.resolve;\n          ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n        });\n        tasks[id] = task;\n        return task;\n      }\n    };\n\n    const add = (id, data) => {\n      if (resultFns[id] !== undefined) {\n        resultFns[id](data);\n        delete resultFns[id];\n      }\n\n      tasks[id] = Promise.resolve(data);\n      resources[id] = data;\n    };\n\n    const has = id => {\n      return id in resources;\n    };\n\n    const unload = id => {\n      delete tasks[id];\n    };\n\n    const get = id => resources[id];\n\n    return {\n      load,\n      add,\n      has,\n      get,\n      unload\n    };\n  };\n\n  const Resource = create$1();\n\n  const create = () => (() => {\n    let data = {};\n    let keys = [];\n    const storage = {\n      getItem: key => {\n        const item = data[key];\n        return item ? item : null;\n      },\n      setItem: (key, value) => {\n        keys.push(key);\n        data[key] = String(value);\n      },\n      key: index => {\n        return keys[index];\n      },\n      removeItem: key => {\n        keys = keys.filter(k => k === key);\n        delete data[key];\n      },\n      clear: () => {\n        keys = [];\n        data = {};\n      },\n      length: 0\n    };\n    Object.defineProperty(storage, 'length', {\n      get: () => keys.length,\n      configurable: false,\n      enumerable: false\n    });\n    return storage;\n  })();\n\n  let localStorage;\n\n  try {\n    const test = '__storage_test__';\n    localStorage = window.localStorage;\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n  } catch (e) {\n    localStorage = create();\n  }\n\n  var LocalStorage = localStorage;\n  const publicApi = {\n    geom: {\n      Rect\n    },\n    util: {\n      Delay,\n      Tools,\n      VK,\n      URI,\n      EventDispatcher,\n      Observable,\n      I18n,\n      LocalStorage,\n      ImageUploader\n    },\n    dom: {\n      EventUtils,\n      TreeWalker: DomTreeWalker,\n      TextSeeker,\n      DOMUtils,\n      ScriptLoader,\n      RangeUtils,\n      Serializer: DomSerializer,\n      StyleSheetLoader,\n      ControlSelection,\n      BookmarkManager,\n      Selection: EditorSelection,\n      Event: EventUtils.Event\n    },\n    html: {\n      Styles,\n      Entities,\n      Node: AstNode,\n      Schema,\n      DomParser,\n      Writer,\n      Serializer: HtmlSerializer\n    },\n    Env,\n    AddOnManager,\n    Annotator,\n    Formatter,\n    UndoManager,\n    EditorCommands,\n    WindowManager,\n    NotificationManager,\n    EditorObservable,\n    Shortcuts,\n    Editor,\n    FocusManager,\n    EditorManager,\n    DOM: DOMUtils.DOM,\n    ScriptLoader: ScriptLoader.ScriptLoader,\n    PluginManager,\n    ThemeManager,\n    ModelManager,\n    IconManager,\n    Resource,\n    FakeClipboard,\n    trim: Tools.trim,\n    isArray: Tools.isArray,\n    is: Tools.is,\n    toArray: Tools.toArray,\n    makeMap: Tools.makeMap,\n    each: Tools.each,\n    map: Tools.map,\n    grep: Tools.grep,\n    inArray: Tools.inArray,\n    extend: Tools.extend,\n    walk: Tools.walk,\n    resolve: Tools.resolve,\n    explode: Tools.explode,\n    _addCacheSuffix: Tools._addCacheSuffix\n  };\n  const tinymce$1 = Tools.extend(EditorManager, publicApi);\n\n  const exportToModuleLoaders = tinymce => {\n    if (typeof module === 'object') {\n      try {\n        module.exports = tinymce;\n      } catch (_) {}\n    }\n  };\n\n  const exportToWindowGlobal = tinymce => {\n    window.tinymce = tinymce;\n    window.tinyMCE = tinymce;\n  };\n\n  exportToWindowGlobal(tinymce$1);\n  exportToModuleLoaders(tinymce$1);\n})();","map":{"version":3,"sources":["/home/wassef/Bureau/lastversion/frontend/node_modules/tinymce/tinymce.js"],"names":["typeOf$1","x","undefined","t","Array","prototype","isPrototypeOf","constructor","name","String","isEquatableType","indexOf","sort$1","xs","compareFn","clone","slice","call","sort","contramap","eqa","f","eq$2","y","eq","tripleEq","eqString","eqArray","length","len","i","eqSortedArray","eqRecord","kx","Object","keys","ky","q","eqAny","tx","ty","getPrototypeOf$2","getPrototypeOf","hasProto","v","predicate","_a","typeOf","isArray","o","proto","isType$1","type","value","isSimpleType","eq$1","a","is$4","isObject","isString","isPlainObject","isArray$1","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","isArrayOf","pred","noop","compose","fa","fb","args","apply","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","concat","not","die","msg","Error","apply$1","never","always","Optional","tag","some","none","singletonNone","fold","onNone","onSome","isSome","isNone","map","mapper","bind","binder","exists","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","from","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeSlice","nativeIndexOf","nativePush","push","rawIndexOf","ts","indexOf$1","r","contains$2","map$3","each$e","eachr","partition$2","pass","fail","arr","filter$5","foldr","acc","foldl","findUntil$1","until","find$2","findIndex$2","flatten","bind$3","reverse","difference","a1","a2","mapToObject","comparator","copy","get$b","head","last$3","findMap","unique$1","isDuplicated","hasOwnProperty$1","hasOwnProperty","each$d","obj","props","k","map$2","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","bifilter","filter$4","mapToArray","values","get$a","key","has$2","hasNonNullableKey","equal$1","stringArray","isArrayLike","toArray$1","array","l","each$c","cb","s","n","map$1","callback","out","item","index","filter$3","reduce","collection","iteratee","accumulator","thisArg","findIndex$1","last$2","cached","called","DeviceType","os","browser","userAgent","mediaMatch","isiPad","isiOS","test","isiPhone","isMobile","isAndroid","isTouch","isTablet","isPhone","iOSwebview","isSafari","isDesktop","isWebView","firstMatch","regexes","find$1","agent","major","minor","group","Number","replace","nu$3","detect$5","versionRegexes","cleanedAgent","toLowerCase","unknown$2","Version","nu","detect","unknown","detectBrowser$1","browsers","userAgentData","brands","uaBrand","lcBrand","brand","info","current","version","parseInt","detect$4","candidates","candidate","search","detectBrowser","detectOs","oses","removeFromStart","str","numChars","substring","checkRange","substr","start","removeLeading","prefix","startsWith","contains$1","end","idx","endsWith","suffix","blank","trim$4","lTrim","rTrim","isNotEmpty","isEmpty$3","repeat","count","join","toInt","radix","num","isNaN","normalVersionRegex","checkContains","target","uastring","PlatformInfo","edge","chromium","ie","opera","firefox","safari","unknown$1","nu$2","isBrowser","isEdge","isChromium","isIE","isOpera","isFirefox","Browser","windows","ios","android","linux","macos","solaris","freebsd","chromeos","nu$1","isOS","isWindows","isMacOS","isLinux","isSolaris","isFreeBSD","isChromeOS","OperatingSystem","detect$3","userAgentDataOpt","deviceType","PlatformDetection","query","window","matchMedia","matches","platform$4","navigator","detect$2","platform$3","browser$3","os$1","windowsPhone","Env","transparentSrc","documentMode","document","cacheSuffix","container","canHaveCSP","whiteSpaceRegExp$1","trim$3","is$3","makeMap$4","items","delim","resolvedItems","split","extend$3","exts","ext","walk$4","resolve$3","path","explode$3","d","_addCacheSuffix","url","Tools","trim","is","makeMap","grep","inArray","hasOwn","extend","walk","resolve","explode","is$2","lhs","rhs","left","equals","lift2","cat","oa","ob","lift3","oc","someIf","Global","Function","parts","scope","resolve$2","p","unsafe","actual","getPrototypeOf$1","sandHTMLElement","COMMENT","DOCUMENT","DOCUMENT_FRAGMENT","ELEMENT","TEXT","element","dom","nodeName","type$1","nodeType","isType","isComment$1","isHTMLElement$1","isElement$7","isText$b","isDocument$2","isDocumentFragment$1","isTag","e","rawSet","setAttribute","console","error","set$3","setAll$1","attrs","get$9","getAttribute","getOpt","has$1","hasAttribute","remove$a","removeAttribute","hasNone","attributes","clone$4","attr","read$4","add$4","id","old","remove$9","supports","classList","get$8","add$3","clazz","remove$8","toggle$2","add$2","add","cleanClass","remove$7","remove","toggle$1","result","toggle","has","contains","fromHtml$1","html","doc","div","createElement","innerHTML","hasChildNodes","childNodes","fromDom$2","fromTag","node","fromText","text","createTextNode","fromPoint$2","docElm","elementFromPoint","SugarElement","fromHtml","fromDom","fromPoint","recurse","cur","is$1","selector","elem","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","bypassSelector","childElementCount","base","querySelectorAll","one","querySelector","e1","e2","d1","d2","owner$1","ownerDocument","documentOrOwner","dos","documentElement","defaultView","parent","parentNode","parentElement","parents$1","isRoot","stop","ret","rawParent","siblings","filterSelf","elements","children$1","prevSibling","previousSibling","nextSibling","prevSiblings","nextSiblings","child$1","cs","firstChild","lastChild","childNodesCount","getHead","isShadowRoot","host","supported","Element","attachShadow","Node","getRootNode","isSupported$1","getStyleContainer","getContentContainer","body","getShadowRoot","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composed","composedPath","shadowRoot","inBody","ClosestOrAncestor","ancestor","ancestor$4","closest$4","sibling$1","child","descendant$2","descend","res","ancestor$3","descendant$1","closest$3","closest$2","isEditable$2","assumeEditable","isContentEditable","editable","getRaw$1","contentEditable","isSupported","style","getPropertyValue","internalSet","property","setProperty","internalRemove","removeProperty","set$2","setAll","css","get$7","styles","getComputedStyle","getUnsafeProperty","getRaw","raw","getAllRaw","ruleName","remove$6","reflow","offsetWidth","before$3","marker","parent$1","insertBefore","after$4","sibling","append$1","prepend","firstChild$1","appendChild","wrap$2","wrapper","after$3","append","empty","textContent","rogue","remove$5","removeChild","unwrap","children","fromDom$1","nodes","get$6","set$1","content","owner","docDom","fragment","createDocumentFragment","contentElements","getOuter","cloneNode","mkEvent","prevent","kill","fromRawEvent","rawEvent","stopPropagation","preventDefault","clientX","clientY","handle$1","handler","useCapture","wrapped","addEventListener","unbind","bind$2","removeEventListener","top","translate","SugarPosition","boxPosition","box","getBoundingClientRect","firstDefinedOrZero","absolute","win","offsetLeft","offsetTop","scrollTop","pageYOffset","scrollLeft","pageXOffset","clientTop","clientLeft","viewport","get$5","_DOC","to","scrollTo","intoView","alignToTop","scrollIntoViewIfNeeded","scrollIntoView","get$4","_win","visualViewport","bounds","width","height","right","bottom","getBounds","scroll","clientWidth","clientHeight","Math","max","pageLeft","pageTop","descendants$1","descendants","ancestor$2","DomTreeWalker","startNode","rootNode","next","prev","prev2","shallow","findSibling","findPreviousNode","startName","siblingName","isNodeType","isRestrictedNode","isElement$6","isHTMLElement","isSVGElement","namespaceURI","matchNodeName","lowerCasedName","matchNodeNames","names","lowerCasedNames","matchStyleValues","computed","cssValue","attrName","hasAttributeValue","attrValue","isBogus$2","isBogusAll$1","isTable$2","tagName","hasContentEditableState","isTextareaOrInput","isText$a","isCData","isPi","isComment","isDocument$1","isDocumentFragment","isBr$6","isImg","isContentEditableTrue$3","isContentEditableFalse$b","isTableCell$3","isTableCellOrCaption","isMedia$2","isListItem$2","isDetails","isSummary$1","zeroWidth","nbsp","isZwsp$2","char","removeZwsp","NodeValue","get","getOption","nodeValue","set","api$1","get$3","tableCells","tableSections","textBlocks","listItems$1","lists","wsElements","lazyLookup","lookup","isTable$1","isBr$5","isTextBlock$2","isList","isListItem$1","isTableSection","isTableCell$2","isWsPreserveElement","getLastChildren$1","elm","rawNode","removeTrailingBr","allBrs","brs","createPaddingBr","br","fillWithPaddingBr","trimBlockTrailingBr","schema","lastChildPrevSibling","isBlock","ZWSP$1","isZwsp$1","trim$2","insert$5","editor","insertContent","preserve_zwsp","isElement$5","isText$9","isCaretContainerBlock$1","isCaretContainerInline","data","isCaretContainer$2","hasContent","insertInline$1","before","textNode","startsWithCaretContainer$1","splitText","endsWithCaretContainer$1","isBeforeInline","pos","charAt","offset","isAtStart","isAfterInline","isAtEnd","insertBlock","blockName","blockNode","trimBogusBr","getElementsByTagName","lastBr","showCaretContainerBlock","caretContainer","isRangeInCaretContainerBlock","range","startContainer","isContentEditableTrue$2","isContentEditableFalse$a","isBr$4","isText$8","isInvalidTextElement","isAtomicInline","isTable","isCaretContainer$1","isCaretCandidate$3","isNonUiContentEditableFalse","isUnselectable","isInEditable","root","tempNode","isAtomicContentEditableFalse","isAtomic$1","isEditableCaretCandidate$1","whiteSpaceRegExp","isWhitespaceText","isZwsp","c","isCollapsibleWhitespace$1","isNewLineChar","isNewline","normalize$4","tabSpaces","isStartOfContent","isEndOfContent","tabSpace","normalizedText","pcIsSpace","hasWhitespacePreserveParent","rootElement","isWhitespace$1","isNamedAnchor","isContent$1","isBookmark","isBogus$1","isBogusAll","hasNonEditableParent","isEmptyNode","targetNode","skipBogus","brCount","walker","isEmpty$2","isNonHtmlElementRootName","isNonHtmlElementRoot","toScopeType","namespaceElements","createNamespaceTracker","scopes","peek","track","currentScope","pop","reset","transparentBlockAttr","elementNames","makeSelectorFromSchemaMap","ns","updateTransparent","blocksSelector","transparent","updateBlockStateOnChildren","transparentSelector","getTransparentElements","getBlockElements","trimEdge","leftSide","childPropertyName","split$2","parentElm","splitElm","createRange","setStartBefore","setEndBefore","beforeFragment","extractContents","setStartAfter","setEndAfter","afterFragment","splitInvalidChildren","transparentBlocks","blocksElements","transparentBlock","parentBlock","invalidChildren","isValidChild","stateScope","unwrapInvalidChildren","isTransparentBlock","block","isTransparentInline","updateChildren","updateElement","isTransparentElement","updateCaret","caretParent","parents","hasBlockAttr","isTransparentElementName","isTransparentAstBlock","browser$2","firstElement","getTableCaptionDeltaY","caption","bodyTop","captionTop","captionHeight","offsetHeight","hasChild","getPos","rootElm","offsetParent","castOffsetParent","StyleSheetLoader","documentOrShadowRoot","settings","idCount","loadedStates","edos","_setReferrerPolicy","referrerPolicy","_setContentCssCors","contentCssCors","addStyle","removeStyle","styleContainer","getOrCreateState","passed","failed","load","Promise","success","failure","link","urlWithSuffix","state","callbacks","status","onload","onerror","linkElem","rel","loadRawCss","styleElem","loadAll","urls","loadedUrls","allSettled","then","results","reject","reason","unload","unloadRawCss","unloadAll","create$d","WeakMap","forElement","referenceElement","rootDom","sl","instance","isSpan","isInlineContent","isInline","surroundedByInlineContent","prevIsInline","nextIsInline","isBookmarkNode$2","isKeepTextNode","isKeepElement","isDocument","trimNode","currentChildren","makeMap$3","attrsCharsRegExp","textCharsRegExp","rawCharsRegExp","entityRegExp","asciiMap","baseEntities","reverseEntities","nativeDecode","innerText","buildEntitiesLookup","itemList","chr","fromCharCode","entity","namedEntities","encodeRaw","encodeAllRaw","encodeNumeric","charCodeAt","encodeNamed","entities","resolveEntities","getEncodeFunc","entitiesMap","encodeNamedAndNumeric","encodeCustomNamed","nameMap","named","numeric","decode","Entities","split$1","patternToRegExp","RegExp","parseCustomElementsRules","customElementRegExp","rule","exec","inline","cloneName","getElementSetsAsStrings","globalAttributes","blockContent","phrasingContent","transparentContent","html4PhrasingContent","html4BlockContent","flowContent","makeSchema","addElement","attributesOrder","childNames","ni","allAttributes","addAttrs","schemaItem","video","audio","table","script","prefixToOperation","parseValidChildrenRules","childRuleRegExp","operation","validChildren","parseValidElementsAttrDataIntoElement","attrData","targetElement","attrRuleRegExp","hasPatternsRegExp","attrType","attrPrefix","attributesRequired","required","splice","attributesDefault","defaultValue","attributesForced","forcedValue","validValues","attrPattern","attributePatterns","pattern","cloneAttributesInto","parseValidElementsRules","globalElement","validElements","elementRuleRegExp","elementName","outputName","attrsPrefix","paddEmpty","removeEmpty","removeEmptyAttrs","aliasName","mapCache","makeMap$2","each$b","extend$2","explode$2","createMap","extendWith","toUpperCase","getTextRootBlockElements","getTextBlockElements","compileElementMap","mode","Schema","patternElements","customElementsMap","specialElements","createLookupTable","option","newValue","schemaType","schemaItems","verify_html","valid_elements","validStyles","valid_styles","invalidStyles","invalid_styles","validClasses","valid_classes","whitespaceElementsMap","selfClosingElementsMap","voidElementsMap","boolAttrMap","nonEmptyOrMoveCaretBeforeOnEnter","nonEmptyElementsMap","moveCaretBeforeOnEnterElementsMap","headings","textBlockElementsMap","blockElementsMap","textInlineElementsMap","transparentElementsMap","wrapBlockElementsMap","addValidElements","patternElement","setValidElements","addCustomElements","customElements","text_block_elements","block_elements","customRule","elmName","addValidChildren","getElementRule","_val","padd_empty_block_inline_children","paddInEmptyBlock","svg","custom_elements","valid_children","extended_valid_elements","dd","dt","li","td","th","tr","tbody","thead","tfoot","legend","area","param","parentsRequired","invalid_elements","getValidStyles","getInvalidStyles","getValidClasses","getBoolAttrs","getTextInlineElements","getVoidElements","seal","getSelfClosingElements","getNonEmptyElements","getMoveCaretBeforeOnEnterElements","getWhitespaceElements","getWrapBlockElements","getSpecialElements","isValid","attrPatterns","isWrapper","getCustomElements","hexColour","normalizeHex","hex","toHex","component","fromRgba","rgbaColour","red","green","blue","rgbRegex","rgbaRegex","alpha","fromStringValues","g","parseFloat","fromString","rgbaString","rgbMatch","rgbaMatch","rgba","rgbaToHexString","color","h","Styles","urlOrStrRegExp","styleRegExp","trimRightRegExp","encodingLookup","invisibleChar","encodingItems","self","parse","isEncoded","urlConverter","url_converter","urlConverterScope","url_converter_scope","compress","noJoin","canCompress","compress2","encode","keepSlashes","decodeSingleHexSequence","escSeq","decodeHexSequences","processUrl","match","url2","url3","str2","allow_script_urls","scriptUrl","allow_svg_data_urls","lastIndex","force_hex_color","border","serialize","serializeStyles","elemName","validStyleList","styleList","styleMap","deprecated","keyLocation","layerX","layerY","returnValue","webkitMovementX","webkitMovementY","keyIdentifier","mozPressure","isNativeEvent","Event","initEvent","hasIsDefaultPrevented","isDefaultPrevented","needsNormalizing","clone$3","originalEvent","getModifierState","keyArg","getTargetRanges","normalize$3","fallbackTarget","srcElement","defaultPrevented","cancelBubble","isPropagationStopped","stopImmediatePropagation","isImmediatePropagationStopped","eventExpandoPrefix","mouseEventRe","addEvent","capture","removeEvent","isMouseEvent","fix","pageX","eventDoc","mouseEvent","pageY","bindOnReady","eventUtils","domLoaded","isDocReady","readyState","readyHandler","EventUtils","events","expando","Date","hasFocusIn","callbackList","defaultNativeHandler","evt","executeHandlers","namesList","nativeHandler","fakeName","func","eventMap","ci","newCallbackList","ex","fire","dispatch","parentWindow","clean","destroy","cancel","each$a","internalStyleName","numericalCssMap","legacySetAttribute","camelCaseToHyphens","findNodeIndex","normalized","lastNodeType","updateInternalStyleAttr","rawValue","convertStyleToString","cssName","applyStyle$1","$elm","normalizedName","setupAttrHooks","getContext","keepValues","keep_values","keepUrlHook","sugarElm","internalName","attrHooks","href","src","DOMUtils","addedStyles","files","counter","stdMode","boxModel","styleSheetLoader","boundEvents","ownEvents","getElementById","_get","getAttrib","defaultVal","hook","getAttribs","setAttrib","run","val","originalValue","onSetAttrib","attrElm","deep","getRoot","root_element","getViewPort","argWin","vp","w","getPos$1","setStyle","update_styles","setStyles","stylesArg","getStyle","getSize","getRect","size","elms","getParents","collect","resolvedRoot","selectorVal","getParent","_findSib","getNext","getPrev","isParentNode","select","_b","context","setAttribs","setHTML","create","newElm","createHTML","outHtml","createFragment","frag","keepChildren","$node","removeAllAttribs","removeAttributeNode","parseStyle","cssText","serializeStyle","DOM","styleElm","styleSheet","loadCSS","catch","toggleClass","cls","classes","addClass","removeClass","hasClass","show","hide","isHidden","uniqueId","getOuterHTML","outerHTML","setOuterHTML","insertAfter","reference","referenceNode","oldElm","replacee","replaceChild","rename","attrNode","findCommonAncestor","ps","pe","isNonEmptyElement","isEmpty","options","whitespaceElements","nonEmptyElements","bogusVal","includeZwsp","createRng","replacementElm","setStart","setEnd","rv","boundTarget","boundName","boundFunc","getContentEditable","getContentEditableParent","isEditable","_","isChildOf","dumpRng","startOffset","endContainer","endOffset","nodeIndex","DOM$b","QUEUED","LOADING","LOADED","FAILED","ScriptLoader","states","queue","scriptLoadedCallbacks","queueLoadedCallbacks","loading","loadScript","cleanup","done","isDone","markDone","loadQueue","loadScripts","scripts","execCallbacks","processResults","failures","processQueue","nextQueuedItem","shift","uniqueScripts","Cell","initial","firstIndex","isRaw","isTokenised","currentCode","getLanguageData","getData$1","setCode","newCode","getCode","add$1","code","langData","lcNames","translation","lcName","getLangData","textStr","removeContext","substitued","$1","$2","isRtl$1","dir","hasCode","I18n","getData","isRtl","AddOnManager","_listeners","runListeners","matchedListeners","listener","isLoaded","isAdded","loadLanguagePack","languages","language","wrappedLanguages","requireLangPack","languageLoad","waitFor","addOn","createUrl","baseUrl","dep","resource","addOnUrl","urlString","baseURL","lastIndexOf","PluginManager","ThemeManager","ModelManager","singleton","doRevoke","subject","revoke","clear","isSet","repeatable","delay","intervalId","clearInterval","functionToRepeat","setInterval","value$2","on","first$1","rate","timer","clearTimeout","throttle","setTimeout","last$1","annotation","dataAnnotation","dataAnnotationId","dataAnnotationActive","dataAnnotationClasses","dataAnnotationAttributes","isRoot$1","identify","annotationName","rng","selection","getRng","getBody","an","newStart","closest","uid","findMarkers","isAnnotation","isBogusElement","descendant","findAll","markers","directory","m","nodesAlready","setup$y","registry","changeCallbacks","initData","listeners","previous","withCallbacks","updateCallbacks","callbackMap","outputData","fireCallbacks","fireNoAnnotation","toggleActiveAttr","onNodeChange","annotations","getNames","addListener","setup$x","dataAnnotation$1","identifyParserNode","removeDirectAnnotation","customAttrNames","customClasses","newClassList","serializer","addTempAttr","addAttributeFilter","persistent","create$c","register","unique","generate$1","date","time","getTime","random","floor","remove$4","clone$2","original","isDeep","shallow$1","deep$1","shallowAs","mutate","TextWalker","isBoundary","direction","TextSeeker","isBlockBoundary","process","newOffset","backwards","forwards","round$2","round","clone$1","rect","collapse","toStart","isEqual","rect1","rect2","isValidOverflow","overflowY","min","isAbove$1","halfHeight","isBelow$1","containsXY","boundingClientRectFromRects","rects","prevRect","distanceToRectEdgeFromXY","cx","cy","sqrt","overlapY","r1","r2","clamp$2","getSelectedNode","getNode$1","safeOffset","getNodeUnsafe","extendingChars","isExtendingChar","ch","and","isElement$4","isCaretCandidate$2","isBlock$2","isFloated","isValidElementCaretCandidate","isNotPre","isText$7","isBr$3","nodeIndex$1","resolveIndex$1","createRange$1","isWhiteSpace$1","isRange","isHiddenWhiteSpaceRange","getBrClientRect","brNode","nbsp$1","clientRect","getBoundingClientRectWebKitText","sc","ec","so","eo","newRng","cloneRange","getBoundingClientRect$1","isZeroRect","clientRects","getClientRects","collapseAndInflateWidth","newClientRect","getCaretPositionClientRects","caretPosition","addUniqueAndValidRect","addCharacterOffset","beforeNode","CaretPosition","toRange","isVisible","getNode","fromRangeStart","fromRangeEnd","after","isAbove","pos1","pos2","isBelow","isTextPosition","isElementPosition","trimEmptyTextNode$1","insertNode","insertFragment","rangeInsertNode","isText$6","isBogus","normalizedParent","getChildNodes","normalizedTextOffset","equal","normalizedNodeIndex","numTextFragments","createPathItem","parentsUntil$1","create$b","outputOffset","resolvePathItem","findTextPosition","targetOffset","dataLen","resolve$1","paths","nodeOffset","isContentEditableFalse$9","getNormalizedTextOffset$1","trimmedOffset","getPoint","point","getLocation","forward","isForward","fakeCaret","isFakeCaret","isCollapsed","findIndex","moveEndPoint$1","normalizeTableCellSelection","findAdjacentContentEditableFalseElm","getOffsetBookmark","getCaretBookmark","getRangeBookmark","createBookmarkSpan","filled","getPersistentBookmark","collapsed","rng2","endBookmarkNode","startBookmarkNode","moveToBookmark","keep","getBookmark$2","getUndoBookmark","value$1","applyHelper","constHelper","outputHelper","output","inner","_onError","onValue","isValue","isError","Result","mapError","toOptional","onError","_onValue","fromOption","optional","err","generate","cases","constructors","adt","acase","keys$1","argLength","branches","branchKeys","allReqd","reqKey","foldArgs","log","label","params","Adt","bothErrors","firstError","secondError","bothValues","partition$1","errors","isInlinePattern","isBlockPattern","normalizePattern","formatOrCmd","onFormat","onCommand","format","formats","cmd","command","commandValue","getBlockPatterns","patterns","getInlinePatterns","createPatternSet","dynamicPatternsLookup","inlinePatterns","blockPatterns","fromRawPatterns","fromRawPatternsLookup","lookupFn","ctx","rawPatterns","deviceDetection$1","DOM$a","getHash","isRegExp","stringOrObjectProcessor","bodyOptionProcessor","valid","bodyObj","register$7","registerOption","processor","default","documentBaseUrl","isInline$1","hasPlugin","convertURL","_ctx","getElement","getIframeAttrs","getDocType","getDocumentBaseUrl","getBodyId","getBodyClass","getContentSecurityPolicy","shouldPutBrInPre$1","getForcedRootBlock","getForcedRootBlockAttrs","getNewlineBehavior","getBrNewLineSelector","getNoNewLineSelector","shouldKeepStyles","shouldEndContainerOnEmptyBlock","isAutomaticUploadsEnabled","shouldReuseFileName","shouldReplaceBlobUris","getIconPackName","getIconsUrl","getImageUploadUrl","getImageUploadBasePath","getImagesUploadCredentials","getImagesUploadHandler","shouldUseContentCssCors","getReferrerPolicy","getLanguageCode","getLanguageUrl","shouldIndentUseMargin","getIndentation","getContentCss","getContentStyle","getFontCss","getDirectionality","getInlineBoundarySelector","getObjectResizing","getResizeImgProportional","getPlaceholder","getEventRoot","getServiceMessage","getTheme","getThemeUrl","getModel","getModelUrl","isInlineBoundariesEnabled","getFormats","getPreviewStyles","canFormatEmptyLines","getFormatNoneditableSelector","getCustomUiSelector","hasHiddenInput","shouldPatchSubmit","shouldAddFormSubmitTrigger","shouldAddUnloadTrigger","getCustomUndoRedoLevels","shouldDisableNodeChange","isReadOnly$1","hasEditableRoot$1","hasContentCssCors","getPlugins","getExternalPlugins$1","shouldBlockUnsupportedDrop","isVisualAidsEnabled","getVisualAidsTableClass","getVisualAidsAnchorClass","getIframeAriaText","getSetupCallback","getInitInstanceCallback","getUrlConverterCallback","getAutoFocus","shouldBrowserSpellcheck","getProtect","shouldPasteBlockDrop","shouldPasteDataImages","getPastePreProcess","getPastePostProcess","getNewDocumentContent","getPasteWebkitStyles","shouldPasteRemoveWebKitStyles","shouldPasteMergeFormats","isSmartPasteEnabled","isPasteAsTextEnabled","getPasteTabSpaces","shouldAllowHtmlDataUrls","getTextPatterns","getTextPatternsLookup","getNonEditableClass","getEditableClass","getNonEditableRegExps","shouldPreserveCData","shouldHighlightOnFocus","shouldSanitizeXss","shouldUseDocumentWrite","hasTextPatternsLookup","getFontStyleValues","getFontSizeClasses","isEncodingXml","getAllowedImageFileTypes","hasTableTabNavigation","getDetailsInitialState","getDetailsSerializedState","shouldForceHexColor","shouldSandboxIframes","isElement$3","isText$5","removeNode$1","trimCount","trimmedText","deleteZwspChars","deleteData","removeUnchanged","remove$3","removeTextAndReposition","removeElementAndReposition","newPosition","removeTextCaretContainer","removeElementCaretContainer","removeAndReposition","caretContainerNode","isContentEditableFalse$8","isMedia$1","isTableCell$1","inlineFakeCaretSelector","getAbsoluteClientRect","scrollX","scrollY","rootRect","margin","trimInlineCaretContainers","fakeCaretTargetNodes","FakeCaret","hasFocus","lastVisualCaret","cursorInterval","caretBlock","caret","startBlink","isInlineFakeCaretTarget","caretState","reposition","getCss","isFakeCaretTableBrowser","isFakeCaretTarget","isTarget","isContentEditableTrue$1","isContentEditableFalse$7","isMedia","isBlockLike","isCaretContainer","isCaretContainerBlock","isElement$2","isText$4","isCaretCandidate$1","isForwards","isBackwards","skipCaretContainers","findNode","predicateFn","isCefOrCaretContainer","getEditingHost","isCETrue","getParentBlock$3","isInSameBlock","caretPosition1","caretPosition2","getChildNodeAtRelativeOffset","relativeOffset","beforeAfter","isNodesInSameBlock","node1","node2","lean","before$2","after$2","normalizeRange","leanLeft","leanRight","location","getRelativeCefElm","getNormalizedRangeEndPoint","normalizedRange","getElementFromPosition","getElementFromPrevPosition","getVisualCaretPosition","walkFn","isMoveInsideSameBlock","inSameBlock","HDirection","isContentEditableFalse$6","isText$3","isElement$1","isBr$2","isCaretCandidate","isAtomic","isEditableCaretCandidate","getParents$3","nodeAtIndex","getCaretCandidatePosition","moveForwardFromBr","nextNode","findCaretPosition$1","Forwards","startPos","innerNode","rootContentEditableFalseElm","CaretWalker","Backwards","walkToPositionIn","position","fromPosition","afterElement","isBeforeOrStart","isAfterOrEnd","isBeforeAfterSameElement","isAtBr","shouldSkipPosition","navigate","navigateIgnore","ignoreFilter","positionIn","nextPosition","prevPosition","firstPositionIn","lastPositionIn","CARET_ID","isCaretNode","getParentCaretContainer","currentNode","isStringPathBookmark","bookmark","isRangeBookmark","isIdBookmark","isIndexBookmark","isPathBookmark","isForwardBookmark","addBogus","resolveCaretPositionBookmark","endPos","insertZwsp","isEmpty$1","tryFindRangePosition","padEmptyCaretContainer","setEndPoint","isValidTextNode","restoreEndPoint","markerParent","otherMarker","appendData","resolvePaths","resolveId","spos","epos","resolveIndex","selectNode","getBookmark$1","setRng","isBookmarkNode$1","expected","isNbsp","isWhiteSpace","isContent","getRanges$1","ranges","rangeCount","getRangeAt","getSelectedNodes","hasMultipleRanges","getCellsFromRanges","getCellsFromElement","getCellsFromElementOrRanges","selectedCells","getCellsFromEditor","getSel","getClosestTable","cell","getStartNode","getEndNode","getFirstChildren","getLastChildren","hasAllContentsSelected","endNode","moveEndPoint","hasAnyRanges","sel","runOnRanges","executor","fakeSelectionNodes","fakeNodeRng","preserve","fillBookmark","isNode","isElementNode$1","isElementDirectlySelected","selectedAttr","preserveSelection","action","shouldMoveStart","selectedNodeBeforeAction","isSelectedBeforeNodeNoneditable","isBeforeNodeStillNoneditable","getStart","moveStartToNearestText","selectedNode","isWhiteSpaceNode$1","getNonWhiteSpaceSibling","inc","nextName","isTextBlock$1","ed","allowSpaces","isEmptyTextNode$1","isWrapNoneditableTarget","baseDataSelector","formatNoneditableSelector","isWrappableNoneditable","replaceVars","vars","isEq$5","str1","normalizeStyleValue","strValue","getTextDecoration","decoration","getParents$2","isFormatPredicate","formatName","formatter","isVariableFormatName","hasVariableValues","isVariableValue","field","fieldValues","areSimilarFormats","otherFormatName","validKeys","filterObj","validKey","fmt1","filteredFmt1","fmt2","filteredFmt2","isBlockFormat","isWrappingBlockFormat","isNonWrappingBlockFormat","isSelectorFormat","isInlineFormat","isMixedFormat","shouldExpandToSelector","expand","getEmptyCaretContainers","isCaretContainerEmpty","isEmptyCaretFormatElement","isBookmarkNode","getParents$1","isWhiteSpaceNode","isTextBlock","isBogusBr","findParentContentEditable","walkText","findSpace","findContent","findWordEndPoint","includeTrailingSpaces","lastTextNode","textSeeker","textOffset","spaceResult","findSelectorEndPoint","formatList","curFormat","findBlockEndPoint","scopeRoot","isAtBlockBoundary$1","findParentContainer","block_expand","isSelfOrParentBookmark","expandRng","includeTrailingSpace","startPoint","endPoint","walk$3","exclude","firstNode","lastNode","collectSiblings","findEndPoint","walkBoundary","validBlocks","isZeroWidth","wrapName","applyWordGrab","applyAnnotation","masterUId","decorate","directAnnotation","otherData","attributeNames","makeAnnotation","eDoc","master","annotate","newWrappers","getDoc","finishWrapper","getOrOpenWrapper","processElements","elems","processElement","processNodes","annotateWithBookmark","undoManager","transact","initialRng","hasFakeSelection","masterUid","selectionRng","Annotator","changes","removeAnnotations","annotationChanged","getBookmark","removeAll","getAll","BookmarkManager","isXYWithinRange","firePreProcess","firePostProcess","fireRemove","fireDetach","fireSwitchMode","fireObjectResizeStart","origin","fireObjectResized","firePreInit","firePostRender","fireInit","firePlaceholderToggle","fireError","errorType","fireFormatApply","fireFormatRemove","fireBeforeSetContent","fireSetContent","fireBeforeGetContent","fireGetContent","fireAutocompleterStart","fireAutocompleterUpdate","fireAutocompleterEnd","firePastePreProcess","internal","firePastePostProcess","firePastePlainTextToggle","fireEditableRootStateChange","VK","BACKSPACE","DELETE","DOWN","ENTER","ESC","LEFT","RIGHT","SPACEBAR","TAB","UP","PAGE_UP","PAGE_DOWN","END","HOME","modifierPressed","shiftKey","ctrlKey","altKey","metaKeyPressed","metaKey","elementSelectionAttr","controlElmSelector","abs","round$1","resizeHandles","nw","ne","se","sw","isTouchEvent","ControlSelection","editableDoc","rootDocument","selectedElm","selectedElmGhost","resizeHelper","selectedHandle","resizeBackdrop","startX","startY","selectedElmX","selectedElmY","startW","startH","ratio","resizeStarted","startScrollWidth","startScrollHeight","isImage","isEventOnImageOutsideRange","touch","touches","contextMenuSelectImage","getResizeTargets","firstElementChild","isResizable","createGhostElement","setSizeProp","targets","setGhostElmSize","ghostElm","resizeGhostElement","deltaX","deltaY","proportional","resizeHelperX","resizeHelperY","screenX","screenY","display","scrollWidth","scrollHeight","endGhostResize","wasResizeStarted","showResizeRect","nodeChanged","targetElm","unbindResizeHandleEvents","targetWidth","targetHeight","hideResizeRect","handle","startDrag","handleElm","throttledShowResizeRect","removeSelected","isChildOrEqual","updateResizeRect","removed","composing","controlElm","selectedValue","img","disableGeckoResize","startElm","getEnd","execCommand","situ","setFinish","relativeToNative","startSitu","finishSitu","exactToNative","soffset","finish","foffset","adt$3","ltr","rtl","fromRange","getRanges","domRange","relative","exact","doDiagnose","reversed","rev","diagnose","create$a","SimRange","caretPositionFromPoint","offsetNode","caretRangeFromPoint","availableSearch","fromPoint$1","adt$2","cata","onBefore","onOn","onAfter","getStart$2","before$1","after$1","Situ","adt$1","exactFromRange","simRange","getStart$1","_finishSitu","_soffset","_finish","_foffset","getWin","SimSelection","beforeSpecial","name$1","preprocessRelative","preprocessExact","preprocess","fromElements","toNative","getDomRange","filtered","getAtPoint","isEq$4","rng1","findParent","hasParent$1","hasParentWithName","isCeFalseCaretContainer","hasBrBeforeAfter","isPrevNode","hasContentEditableFalseParent","findTextNodeRelative","isAfterNode","lastInlineElement","parentBlockContainer","normalizeEndPoint","directionLeft","normalize$2","normRng","newContainer","RangeUtils","normalize","normalizedRng","rangeLike","newRange","compareRanges","getCaretRangeFromPoint","Dimension","getOffset","aggregate","properties","cumulativeInclusions","absoluteMax","api","get$2","getDocument","walkUp","navigation","frame","view","rest","pathTo","frameElement","Navigation","freeze","__proto__","find","frames","loc","excludeFromDescend","fireScrollIntoViewEvent","scrollEvent","fireAfterScrollIntoViewEvent","last","markerInfo","cleanupFun","createMarker$1","span","elementMarker","withMarker","preserveWith","_s","_e","applyWithMarker","withScrollEvents","withElement","startElement","endElement","scrollToMarker","viewHeight","intoWindowIfNeeded","viewportBottom","markerTop","markerBottom","largerThanViewport","align","intoWindow","innerHeight","intoFrame","frameViewHeight","op","viewportBounds","rangeIntoWindow","elementIntoWindow","rangeIntoFrame","elementIntoFrame","scrollElementIntoView","scroller","scrollRangeIntoView","focus$1","preventScroll","focus","hasFocus$1","activeElement","active$1","clamp$1","normalizeRng","isOrContains","isRngInRoot","shouldStore","nativeRangeToSelectionRange","readRange","getSelection","validate","bookmarkToNativeRng","store","newBookmark","restore","isEditorUIElement$1","className","FocusManager","isEditorUIElement","wrappedSetTimeout","wrappedSetInterval","Delay","setEditorTimeout","setEditorInterval","isManualNodeChange","selectionChange","registerPageMouseUp","throttledStore","mouseUpPage","registerMouseUp","registerEditorEvents","register$6","documentFocusInHandler","DOM$9","isEditorContentAreaElement","isUIElement","customSelector","getActiveElement","registerEvents$1","editorManager","toggleContentAreaOnFocus","contentArea","getContainer","focusedEditor","setActive","blurredEditor","activeEditor","unregisterDocumentEvents","setup$w","getContentEditableHost","getCollapsedNode","getFocusInElement","normalizeSelection","caretPos","focusBody","hasElementFocus","hasIframeFocus","iframeElement","hasInlineFocus","rawBody","hasUiFocus","hasEditorOrUiFocus","focusEditor","quirks","refreshContentEditable","bookmarkRng","contentEditableHost","activateEditor","skipFocus","isEditableRange","getEndpointElement","real","getEnd$1","skipEmptyTextNodes","orig","commonAncestorContainer","getSelectedBlocks","endElm","selectedBlocks","processRanges","isTextNodeWithCursorPosition","isContentEditableFalse$5","elementsWithCursorPosition","isCursorPosition","hasCursorPosition","first","descendantRtl","autocompleteSelector","create$9","findIn","setCursorLocation","detect$1","remove$2","typeLookup","walk$2","isEmptyTextNode","AstNode","insert","selfAttrs","cloneAttrs","selfAttr","wrap","refNode","whitespace","unescapedTextParents","containsZwsp","includes","getTemporaryNodeSelector","tempAttrs","getTemporaryNodes","createZwspCommentWalker","createTreeWalker","NodeFilter","SHOW_COMMENT","FILTER_ACCEPT","FILTER_SKIP","createUnescapedZwspTextWalker","SHOW_TEXT","hasZwspComment","hasUnescapedZwspText","hasTemporaryNode","trimTemporaryNodes","emptyAllNodeValuesInWalker","curr","emptyZwspComments","emptyUnescapedZwspTexts","trim$1","conditionalTrims","condition","trimmed","cloned","cleanupBogusElements","bogusElements","bogusValue","cleanupInputNames","inputs","input","trimEmptyContents","emptyRegExp","getPlainTextContent","offscreenDiv","getContentFromBody","getTempAttrs","shouldTrim","getContentInternal","makeMap$1","Writer","indent","indentBefore","indent_before","indentAfter","indent_after","entity_encoding","htmlOutput","element_format","cdata","comment","pi","doctype","getContent","HtmlSerializer","writer","handlers","sortedAttrs","elementRule","nonInheritableStyles","Set","nonInheritableStylesArr","shorthandStyleProps","getStyleProps","isNonInheritableStyle","hasInheritableStyles","getLonghandStyleProps","prop","hasStyleConflict","nodeStyleProps","parentNodeStyleProps","valueMismatch","parentValue","nodeStyleProp","propExists","longhandProps","isChar","delta","isBeforeSpace","isAfterSpace","isEmptyText","matchesElementPosition","isImageBlock","isCefNode","isBeforeImageBlock","isAfterImageBlock","isBeforeMedia","isAfterMedia","isBeforeTable","isAfterTable","isBeforeContentEditableFalse","isAfterContentEditableFalse","dropLast","parentsUntil","parentsAndSelf","navigateIgnoreEmptyTextNodes","isBlock$1","getClosestBlock$1","isAtBeforeAfterBlockBoundary","newPos","fromBlock","isAtBlockBoundary","isAtStartOfBlock","isAtEndOfBlock","isBeforeBlock","isAfterBlock","isBr$1","findBr","parentBlocks","isBeforeBr$1","isAfterBr","findPreviousBr","findNextBr","isInMiddleOfText","getClosestBlock","hasSpaceBefore","hasSpaceAfter","isPreValue","isInPre","isAtBeginningOfBody","isAtEndOfBody","isAtLineBoundary","isCefBlock","isSiblingCefBlock","isBeforeCefBlock","nextPos","isNextCefBlock","isAfterCefBlock","prevPos","isPrevCefBlock","needsToHaveNbsp","needsToBeNbspLeft","needsToBeNbspRight","needsToBeNbsp","isNbspAt","isWhiteSpaceAt","hasNbsp","normalizeNbspMiddle","chars","normalizeNbspAtStart","makeNbsp","firstPos","normalizeNbspInMiddleOfTextNode","newText","normalizeNbspAtEnd","lastPos","normalizeNbsps","normalizeNbspsInEditor","normalize$1","replaceData","normalizeWhitespaceAfter","whitespaceCount","normalizeWhitespaceBefore","mergeTextNodes","prevNode","normalizeWhitespace","mergeToPrev","whitespaceOffset","newNode","removeNode","insertData","needsReposition","beforeOrStartOf","afterOrEndOf","getPreviousSiblingCaretPosition","getNextSiblingCaretPosition","findCaretPositionBackwardsFromElm","findCaretPositionForwardsFromElm","findCaretPositionBackwards","findCaretPositionForward","findCaretPosition","findCaretPosOutsideElmAfterDelete","setSelection$1","eqRawNode","paddEmptyBlock","preserveEmptyCaret","deleteNormalized","afterDeletePosOpt","prevTextOpt","nextTextOpt","isInlineElement","deleteElement$2","moveCaret","afterDeletePos","normalizedAfterDeletePos","setContent","paddPos","strongRtl","hasStrongRtl","isInlineTarget","findInlineParents","findRootInline","hasSameParentBlock","block1","block2","isAtZwsp","normalizePosition","normalizeForwards","normalizeBackwards","execCommandIgnoreInputEvents","inputBlocker","off","execEditorDeleteCommand","execNativeDeleteCommand","execNativeForwardDeleteCommand","isBeforeRoot","isTextBlockOrListItem","getParentBlock$2","paddEmptyBody","moveSelection","no_selection","willDeleteLastPositionInElement","fromPos","normalizedFirstPos","normalizedLastPos","normalizedFromPos","freefallRtl","deleteRangeContents","deleteContents","lastBlock","additionalCleanupNodes","ancestor$1","isRootFromElement","getTableCells","getTable$1","selectionInTableWithNestedTable","details","startTable","endTable","isStartTableParentOfEndTable","isEndTableParentOfStartTable","isSameTable","isMultiTable","adjustQuirksInDetails","getTableDetailsFromRange","isStartInTable","isEndInTable","tableCellRng","tableSelection","cells","deleteAction","singleCellTable","fullTable","partialTable","multiTable","getClosestCell$1","isExpandedCellRng","cellRng","getTableFromCellRng","startParentTable","endParentTable","isSingleCellTable","rows","getCellRng","startCell","endCell","getCellRangeFromStartTable","getCellRangeFromEndTable","getTableSelectionFromCellRng","getTableSelections","selectionDetails","sameTableSelection","startTableSelection","endTableSelection","getCellIndex","getSelectedCells","startIndex","endIndex","isSingleCellTableContentSelected","optCellRng","unselectCells","otherContentRng","handleSingleTable","handleMultiTable","startTableSelectedCells","endTableSelectedCells","getActionFromRange","cleanCells","getOutsideBlock","handleEmptyBlock","startInTable","emptyBlock","deleteContentInsideCell","isFirstCellInSelection","insideTableRng","deleteCellContents","collapseAndRestoreCellSelection","emptySingleTableCells","outsideDetails","editorRng","cellsToClean","outsideBlock","endPointCell","emptyMultiTableCells","startTableCells","endTableCells","betweenRng","startTableCellsToClean","endTableCellsToClean","deleteTableElement","deleteCellRange","deleteCaptionRange","emptyElement","deleteTableRange","getParentCaption","deleteRange$3","getParentCell","deleteBetweenCells","fromCell","toCell","isDeleteOfLastCharPos","fromCaption","emptyCaretCaption","validateCaretCaption","toCaption","deleteCaretInsideCaption","deleteCaretCells","deleteCaretCaption","isNearTable","isBeforeOrAfterTable","deleteCaret$3","backspaceDelete$a","getContentEditableRoot$1","internalAttributesPrefixes","each$9","ElementUtils","internalAttributes","compare","attribs","isAttributeInternal","compareObjects","obj1","obj2","attributeName","isHeading","isSummary","traverse","matchNode$1","nodeFilters","attributeFilters","nl","ai","al","findMatchingNodes","childNode","runFilters","matchRecord","filteringAttributes","valueMatches","filter$2","paddEmptyNode","brPreferred","pad_empty_with_br","astNode","isPaddedWithNbsp","hasOnlyChild","isPadded","isLineBreakNode","findClosestEditingHost","editableNode","removeOrUnwrapInvalidNode","originalNodeParent","cleanInvalidNodes","onCreate","textBlockElements","nonSplittableElements","fixed","isSplittableElement","newParent","isInvalid","hasClosest","parentName","normalizeBlockSelectionRange","newEndPos","hasOnlyOneChild$1","isPaddingNode","isPaddedEmptyBlock","blockElements","isEmptyFragmentElement","isListFragment","cleanupDomFragment","domFragment","toDomFragment","listItems","isPadding","isListItemPadded","isEmptyOrPadded","trimListItems","getParentLi","isParentBlockLi","getSplit","beforeRng","afterRng","cloneContents","findFirstIn","caretWalker","newCaretPos","findLastOf","insertMiddle","insertBefore$2","insertAfter$2","insertAtCaret$1","liTarget","liElms","BEGINNING","isAt","newPosNode","mergeableWrappedElements","shouldPasteContentOnly","isPastingSingleElement","isWrappedElement","isPastingInTheSameBlockTag","isPastingInContentEditable","isTableCell","isTableCellContentSelected","validInsertion","no_events","trimBrsFromTableCell","reduceInlineTextElements","merge","textInlineElements","elementUtils","styleConflict","markFragmentElements","unmarkFragmentElements","isPartOfFragment","canHaveChildren","moveSelectionToMarker","_c","nextRng","parentEditableElm","findNextCaretRng","isCell","deleteSelectedContent","findMarkerNode","markerNode","notHeadingsInSummary","insertHtmlAtCaret","parser","bookmarkHtml","caretElement","parserArgs","paste","_selectionOverrides","showBlockCaretContainer","invalid","editingHost","toExtract","getNodeFilters","getAttributeFilters","isTreeNode","setEditorHtml","noSelection","setContentString","padd","forcedRootBlockName","isRootContent","trimmedHtml","setContentTree","setContentInternal","ensureIsRoot","transform","transformed","closest$1","isEq$3","matchesUnInheritedFormatSelector","inherit","matchParents","similar","matchedNode","matchNode","matchName","matchItems","itemName","matchAttributes","onmatch","expectedValue","isEmptyValue","match$2","matchAll","matchedFormatNames","checkedMap","rawElm","canApply","matchAllOnNode","formatNames","matchSimilar","ZWSP","importNode","findFirstTextNode","createCaretContainer","fill","trimZwspFromCaretContainer","removeCaretContainerNode","removeCaretContainer","insertCaretContainerNode","formatNode","appendNode","insertFormatNodesIntoCaretContainer","formatNodes","innerMostFormatNode","cleanFormatNode","validFormats","matchedFormats","uniqueFormats","fmtName","clonedFormatNode","applyCaretFormat","wordcharRegex","removeCaretFormat","hasContentAfter","expandedRng","parentsAfter","newCaretContainer","cleanedFormatNode","caretTextNode","disableCaretContainer","keyCode","endsWithNbsp","setup$v","createCaretFormat","innerMost","replaceWithCaretFormat","createCaretFormatAtStart$1","isFormatElement","inlineElements","postProcessHooks","isPre","addPostProcessHook","hooks","postProcess$1","hasPreSibling","blocks","pre","joinPre","pre1","pre2","sPre2","preBlocks","listItemStyles","hasListStyles","fmt","findExpandedListItemFormat","getExpandedListItemFormat","isRngStartAtStartOfElement","isRngEndAtEndOfElement","isEditableListItem","getFullySelectedBlocks","middle","getFullySelectedListItems","getPartiallySelectedListItems","each$8","isElementNode","findElementSibling","mergeSiblingsNodes","isPrevEditable","isNextEditable","tmpSibling","mergeSiblings","merge_siblings","clearChildStyles","clear_child_styles","links","_value","processChildElements","unwrapEmptySpan","hasStyle","applyStyle","removeResult","MCE_ATTR_RE","each$7","isEq$2","isTableCellOrRow","isChildOfInlineParent","lastIdx","normalizeTableSelection","wrap$1","wrapWithSiblings","isColorFormatAndAnchor","rootBlockElm","forcedRootBlock","list_block","processFormatAttrOrStyle","removeEmptyStyleAttributeIfNeeded","removeStyles","compareNode","stylesModified","styleName","styleValue","normalizedStyleValue","remove_similar","removeListStyleFormats","liFmt","removeNodeFormatInternal","ceFalseOverride","preserveAttributes","preserve_attributes","attrsToPreserve","currentValue","valueOut","findFormatRoot","formatRoot","removeNodeFormatFromClone","newName","wrapAndSplit","lastClone","firstClone","formatRootParent","mixed","removeFormatInternal","splitToFormatRoot","isRemoveBookmarkNode","removeFormatOnNode","removeNodeFormat","currentNodeMatches","textDecorations","textDecoration","removeRngStyle","removeFormat$1","each$6","mergeTextDecorationsAndColor","processTextDecorationsAndColor","parentTextDecoration","mergeBackgroundColorAndFontSize","backgroundColor","hasFontSize","mergeSubSup","inverseTagDescendants","mergeWithChildren","mergeWithParents","merge_with_parents","each$5","canFormatBR","validBRParentElements","hasCaretNodeSibling","applyStyles","styleVal","applyFormatAction","setElementFormat","onformat","applyNodeStyle","found","createWrapElement","wrapElm","applyRngStyle","nodeSpecific","isMatchingWrappingBlock","canRenameBlock","isEditableDescendant","isValidBlockFormatForNode","canWrapNode","isWrappableNoneditableElm","isValidWrapNode","isCaret","isCorrectFormatForNode","currentWrapElm","lastContentEditable","contentEditableValue","getChildCount","mergeStyles","childElement","childCount","fake","applyFormat$1","hasVars","setup$u","registeredFormatListeners","updateAndFireChangeCallbacks","nodeOrRange","fallbackElement","matchingNode","isMatchingNode","matchingFormat","isUnableToMatch","registeredCallbacks","runIfChanged","spec","withSimilar","withoutSimilar","withVars","addListeners","formatChangeItems","getCurrent","toAppendTo","removeListeners","formatChangedInternal","explode$1","create$8","filters","addFilter","getFilters","removeFilter","newCallbacks","removeAttrs","addFontToSpansFilter","domParser","fontSizes","addNodeFilter","face","addStrikeFilter","convertToSTag","addFilters","convert_fonts_to_spans","font_size_legacy_values","register$5","inline_styles","htmlParser","prevName","lastParent","blobUriToBlob","fetch","ok","blob","uriType","extractBase64Data","parseDataUri","uri","base64Encoded","extractedData","decodeURIComponent","buildBlob","atob","Uint8Array","Blob","dataUriToBlob","uriToBlob","blobToDataUri","reader","FileReader","onloadend","readAsDataURL","count$1","uniqueId$1","processDataUri","dataUri","base64Only","generateBlobInfo","base64","btoa","createBlobInfo$1","blobCache","blobInfo","dataUriToBlobInfo","getByData","imageToBlobInfo","imageSrc","invalidDataUri","getByUri","isBogusImage","isInternalImageSource","registerBase64ImageFilter","blob_cache","processImage","inputSrc","blobUri","isMimeType","mime","createSafeEmbed","sandboxIframes","embed","register$4","remove_trailing_brs","appendRel","addNoOpener","newRel","allow_unsafe_link_target","allow_html_in_named_anchor","fix_list_elements","classValue","validClassesMap","convert_unsafe_embeds","sandbox_iframes","entries","setPrototypeOf","isFrozen","getOwnPropertyDescriptor","create$7","construct","Reflect","fun","thisValue","Func","arrayForEach","unapply","forEach","arrayPop","arrayPush","stringToLowerCase","stringToString","stringMatch","stringReplace","stringIndexOf","stringTrim","regExpTest","typeErrorCreate","unconstruct","TypeError","_len","arguments","_key","_len2","_key2","addToSet","transformCaseFunc","_transformCaseFunc","lcElement","object","newObject","lookupGetter","desc","fallbackValue","warn","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","EXPRESSIONS","getGlobal","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","createPolicy","ATTR_NAME","policyName","createScriptURL","createDOMPurify","DOMPurify","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","getNextSibling","getParentNode","template","trustedTypesPolicy","emptyHTML","implementation","createNodeIterator","createHTMLDocument","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","enumerable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","SANITIZE_NAMED_PROPS_PREFIX","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","DEFAULT_PARSER_MEDIA_TYPE","CONFIG","formElement","isRegexOrFunction","testValue","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","TRUSTED_TYPES_POLICY","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","parentTagName","Boolean","_forceRemove","_removeAttribute","attribute","getAttributeNode","_initDocument","dirty","leadingWhitespace","dirtyPayload","parseFromString","createDocument","_createIterator","SHOW_ELEMENT","_isClobbered","_isNode","_executeHook","entryPoint","_sanitizeElements","allowedTags","_basicCustomElementTest","_isValidAttribute","lcTag","_sanitizeAttributes","hookEvent","keepAttr","allowedAttributes","initValue","forceKeepAttr","getAttributeType","setAttributeNS","_sanitizeShadowDOM","shadowNode","shadowIterator","sanitize","importedNode","returnNode","nodeIterator","shadowroot","shadowrootmode","serializedHTML","setConfig","clearConfig","isValidAttribute","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","purify","each$4","queryParts","DEFAULT_PORTS","ftp","http","https","mailto","safeSvgDataUrlElements","blockSvgDataUris","allowSvgDataUrls","decodeUri","encodedUri","unescape","isInvalidUri","decodedUri","allow_html_data_urls","URI","uriComponents","isDomSafe","protocol","pathname","baseUri","base_uri","source","isProtocolRelative","toAbsPath","urlMatch","part","userInfo","port","setPath","pathMatch","file","getURI","toRelative","relativeUri","tu","uu","toRelPath","anchor","toAbsolute","noHost","absoluteUri","isSameOrigin","defaultPort","breakPoint","normalizedBase","nb","normalizedPath","baseParts","pathParts","outPath","noProtoHost","filteredUrlAttrs","internalElementAttr","processNode","_d","allow_conditional_comments","lcTagName","isInternalElement","bogus","processAttr","ele","shouldKeepAttribute","isBooleanAttribute","isRequiredAttributeOfInternalElement","filterAttributes","setupPurify","namespaceTracker","purify$1","getPurifyConfig","mimeType","basePurifyConfig","config","sanitizeNamespaceElement","xlinkAttrs","getSanitizer","sanitizeHtmlElement","_mimeType","extend$1","transferChildren","nativeParent","nsSanitizer","isSpecial","nativeChild","walkTree","preprocessors","postprocessors","traverseOrder","postprocess","whitespaceCleaner","textRootBlockElements","allWhiteSpaceRegExp","startWhiteSpaceRegExp","endWhiteSpaceRegExp","hasWhitespaceParent","isTextRootBlockEmpty","isAtEdgeOfBlock","neighbour","isNodeEmpty","getRootBlockName","forced_root_block","DomParser","nodeFilterRegistry","attributeFilterRegistry","defaultedSettings","root_name","sanitizer","parseAndSanitizeWithContext","rootName","isSpecialRoot","wrappedHtml","removeNodeFilter","removeAttributeFilter","findInvalidChildren","isWrappableNode","addRootBlocks","rootBlockName","rootBlockNode","rootBlock","forced_root_block_attrs","whitespacePre","whitespacePost","invalidFinder","matchFinder","topLevelChildren","otherChildren","exports","serializeContent","withSerializedContent","fireEvent","parserSettings","serializedContent","eventArgs","preProcessGetContent","postProcessGetContent","processedEventArgs","preProcessSetContent","postProcessSetContent","tableModel","tableRow","cellPosition","getSpan","fillout","rowspan","colspan","y2","x2","cellExists","skipCellsX","getWidth","row","findElementPos","extractRows","sx","sy","ey","newRows","subTable","createDomTable","tableElement","tableBody","modelRowsToDomRows","tableElm","toDom","subsection","findParentListContainer","getFullySelectedListWrappers","_li","listCont","listElm","listStyles","_style","innerElm","directListWrappers","commonAnchorContainer","getWrapElements","wrapElements","listWrappers","allWrappers","emptyFragment","getFragmentFromRange","getParentTable","getTableFragment","selectedTableCells","firstCell","lastCell","fullTableModel","sectionedTableModel","getSelectionFragment","read$3","isCollapsibleWhitespace","getInnerText","bin","getContextNodeName","parentBlockOpt","getTextContent","contextNodeName","rangeContentClone","nonRenderedText","parentBlockText","textIndex","hasProceedingSpace","hasTrailingSpace","getSerializedContent","tmpElm","contextual","extractSelectedContent","setupArgs$3","getInner","getSelectedContentInternal","defaultedArgs","updatedArgs","KEEP","INSERT","diff","vDown","vUp","snake","diag","buildScript","start1","end1","start2","end2","getMiddleSnake","j","i2","buildSnake","sum","getOuterHtml","insertAt","removeAt","applyDiff","read$2","trimZwsp","write","fragments","currentFragments","lazyTempDocument","hasIframes","createFragmentedLevel","beforeBookmark","createCompleteLevel","createFromEditor","applyToEditor","level","getLevelContent","getCleanLevelContent","hasEqualContent","level1","level2","hasEqualCleanedContent","isEq$1","isUnlocked","locks","setTyping","typing","endTyping","endTypingLevelIgnoreLocks","beforeChange$1","addUndoLevel$1","currentLevel","newLevel","lastLevel","bm","customUndoRedoLevels","setDirty","clear$1","extra$1","callback1","callback2","redo$1","undo$1","reset$1","hasUndo$1","hasRedo$1","transact$1","beforeChange","ignore","ignore$1","addVisualInternal","matchedElm","hasVisual","makePlainAdaptor","init","bindEvents","undo","redo","hasUndo","hasRedo","extra","formatChanged","addVisual","autocompleter","addDecoration","removeDecoration","makeRtcAdaptor","rtcEditor","defaultVars","_undoManager","_locks","_index","_node","_similar","_rfl","_details","_format","getRawModel","makeNoopAdaptor","nul","isRtc","plugins","getRtcSetup","rtcPlugin","setup","setup$t","editorCast","rtcInstance","rtc","isRemote","getRtcInstanceWithFallback","getRtcInstanceWithError","addUndoLevel","matchFormat","matchAllFormats","matchNodeFormat","canApplyFormat","closestFormat","applyFormat","removeFormat","toggleFormat","getContent$2","setContent$2","insertContent$1","getSelectedContent","addVisual$1","addAutocompleterDecoration","removeAutocompleterDecoration","getContent$1","walkPastBookmark","merge$1","outer","outerElm","oldLength","normalizeTextIfRequired","mergeAndNormalizeText","outerNode","normalizer","innerTextNode","rngSetContent","prevText","nextText","setupArgs$2","cleanContent","contextBlock","contextArgs","setContent$1","cleanedContent","createContextualFragment","deleteFromCallbackMap","SelectorChanged","selectorChangedData","currentSelectors","findMatchingNode","matchedSelectors","selectorChangedWithUnbind","isAttachedToDom","isValidRange","EditorSelection","selectedRange","explicitRange","getRng$1","bookmarkManager","select$1","compareEndPoints","fakeSelectedElements","tryCompareBoundaryPoints","how","sourceRange","destinationRange","compareBoundaryPoints","anchorNode","START_TO_START","END_TO_END","removeAllRanges","addRange","setBaseAndExtent","focusNode","setNode","getSelectedBlocks$1","anchorRange","focusRange","anchorOffset","focusOffset","selectorChanged","getScrollContainer","scrollContainer","placeCaretAt","controlSelection","register$3","hasChildren","preserve_cdata","trimTrailingBr","isBr","brNode1","brNode2","preProcess$1","oldDoc","clonedNode","impl","shouldFireEvent","hasEventListeners","process$1","postProcess","outArgs","getHtmlFromNode","parseHtml","serializeNode","htmlSerializer","toHtml","DomSerializerImpl","addRules","setRules","DomSerializer","domSerializer","defaultFormat$1","setupArgs$1","defaultFormat","setupArgs","removedOptions","deprecatedOptions","removedPlugins","deprecatedPlugins","replacedWith","getMatchingOptions","searchingFor","settingNames","setting","getRemovedOptions","getDeprecatedOptions","getMatchingPlugins","plugin","pluginNames","getRemovedPlugins","getDeprecatedPlugins","entry","logRemovedWarnings","rawOptions","normalizedOptions","hasRemovedPlugins","hasRemovedOptions","isLegacyMobileTheme","theme","listJoiner","themesMessage","pluginsMessage","optionsMessage","getPluginDescription","logDeprecatedWarnings","hasDeprecatedPlugins","hasDeprecatedOptions","logWarnings","DOM$8","restoreOriginalStyles","orgDisplay","safeDestroy","clearDomReferences","contentAreaContainer","editorContainer","bodyElement","contentDocument","contentWindow","restoreForm","form","_mceOldSubmit","submit","formEventDelegate","remove$1","editorUpload","save","is_removing","unbindAllNativeEvents","automatic","destroyed","_beforeUnload","CreateIconManager","iconPack","icons","IconManager","getProp","propName","getComputedSizeProp","getClientWidth","getClientHeight","getMarginTop","getMarginLeft","isInsideElementContentArea","bodyElm","transpose","isXYInContentArea","transposedPoint","fromDomSafe","isEditorAttachedToDom","rawContainer","getContentAreaContainer","NotificationManagerImpl","unimplemented","open","close","getArgs","NotificationManager","notifications","getImplementation","getNotificationManagerImpl","getTopNotification","progressBar","timeout","notification","addNotification","closeNotification","otherNotification","getEl","getNotifications","registerEvents","serviceMessage","requestAnimationFrame","WindowManagerImpl","openUrl","alert","confirm","WindowManager","dialogs","getWindowManagerImpl","funcBind","fireOpenEvent","dialog","fireCloseEvent","addDialog","closeDialog","otherDialog","getTopDialog","storeSelectionAndOpenDialog","openDialog","ui","windowManagerImpl","displayNotification","notificationManager","displayError","_skinLoaded","uploadError","logError","createLoadError","pluginLoadError","iconsLoadError","languageLoadError","themeLoadError","modelLoadError","pluginInitError","initError","isContentCssSkinName","toContentSkinResourceName","isBundledCssSkinName","tinymce","Resource","getContentCssUrls","transformToUrls","getFontCssUrls","cssLinks","skinUrl","contentCssFile","documentBaseURI","appendContentCssFromSettings","contentCSS","getAllImages","ImageScanner","uploadStatus","cachedPromises","images","isUploaded","promises","imageInfo","image","newPromise","UploadStatus","PENDING","UPLOADED","blobUriStatuses","createStatus","resultUri","hasBlobUri","getResultUri","isPending","markPending","markUploaded","removeFailed","seed","rnd","now","uuid","BlobCache","cache","mimeToExt","mimes","filename","toBlobInfo","URL","createObjectURL","findFirst","cachedBlobInfo","removeByUri","revokeObjectURL","Uploader","pendingPromises","pathJoin","path1","path2","defaultHandler","progress","xhr","XMLHttpRequest","withCredentials","credentials","upload","onprogress","loaded","total","json","JSON","responseText","basePath","formData","FormData","send","uploadHandler","noUpload","handlerSuccess","handlerFailure","resolvePending","uploadBlobInfo","openNotification","percent","isDefaultHandler","pendingUploadBlobInfo","uploadBlobs","blobInfos","createUploader","ImageUploader","uploader","showNotification","isEmptyForPadding","addPaddingToEmpty","EditorUpload","imageScanner","urlFilters","aliveGuard","cacheInvalidator","replaceString","replaceImageUrl","targetUrl","replacementUrl","replacementString","replaceUrlInUndoStack","replaceImageUriInView","uploadImages","scanForImages","imageInfos","imagesToRemove","shouldDispatchChange","filteredResult","uploadInfo","uploadUri","sugarElement","parentOpt","dispatchChange","uploadImagesAuto","isValidDataUriImage","imgElm","resultItem","replaceBlobUris","source_view","get$1","valigntop","verticalAlign","valignmiddle","valignbottom","alignleft","preview","textAlign","float","marginLeft","marginRight","aligncenter","alignright","alignjustify","bold","fontWeight","italic","fontStyle","underline","strikethrough","strike","forecolor","hilitecolor","fontname","fontFamily","fontsize","fontSize","lineheight","lineHeight","fontsize_class","class","blockquote","subscript","superscript","_fmt","_itemName","lang","customValue","removeformat","genericBase","cellBase","cellFormats","tablecellbackgroundcolor","tablecellverticalalign","tablecellbordercolor","borderColor","tablecellclass","tableclass","tablecellborderstyle","borderStyle","tablecellborderwidth","borderWidth","FormatRegistry","unregister","each$3","isPreviewItem","parsedSelectorToHtml","ancestry","sItem","getRequiredParent","elmRule","wrapInHtml","ancestors","parentCandidate","ancestorName","parentRequired","siblingElm","parentSiblings","parseSelectorItem","$0","$3","$4","parseSelector","getCssText","previewCss","previewStyles","removeVars","previewFrag","previewElm","rawParentFontSize","parentFontSize","numValue","setup$s","addShortcut","Formatter","formatChangeState","shouldIgnoreCommand","isFirstTypedCharacter","addNonTypingUndoLevel","isMeta","isDirty","modKey","hasOnlyMetaOrCtrlModifier","isInsertReplacementText","inputType","isInsertTextDataNull","isInsertFromPasteOrDrop","addKeyboardShortcuts","UndoManager","nonTypingKeycodes","placeholderAttr","isKeyboardEvent","isDeleteEvent","isNonTypingKeyboardEvent","isTypingKeyboardEvent","isVisuallyEmpty","setup$r","placeholder","updatePlaceholder","showPlaceholder","isPlaceholderShown","blockPosition","blockBoundary","getBlockPosition","containerElm","isDifferentBlocks","getClosestHost","isHost","hasSameHost","isEditable$1","hasValidBlocks","isValidBlock","skipLastBr","lastPositionInBlock","readFromRange","fromBlockPos","toBlockPos","blockPos","read$1","getChildrenUntilBlockBoundary","extractChildren","removeEmptyRoot","isEmptyBefore","nestedBlockMerge","toBlock","insertionPoint","sidelongBlockMerge","getInlineToBlockDescendants","helper","newFromBlockDescendants","findInsertionPoint","parentsAndSelf$1","getInsertionPoint","trimBr","mergeBlockInto","mergeBlocks","backspaceDelete$9","deleteRangeMergeBlocks","isRawNodeInTable","isSelectionInTable","isEverythingSelected","noPrevious","noNext","emptyEditor","deleteRange$2","backspaceDelete$8","_forward","showCaret","getNodeRange","renderCaretAtRange","caretPositionNode","caretPositionBeforeNode","ceRoot","renderRangeCaret","isBeforeBoundary","isAfterBoundary","trimEmptyTextNode","deleteContentAndShowCaret","peekCaretPosition","caretRange","deleteRange","deleteBoundaryText","getNextPosFn","isBeforeFn","nextCaretPosition","normalizedNextCaretPosition","backspaceDelete$7","getEdgeCefPosition","atStart","isCefAtEdgeSelected","isCompoundElement","DeleteAction","moveToElement","moveToPosition","isAtContentEditableBlockCaret","caretLocation","isDeleteFromCefDifferentBlocks","deleteEmptyBlockOrMoveToCef","toCefElm","blockElm","findCefPosition","getContentEditableBlockAction","skipMoveToActionFromInlineCefToContent","getContentEditableAction","read","deleteElement$1","hideFakeCaret","getAncestorCe","backspaceDeleteCaret","deleteOffscreenSelection","backspaceDeleteRange","hasCefAncestor","paddEmptyElement","backspaceDelete$6","deleteCaret$2","backspaceDelete$5","isText$2","startsWithCaretContainer","endsWithCaretContainer","createZwsp","insertBefore$1","insertAfter$1","insertInline","insertInlineBefore","insertInlineAfter","insertInlinePos","isPosCaretContainer","caretNode","renderCaret","evaluateUntil","fns","Location","rescope$1","nPos","isNotInsideFormatCaretContainer","findInsideRootInline","start$1","isValidLocation","readLocation","getName","outside","inside","isEq","location1","location2","betweenInlines","fromInline","toInline","skipNoMovement","fromLocation","toLocation","findLocationTraverse","findLocationSimple","findLocation$1","hasSelectionModifyApi","modify","moveRel","moveByWord","BreakType","flip","positions","walk$1","getBreakType","currentPos","Br","Block","Wrap","getPositionsUntil","breakType","breakAt","Eol","getAdjacentLinePositions","getPositionsUntilBreak","findClosestHorizontalPositionFromPoint","lastRect","newRect","lastDist","newDist","findClosestHorizontalPosition","targetRect","getPositionsUntilPreviousLine","getPositionsUntilNextLine","getPositionsAbove","getPositionsBelow","isAtFirstLine","isAtLastLine","getFirstLinePositions","getLastLinePositions","getClosestPositionAbove","getClosestPositionBelow","isContentEditableFalse$4","distanceToRectLeft$1","distanceToRectRight$1","isNodeClientRect","findClosestClientRect","oldClientRect","oldDistance","newDistance","getNodeClientRects","toArrayWithNode","VDirection","findUntil","walkUntil","isAboveFn","isBeflowFn","line","targetClientRect","aboveLineNumber","lineNumber","isLineNumber","upUntil","Up","downUntil","Down","getLastClientRect","positionsUntil","isBelowFn","isAboveLine","isLine","moveToRange","renderRangeCaretOpt","moveHorizontally","isBefore","isAfter","isElement","rangeIsInContainerBlock","moveVertically","caretClientRect","getClosestFn","walkerFn","linePositions","nextLinePositions","nextLineRect","dist1","dist2","caretPositions","closestNextLineRect","getLineEndPoint","lineInfo","moveToLineEndPoint$3","setCaretPosition","setSelected","renderCaretLocation","getPositionFromRange","findLocation","isInlineTarget$1","toggleInlines","inlineBoundaries","selectedInlines","targetInlines","safeRemoveCaretContainer","caretValue","renderInsideInlineCaret","inlines","_inline","move$3","moveWord","_caret","setupSelectedState","moveNextWord","movePrevWord","moveToLineEndPoint$2","linePoint","outsideLoc","rangeFromPositions","hasOnlyTwoOrLessPositionsLeft","setCaretLocation","deleteFromTo","rescope","backspaceDeleteCollapsed","toPosition","backspaceDelete$4","hasMultipleChildren","getParentsUntil","hasOnlyOneChild","getParentInlinesUntilMultichildInline","getParentInlines","getFormatNodes","parentInlines","isFormatElement$1","getFormatNodesAtStart","deleteLastPosition","deleteCaret$1","isBrInEmptyElement","isEmptyCaret","createCaretFormatAtStart","updateCaretFormat","updateFormats","missingFormats","rangeStartsAtTextContainer","rangeStartsAtStartOfTextContainer","rangeStartParentIsFormatElement","startParent","rangeStartAndEndHaveSameParent","endParent","isEqualNode","rangeEndsAtEndOfEndContainer","rangeEndsAtEndOfStartContainer","rangeEndsAfterEndOfStartContainer","rangeEndsAtOrAfterEndOfStartContainer","requiresDeleteRangeOverride","deleteRange$1","backspaceDelete$3","hasAncestorInlineCaret","hasAncestorInlineCaretAtStart","requiresRefreshCaretOverride","refreshCaret","deleteElement","deleteCaret","isNearMedia","backspaceDelete$2","parseIndentValue","getIndentStyleName","useMargin","indentStyleName","indentElement","unit","parsedValue","validateBlocks","intentValue","canOutdent","getBlocksToIndent","isReadOnly","isListComponent","parentIsListComponent","indentation","indentUnit","indentValue","outdent","backspaceDelete$1","findAction","deleteCommand","forwardDeleteCommand","setup$q","addCommand","SIGNIFICANT_MOVE","LONGPRESS_DELAY","getTouch","isFarEnough","distX","distY","setup$p","startData","longpressFired","debounceLongpress","isBlockElement","isValidTarget","hasBlockParent","shouldRemoveTextNode","createRootBlock","rootNodeName","restoreSelection","insertEmptyLine","setup$o","checkClassName","replaceMatchWithSpan","prevChar","findStartTagIndex","tagHtml","convertRegExpsToNonEditable","nonEditableRegExps","setup$n","contentEditableAttrName","editClass","nonEditClass","hasEditClass","hasNonEditClass","findBlockCaretContainer","blockCaretContainer","handleBlockContainer","setup$m","isContentEditableFalse$3","moveToCeFalseHorizontally","moveToCeFalseVertically","createTextBlock","textBlock","exitPreBlock","getVisualCaretPosition$1","newBlock","getHorizontalRange","getVerticalRange","down","flipDirection","moveH$2","moveV$4","moveToLineEndPoint$1","isCefPosition","selectToEndPoint","curRng","getClosestTargetBlock","isAtFirstOrLastLine","moveCaretToNewEmptyLine","insertFn","moveV$3","moveUp","summary","moveDown","move$2","moveV$2","baseKeyPattern","defaultPatterns","defaultDelayedPatterns","matchesEvent","match$1","matchDelayed","execute","executeWithDelayedAction","moveH$1","moveV$1","moveToLineEndPoint","CellLocation","firstLayer","filterFirstLayer","lookup$1","tags","isRootOrUpperTable","isEligible","newIndex","detection","deflate","getCorners","getYAxisValue","tds","findClosestCorner","corners","newCorner","oldCorner","oldDist","getClosestCell","isTargetCorner","corner","getBottomValue","getTopValue","getClosestCellAbove","getClosestCellBelow","findClosestPositionInAboveCell","findClosestPositionInBelowCell","hasNextBreak","breakPos","startsWithWrapBreak","startsWithBrBreak","isAtTableCellLine","isAtFirstTableCellLine","isAtLastTableCellLine","isCaretAtStartOrEndOfTable","navigateHorizontally","_td","getClosestAbovePosition","getClosestBelowPosition","getTable","renderBlock","navigateVertically","move$1","mover","moveH","moveV","getCellFirstCursorPosition","tabGo","_current","tabForward","tabBackward","handleTab","rootElements","model","clearSelectedCells","executeKeydownOverride$4","isMac","setup$l","DOM$7","alwaysNext","textBefore","textAfter","scanLeft","scanRight","repeatLeft","isValidTextRange","getText","isWhitespace","stripTrigger","trigger","findTrigger","firstChar","findStart","initRange","minChars","buffer","findTriggerIndex","spot","triggerIndex","isText$1","toLast","toLeaf","isPreviousCharContent","leaf","_element","isStartOfWord","getTriggerContext","database","triggers","getDatabase","lookupWithContext","fetchOptions","startText","autocompleters","lookupByTrigger","lookupData","ac","fetchResult","maxResults","matchText","columns","onAction","highlightOn","SimpleResultType","fold$1","stype","serror","svalue","partition","Value","bind$1","bindError","toResult","fromResult","SimpleResult","formatObj","stringify","formatErrors","es","getErrorInfo","missingRequired","missingKey","missingBranch","branch","custom","chooseFrom","fields","extract","choose$1","choice","chosen","bothObjects","deepMerge","baseMerge","merger","objects","curObject","defaultedThunk","fallbackThunk","defaulted$1","fallback","asOption","mergeValues","mergeErrors","consolidateObj","consolidateArr","partitions","ResultCombine","field$1","newKey","presence","customField$1","instantiator","ifField","ifCustom","validator","anyValue$1","requiredAccess","bundle","fallbackAccess","optionAccess","optionDefaultedAccess","opt","extractField","av","bundleAsOption","optValue","ov","extractFields","objOf","fieldStrings","_okey","_presence","_instantiator","arrOf","valueOf","extractValue","errs","asRaw","formatError","errInfo","choose","anyValue","typedValue","expectedType","actualType","number","string","boolean","functionProcessor","customField","validateEnum","requiredOf","requiredString","requiredFunction","requiredArrayOf","optionOf","optionString","optionFunction","defaulted","defaultedOf","defaultedNumber","defaultedString","defaultedStringEnum","defaultedBoolean","defaultedFunction","defaultedArrayOf","fetch$1","onSetup","optionalText","optionalIcon","optionalTooltip","optionalLabel","active","enabled","primary","defaultedColumns","defaultedType","autocompleterSchema","createAutocompleter","baseToolbarButtonFields","baseToolbarToggleButtonFields","contextBarFields","contextButtonFields","contextToggleButtonFields","launchButtonFields","launchToggleButtonFields","toggleOrNormal","contextformbutton","contextformtogglebutton","register$2","popups","dataset","popup","datasetValues","dv","setupEditorInput","update","which","cancelIfNecessary","setup$k","activeAutocompleter","uiActive","isActive","commenceIfNecessary","matchLength","getAutocompleters","doLookup","newContext","lookupInfo","_ui","browser$1","emptyNodeContents","isEntireNodeSelected","getParentDetailsElementAtPos","isInDetailsElement","getDetailsElements","startDetails","endDetails","startSummary","isCaretInTheBeginningOf","isCaretInTheEndOf","isCaretAtStartOfSummary","detailsElements","isCaretAtEndOfSummary","isCaretInFirstPositionInBody","isCaretInLastPositionInBody","setCaretToPosition","moveCaretToDetailsPos","isPartialDelete","containsStart","containsEnd","startInSummary","endInSummary","isPartiallySelectedDetailsElements","isInPartiallySelectedSummary","shouldPreventDeleteIntoDetails","granularity","parentDetailsAtCaret","inEmptyParentBlock","isFirstBlock","isLastBlock","firstOrLast","isBeforeAfterDetails","parentDetailsAtNewPos","shouldPreventDeleteSummaryAction","detailElements","shouldPreventDeleteAction","handleDeleteActionSafari","applySelection","updateSelection","appendAllChildNodes","backspaceDelete","createAndFireInputEvent","eventType","specifics","overrides","bubbles","isComposing","detail","currentTarget","eventPhase","AT_TARGET","originalTarget","explicitOriginalTarget","isTrusted","cancelable","InputEvent","fireInputEvent","fireBeforeInputEvent","platform$2","isMacOSOriOS","executeKeydownOverride$3","unmodifiedGranularity","getModifiedGranularity","isWord","applyAction","beforeInput","executeKeyupOverride","isBackspaceKeydown","setup$j","firstNonWhiteSpaceNodeSibling","moveToCaretPosition","getEditableRoot","editableRoot","getParentBlock$1","getParentBlockName","isListItemParentBlock","applyAttributes","forcedRootBlockAttrs","attrStyles","currentStyles","newStyles","attrClassesOpt","attrClasses","currentClassesOpt","currentClasses","filteredClasses","newClasses","appliedAttrs","remainingAttrs","setForcedBlockAttrs","createNewBlock","keepStyles","newBlockName","parentBlockName","getDetailsRoot","isAtDetailsEdge","isLastEmptyBlockInDetails","insertNewLine","hasFirstChild","isFirstChild","hasParent","isListBlock","isListItem","isNestedList","getContainerBlock","containerBlock","containerBlockParent","isFirstOrLastLi","getStyles","insert$4","containerParent","parentBlockStyles","tmpRng","previousChildren","isWithinNonEditableList","parentList","isEmptyAnchor","containerAndSiblingName","canSplitBlock","trimInlineElementsOnLeftSideOfBlock","firstChilds","normalizeZwspOffset","includeZwspInRange","trimLeadingLineBreaks","wrapSelfAndSiblingsInDefaultBlock","startNodeName","startNodeParent","addBrToBlockIfNeeded","shouldEndContainer","optionValue","insert$3","isAfterLastNodeInContainer","isCef","collapsedAndCef","createNewBlock$1","isCaretAtStartOrEndOfBlock","normalizedOffset","insertNewBlockAfter","containerBlockName","liBlock","parentBlockParent","isNearChildren","fakeEventName$1","blockbreak","fakeEventName","hasRightSideContent","moveSelectionToBr","brElm","extraBr","insertBrAtCaret","isControlKey","insertBrBefore","insertBrAfter","hasBrAfter","isBeforeBr","isAnchorLink","isInsideAnchor","readInlineAnchorLocation","insertBrOutsideAnchor","insert$2","anchorLocation","linebreak","matchesSelector","shouldInsertBr","shouldBlockNewLine$1","newLineAction","shouldBlockNewLine","_shiftKey","inListBlock","requiredState","inBlock","inCefBlock","inPreBlock","inSummaryBlock","shouldPutBrInPre","inBrContext","hasShiftKey","_editor","canInsertIntoEditableRoot","rootEditable","isInRootWithEmptyOrCEF","isCefOpt","predicates","isMatch","getAction","insertBreak","insert$1","logicalAction","platform$1","isIOSSafari","handleEnterKeyEvent","isCaretAfterKoreanCharacter","koreanCharRegex","setup$i","iOSSafariKeydownBookmark","iOSSafariKeydownOverride","iOSSafariKeyupOverride","executeKeydownOverride$2","setup$h","setup$g","platform","executeKeyupAction","isPageUpDown","setNodeChangeBlocker","blocked","setup$f","setup$e","insertTextAtPosition","insertNbspAtPosition","insertSpaceAtPosition","insertSpaceOrNbspAtPosition","locationToCaretPosition","insertInlineBoundarySpaceOrNbsp","checkPos","setSelection","isInsideSummary","domUtils","insertSpaceOrNbspAtSelection","insertSpaceInSummaryAtSelectionOnFirefox","insertSpaceThunk","executeKeydownOverride$1","setup$d","tableTabNavigation","executeKeydownOverride","setup$c","setup$b","NodeChange","lastPath","lastRng","nativeRng","fakeRng","isSameElementPath","initialized","currentPath","imageId","getDragImage","transfer","setDragImage","imageData","eventId","getEvent","mkSetEventFn","setEvent","setDragstartEvent","setDropEvent","setDragendEvent","checkEvent","isInDragStartEvent","createEmptyFileList","modeId","getMode","mkSetModeFn","setMode$1","setReadWriteMode","setReadOnlyMode","setProtectedMode","checkMode","expectedMode","isInReadWriteMode","isInProtectedMode","normalizeItems","dataTransfer","itemsImpl","validDropEffects","validEffectAlloweds","createDataTransfer","dataTransferImpl","DataTransfer","dropEffect","effectAllowed","effect","allowed","types","setData","clearData","cloneDataTransfer","originalMode","getHtmlData","setHtmlData","internalMimeType","internalHtmlMime","internalMark","mark","unmark","isMarked","isPlainText","openContainer","rootTag","rootAttrs","toBlockElements","tagOpen","tagClose","paragraphs","stitch","pasteBinDefaultContent","create$6","lastRngCell","pasteBinElm","pasteBinClone","isPasteBin","getHtml","copyAndRemove","toElm","fromElm","pasteBinClones","dirtyWrappers","cleanWrapper","isDefaultPasteBinContent","PasteBin","getLastRng","filter$1","voidElements","ignoreElements","trimHtml","trimSpaces","s1","s2","createIdGenerator","getImageMimeType","lowerExt","mimeOverrides","jpg","jpe","jfi","jif","jfif","pjpeg","pjp","preProcess","processResult","cancelled","postProcessFilter","tempBody","postProcessArgs","filterContent","preProcessArgs","filteredContent","pasteHtml$1","isAbsoluteUrl","isImageUrl","createImage","pasteHtmlFn","createLink","linkSelection","insertImage","smartInsertContent","pasteAsText","createPasteDataTransfer","doPaste","shouldSimulateInputEvent","doPasteAction","pasteHtml","internalFlag","pasteText","encodedText","getDataTransferItems","contentType","hasContentType","clipboardContent","hasHtmlOrText","extractFilename","createBlobInfo","useFileName","pasteImage","imageItem","existingBlobInfo","isClipboardEvent","readFilesAsDataUris","allowedExtensions","extension","getImagesFromDataTransfer","kind","getAsFile","pasteImageData","clipboardData","fileResults","isBrokenAndroidClipboardEvent","isKeyboardPasteEvent","insertClipboardContent","plainTextMode","isInternal","isPlainTextHtml","isAbsoluteUrl$1","registerEventHandlers","pasteBin","pasteFormat","keyboardPastePlainTextState","registerDataImageFilter","isWebKitFakeUrl","isDataUri","isPasteInsert","registerEventsAndFilters","togglePlainTextPaste","register$1","setHtml5Clipboard","setClipboardData","contenteditable","overflow","offscreenRange","selectNodeContents","isTableSelection","hasSelectedContent","cut","getCaretRangeFromEvent","isPlainTextFileUrl","plainTextContent","setFocusedRange","hasImage","needsCustomInternalDrop","dropContent","parentTransparent","inSummary","setupSummaryDeleteByDragFix","hasNoSummary","brokenDetailElements","setup$a","draggingInternallyState","internalContent","needsInternalDrop","isInternalDrop","trimmedContent","setup$9","processEvent","addPreProcessFilter","filterFunc","rgbRegExp","rgbToHex","removeWebKitStyles","webKitStylesOption","webKitStyles","inputStyles","outputStyles","inputValue","compareInput","outputStyle","setup$8","setup$7","preventSummaryToggle","filterDetails","initialStateOption","serializedStateOption","setup$6","isText","isContentEditableFalse$2","isContentEditableTrue","getClosestScope","getClosestCef","findEdgeCaretCandidate","findClosestBlockRange","startRng","clickNode","cef","onTripleClickSelect","setup$5","FakeCaretPosition","distanceToRectLeft","distanceToRectRight","isInsideY","collidesY","isOverlapping","overlap","splitRectsPerAxis","intersectingRects","boundingRect","horizontal","vertical","clientInfo","Before","After","horizontalDistance","_y","closestChildCaretCandidateNodeRect","findCloserTextNode","caretCandidateRect","tryFindSecondBestTextNode","sndClosest","distance","deltaDistance","findClosestCaretCandidateNodeRect","sortedRects","horizontalRects","verticalRects","above","below","traverseUp","prevScope","isDragGhostContainer","childNodesWithoutGhost","uncheckedChildren","newScope","closestCaretCandidateNodeRect","ownerDoc","elementAtPoint","closestFakeCaretCandidate","getAbsolutePosition","docElem","getBodyPosition","getScrollPosition","getBodyScroll","inlineScroll","iframeScroll","getMousePosition","iframePosition","scrollPosition","calculatePosition","bodyPosition","mousePosition","calc","getTargetProps","makeDndEventFromMouseEvent","makeDndEvent","timeStamp","BUBBLING_PHASE","CAPTURING_PHASE","NONE","button","buttons","movementX","movementY","offsetX","offsetY","relatedTarget","initUIEvent","initMouseEvent","makeDataTransferCopyForDragEvent","makeDragEvent","dataTransferForDispatch","scrollPixelsPerInterval","scrollIntervalValue","mouseRangeToTriggerScrollInsideEditor","mouseRangeToTriggerScrollOutsideEditor","isContentEditableFalse$1","isDraggable","isValidDropTarget","dragElement","createGhost","clonedElm","opacity","padding","boxSizing","appendGhostToBody","scrollEditor","amount","behavior","scrollRight","scrollUp","scrollDown","moveGhost","maxX","maxY","mouseY","mouseX","mouseEventOriginatedFromWithinTheEditor","overflowX","outerMouseY","outerMouseX","dragging","innerWidth","removeElement","removeElementWithPadding","isLeftMouseButtonPressed","applyRelPos","relX","ceElm","elmPos","relY","ghost","caretInfo","dispatchDragEvent","move","throttledPlaceCaretAt","state_","movement","targetPos","getRawTarget","drop","dropTarget","removeDragState","stopDragging","bindFakeDragEvents","pageDom","dragStartHandler","dragHandler","dropHandler","dragEndHandler","blockUnsupportedFileDrop","preventFileDrop","preventFileDropIfUIElement","editorRoot","eventNames","init$2","setup$4","renderFocusCaret","setup$3","isContentEditableFalse","getContentEditableRoot","SelectionOverrides","realSelectionId","selectedElement","isFakeSelectionElement","isFakeSelectionTargetElement","setRange","removeElementSelection","contentEditableRoot","setElementSelection","closestContentEditable","normalizeVoidElementSelection","isRangeInCaretContainer","isWithinCaretContainer","setupOffscreenSelection","targetClone","realSelectionContainer","selectElement","nodeElm","afterNode","getNormalizedTextOffset","generatePath","generatePathRange","resolvePath","nodePath","resolvedNode","optNode","resolvePathRange","generatePathRangeFromRange","cleanEmptyNodes","deleteRng","getParentBlock","resolveFromDynamicPatterns","patternSet","beforeText","dynamicPatterns","getBeforeText","startsWithSingleSpace","stripPattern","firstTextNode","applyPattern$1","isBlockFormatName","formatSet","sortPatterns$1","findPattern$1","sortedPatterns","nuText","findPatterns$1","normalizedMatches","blockText","applyMatches$1","newMarker","rangeFromMarker","createMarker","markerPrefix","pathRange","textEnd","textStart","startParentNode","endParentNode","removeMarker","isReplacementPattern","matchesPattern","patternContent","searchText","startEndIndex","findPatternStartFromSpot","startPattern","startSpot","startPatternIndex","isCompleteMatch","nextSpot","findPatternStart","requireGap","startRange","findPattern","endPathRng","endRng","resultsOpt","findPatternsRec","remainingPatterns","startPathRng","endSpot","patternsWithoutCurrent","applyPattern","patternRange","applyReplacementPattern","markerRange","applyPatternWithContent","startMarker","endMarker","markerEndRange","markerStartRange","patternMarker","addMarkers","matchesWithEnds","sortPatterns","getBestMatches","matchesWithSortedPatterns","hasSameMatches","sortedMatch","findPatterns","applyMatches","matchesWithMarkers","handleEnter","dynamicPatternSet","inlineMatches","blockMatches","handleInlineKey","checkKeyEvent","codes","checkKeyCode","checkCharCode","charCode","setup$2","charCodes","keyCodes","getPatternSet","hasDynamicPatterns","hasPatterns","handleInlineTrigger","setup$1","Quirks","isGecko","isWebKit","setEditorCommandState","emptyEditorWhenDeleting","serializeRng","contents","allContentsSelected","allRng","allSelection","selectAll","shortcuts","documentElementEditingFocus","removeHrOnBackspace","Range","blur","selectControlElements","visualAidsAnchorClass","removeStylesWhenDeletingAcrossBlockElements","getAttributeApplyFunction","setAttributeNode","isSelectionAcrossElements","disableBackspaceIntoATable","removeBlockQuoteOnBackSpace","setGeckoEditingOptions","setOpts","addBrAfterLastLinks","fixLinks","setDefaultBlockType","isAllContentSelected","showBrokenImageIcon","contentStyles","restoreFocusOnKeyDown","bodyHeight","blockCmdArrowNavigation","tapLinksAndImages","blockFormSubmitInsideEditor","removeAppleInterchangeBrs","setupRtc","dropDragEndEvent","DragEvent","DOM$6","appendStyle","getRootName","removeUndefined","mkParserSettings","mkSchemaSettings","mkSerializerSettings","createParser","autoFocus","moveSelectionToFirstCaretPosition","initEditor","bindPendingEventDelegates","initInstanceCallback","getStyleSheetLoader$1","makeStylesheetLoadingPromises","framedFonts","bundledCss","normalCss","bundledPromises","loadContentCss","fontCss","removeCss","contentCssText","allStylesheets","contentStyle","preInit","spellcheck","directionality","protect","escape","loadInitialContent","startContent","initEditorWithInitialContent","startProgress","canceled","progressTimeout","setProgressState","contentBodyLoaded","disabled","readonly","_editableRoot","hasEditableRoot","annotator","_nodeChangeDispatcher","setupRtcThunk","cancelProgress","_rtcMode","DOM$5","createIframeElement","title","customAttrs","tabindex","iframe","frameBorder","allowTransparency","getIframeHtml","iframeHTML","bodyId","bodyClass","translatedAriaText","createIframe","boxInfo","iframeTitle","ifr","iframeContainer","setupIframeBody","ready","srcdoc","init$1","hidden","visibility","orgVisibility","DOM$4","initPlugin","initializedPlugins","Plugin","pluginUrl","pluginInstance","trimLegacyPrefix","initPlugins","initIcons","iconPackName","currentIcons","loadIcons","svgData","icon","addIcon","initTheme","Theme","initModel","Model","renderFromLoadedTheme","render","renderUI","renderThemeFalse","renderFromThemeFunc","iframeHeight","createThemeFalseResult","renderThemeFalseIframe","renderThemeUi","augmentEditorUiApi","uiApiFacade","isEnabled","setEnabled","renderInfo","DOM$3","hasSkipLoadPrefix","loadLanguage","scriptLoader","languageCode","languageUrl","loadTheme","themeUrl","loadModel","modelUrl","getIconsUrlMetaFromUrl","getIconsUrlMetaFromName","defaultIconsUrl","customIconsUrl","urlMeta","loadPlugins","loadPlugin","isThemeLoaded","isModelLoaded","getStyleSheetLoader","snapshot","resetContent","triggerSave","windowManager","set_dirty","setEditableRoot","sectionResult","sections","deviceDetection","normalizePlugins","trimmedPlugins","extractSections","getSection","defaults","sectionOptions","hasSection","getSectionConfig","getMobileOverrideOptions","mobileOptions","defaultMobileOptions","table_grid","object_resizing","resize","toolbar_mode","toolbar_sticky","defaultPhoneOptions","menubar","getExternalPlugins","overrideOptions","userDefinedExternalPlugins","external_plugins","combinePlugins","forcedPlugins","getPlatformPlugins","isMobileDevice","desktopPlugins","mobilePlugins","processPlugins","defaultOverrideOptions","forced_plugins","mobileConfig","platformPlugins","combinedPlugins","isOnMobile","combineOptions","defaultOptions","deviceOverrideOptions","mobile","extendedOptions","normalizeOptions","registerExecCommands$3","toggleAlign","editorCommands","addCommands","JustifyLeft","JustifyCenter","JustifyRight","JustifyFull","JustifyNone","registerQueryStateCommands$1","alignStates","registerCommands$b","registerCommands$a","queryCommandEnabled","queryCommandSupported","trimOrPadLeftRight","processValue$1","trimOrPad","insertAtCaret","insertedContent","registerCommands$9","mceCleanup","_command","insertHorizontalRule","insertText","insertHTML","mceInsertContent","mceSetContent","mceReplaceContent","mceNewDocument","legacyPropNames","isFont","getSpecifiedFontProp","getProperty","legacyPropName","normalizeFontFamily","getComputedFontProp","getFontProp","getFontSize","getFontFamily","findFirstCaretElement","getCaretElement","atStartOfNode","bindRange","mapRange","fromFontSizeNumber","fontSizeNumber","fontClasses","normalizeFontNames","font","fonts","fontNameAction","fontNameQuery","fontSizeAction","fontSizeQuery","lineHeightQuery","specifiedStyle","computedStyle","lineHeightAction","registerExecCommands$2","customCode","registerQueryValueCommands","isFormatMatch","addQueryValueHandler","registerCommands$8","registerCommands$7","mceAddUndoLevel","mceEndUndoLevel","Undo","Redo","registerCommands$6","Indent","Outdent","registerCommands$5","applyLinkToSelection","linkDetails","unlink","mceInsertLink","registerExecCommands$1","listParent","registerQueryStateCommands","list","registerCommands$4","getTopParentBlock","topParentBlock","registerCommands$3","InsertNewBlockBefore","InsertNewBlockAfter","registerCommands$2","insertParagraph","mceInsertNewLine","InsertLineBreak","registerCommands$1","mceSelectNodeDepth","mceSelectNode","registerExecCommands","mceRemoveNode","mcePrint","print","mceFocus","mceToggleVisualAid","registerCommands","selectionSafeCommands","isSelectionSafeCommand","EditorCommands","commands","lowerCaseCommand","skip_focus","queryCommandState","queryCommandValue","commandList","addQueryStateHandler","internalContentEditableAttr","setContentEditable","switchOffContentEditableTrue","switchOnContentEditableTrue","removeFakeSelection","restoreFakeSelection","toggleReadOnly","registerFilters","registerReadOnlyContentFilters","isClickEvent","allowedEvents","isReadOnlyAllowedEvent","getAnchorHrefOpt","processReadonlyEvents","targetEl","registerReadOnlySelectionBlockers","nativeEvents","EventDispatcher","isNative","bindings","toggleEvent","beforeFire","once","wrappedCallback","currentName","bindingName","filteredHandlers","binding","getEventDispatcher","_eventDispatcher","toggleNativeEvent","Observable","bubble","dispatcherArgs","DOM$2","customEventRootDelegates","getEventTarget","eventName","eventRoot","isListening","bindEventDelegate","delegates","eventRootElm","delegate","editors","EditorObservable","_pendingNativeEvents","stringListProcessor","getBuiltInProcessor","processValue","isBuiltInSpec","getErrorMessage","additionalText","isValidResult","processDefaultValue","create$5","initialOptions","setValue","isRegistered","immutable","unset","registered","defaultModes","switchToMode","activeMode","availableModes","oldMode","newMode","activate","deactivate","editorReadOnly","setMode","registerMode","create$4","design","each$2","keyCodeLookup","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","modifierNames","isModifier","parseShortcut","shortcut","access","alt","ctrl","meta","Shortcuts","pendingPatterns","hasModifier","isFunctionKey","matchShortcut","subpatterns","executeShortcutAction","cmdFunc","normalizeCommandFunc","createShortcut","create$3","menuItems","contextMenus","contextToolbars","sidebars","views","addButton","addGroupToolbarButton","addToggleButton","addMenuButton","addSplitButton","addMenuItem","addNestedMenuItem","addToggleMenuItem","addAutocompleter","addContextMenu","addContextToolbar","addContextForm","addSidebar","addView","bridge","DOM$1","each$1","Editor","loadedCSS","isNotDirty","documentBaseURL","_setBaseUrl","baseURI","setupCallback","getParam","loadArgs","saveArgs","initialContent","oldState","urlConverterCallback","urlObject","_scanForImages","boundGlobalEvents","beforeUnloadDelegate","globalEventDelegate","EditorManager","toggleGlobalEvents","removeEditorFromList","targetEditor","oldEditors","purgeDestroyedEditor","isQuirksMode","compatMode","majorVersion","minorVersion","releaseDate","i18n","tinyMCEPreInit","srcScript","overrideDefaults","base_url","pluginBaseUrls","plugin_base_urls","pluginBaseUrl","pluginName","invalidInlineTargets","isInvalidInlineTarget","createId","execCallback","findTargets","provideResults","initEditors","initCount","createEditor","existingEditor","editorId","editorOptions","addI18n","dataValue","FakeClipboardItem","getType","FakeClipboard","relativePosition","targetW","targetH","relChars","create$2","findBestRelativePosition","constrainRect","rels","inflate","intersect","cropRect","x1","y1","clamp","clampRect","fixedSize","cx2","cy2","underflowX1","underflowY1","overflowX2","overflowY2","fromClientRect","Rect","awaiter","resolveCb","rejectCb","complete","completer","create$1","tasks","resultFns","resources","loadErrMsg","runErrMsg","task","waiter","storage","getItem","setItem","removeItem","defineProperty","localStorage","LocalStorage","publicApi","geom","util","TreeWalker","Serializer","Selection","tinymce$1","exportToModuleLoaders","module","exportToWindowGlobal","tinyMCE"],"mappings":"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","sourcesContent":["/**\n * TinyMCE version 6.8.2 (2023-12-11)\n */\n\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$2 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$e = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$5 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$e(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$3 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$1 = Object.hasOwnProperty;\n    const each$d = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$d(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$d(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$4 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$d(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$e(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArrayLike = o => o.length !== undefined;\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$c = (o, cb, s) => {\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (isArrayLike(o)) {\n        for (let n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (const n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$c(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$3 = (a, f) => {\n      const o = [];\n      each$c(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      for (let i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$2 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$4 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform$4();\n\n    const userAgent = navigator.userAgent;\n    const platform$3 = detect$2();\n    const browser$3 = platform$3.browser;\n    const os$1 = platform$3.os;\n    const deviceType = platform$3.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$3.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$3.current,\n        version: browser$3.version,\n        isChromium: browser$3.isChromium,\n        isEdge: browser$3.isEdge,\n        isFirefox: browser$3.isFirefox,\n        isIE: browser$3.isIE,\n        isOpera: browser$3.isOpera,\n        isSafari: browser$3.isSafari\n      },\n      os: {\n        current: os$1.current,\n        version: os$1.version,\n        isAndroid: os$1.isAndroid,\n        isChromeOS: os$1.isChromeOS,\n        isFreeBSD: os$1.isFreeBSD,\n        isiOS: os$1.isiOS,\n        isLinux: os$1.isLinux,\n        isMacOS: os$1.isMacOS,\n        isSolaris: os$1.isSolaris,\n        isWindows: os$1.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$3 = str => {\n      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map = {}) => {\n      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n      let i = resolvedItems.length;\n      while (i--) {\n        map[resolvedItems[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$c(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          } else {\n            walk$4(o, f, n, s);\n            return true;\n          }\n        });\n      }\n    };\n    const resolve$3 = (n, o = window) => {\n      const path = n.split('.');\n      for (let i = 0, l = path.length; i < l; i++) {\n        o = o[path[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (isArray$1(s)) {\n        return s;\n      } else if (s === '') {\n        return [];\n      } else {\n        return map$1(s.split(d || ','), trim$3);\n      }\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$3,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$c,\n      map: map$1,\n      grep: filter$3,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$3,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n    const isElement$7 = isType(ELEMENT);\n    const isText$b = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$3 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$d(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$a = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$3(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$9 = (element, attr, id) => {\n      const nu = filter$5(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$3(element, attr, nu.join(' '));\n      } else {\n        remove$a(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$8(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$a(element, 'class');\n      }\n    };\n    const remove$7 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$8(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n      return parent(element).map(children$1).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n    const hasChildNodes = element => element.dom.hasChildNodes();\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$b(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$4 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$2 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n    const descendant$1 = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n    };\n\n    const closest$2 = target => closest$3(target, '[contenteditable]');\n    const isEditable$2 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n      }\n    };\n    const getRaw$1 = element => element.dom.contentEditable;\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$2 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$d(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$6 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n        remove$a(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$e(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$e(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$e(children$1(element), rogue => {\n        remove$5(rogue);\n      });\n    };\n    const remove$5 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$1(wrapper);\n      if (children.length > 0) {\n        after$3(wrapper, children);\n      }\n      remove$5(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$1(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set$1 = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$2().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$2().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$e(children$1(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            let sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n        return undefined;\n      }\n      findPreviousNode(node, shallow) {\n        if (node) {\n          const sibling = node.previousSibling;\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (let child = sibling.lastChild; child; child = child.lastChild) {\n                if (!child.lastChild) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          const parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n        return undefined;\n      }\n    }\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n    const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n    const matchNodeName = name => {\n      const lowerCasedName = name.toLowerCase();\n      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n    };\n    const matchNodeNames = names => {\n      const lowerCasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowerCasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          const win = node.ownerDocument.defaultView;\n          if (win) {\n            for (let i = 0; i < items.length; i++) {\n              const computed = win.getComputedStyle(node, null);\n              const cssValue = computed ? computed.getPropertyValue(name) : null;\n              if (cssValue === items[i]) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const hasAttributeValue = (attrName, attrValue) => {\n      return node => {\n        return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n      };\n    };\n    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isHTMLElement(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$a = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$6 = matchNodeName('br');\n    const isImg = matchNodeName('img');\n    const isContentEditableTrue$3 = hasContentEditableState('true');\n    const isContentEditableFalse$b = hasContentEditableState('false');\n    const isTableCell$3 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isTableCellOrCaption = matchNodeNames([\n      'td',\n      'th',\n      'caption'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isListItem$2 = matchNodeName('li');\n    const isDetails = matchNodeName('details');\n    const isSummary$1 = matchNodeName('summary');\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$2 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$b, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n    const set = (element, value) => api$1.set(element, value);\n\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isTable$1 = node => name(node) === 'table';\n    const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem$1 = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$2 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const getLastChildren$1 = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n      if (allBrs.length === brs.length) {\n        each$e(brs, remove$5);\n      }\n    };\n    const createPaddingBr = () => {\n      const br = SugarElement.fromTag('br');\n      set$3(br, 'data-mce-bogus', '1');\n      return br;\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, createPaddingBr());\n    };\n    const trimBlockTrailingBr = (elm, schema) => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n            remove$5(lastChild);\n          }\n        });\n      });\n    };\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp$1 = isZwsp$2;\n    const trim$2 = removeZwsp;\n    const insert$5 = editor => editor.insertContent(ZWSP$1, { preserve_zwsp: true });\n\n    const isElement$5 = isElement$6;\n    const isText$9 = isText$a;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$9(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$9(node) && isZwsp$1(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const insertBlock = (blockName, node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createPaddingBr().dom);\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      var _a;\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$2(lastBr)) {\n        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const isContentEditableTrue$2 = isContentEditableTrue$3;\n    const isContentEditableFalse$a = isContentEditableFalse$b;\n    const isBr$4 = isBr$6;\n    const isText$8 = isText$a;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$8(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n    const isInEditable = (node, root) => {\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (isNonUiContentEditableFalse(tempNode)) {\n          return false;\n        }\n        if (isContentEditableTrue$2(tempNode)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$2(elm);\n      }, false);\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isZwsp = text => {\n      for (const c of text) {\n        if (!isZwsp$2(c)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const hasWhitespacePreserveParent = (node, rootNode) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));\n    };\n    const isWhitespace$1 = (node, rootNode) => {\n      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isContent$1 = (node, rootNode) => {\n      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const isBogus$1 = hasAttribute('data-mce-bogus');\n    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n    const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n    const isEmptyNode = (targetNode, skipBogus) => {\n      let brCount = 0;\n      if (isContent$1(targetNode, targetNode)) {\n        return false;\n      } else {\n        let node = targetNode.firstChild;\n        if (!node) {\n          return true;\n        }\n        const walker = new DomTreeWalker(node, targetNode);\n        do {\n          if (skipBogus) {\n            if (isBogusAll(node)) {\n              node = walker.next(true);\n              continue;\n            }\n            if (isBogus$1(node)) {\n              node = walker.next();\n              continue;\n            }\n          }\n          if (isContentEditableTrue$3(node) && hasNonEditableParent(node)) {\n            return false;\n          }\n          if (isBr$6(node)) {\n            brCount++;\n            node = walker.next();\n            continue;\n          }\n          if (isContent$1(node, targetNode)) {\n            return false;\n          }\n          node = walker.next();\n        } while (node);\n        return brCount <= 1;\n      }\n    };\n    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\n\n    const isNonHtmlElementRootName = name => name.toLowerCase() === 'svg';\n    const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n    const toScopeType = node => (node === null || node === void 0 ? void 0 : node.nodeName) === 'svg' ? 'svg' : 'html';\n    const namespaceElements = ['svg'];\n    const createNamespaceTracker = () => {\n      let scopes = [];\n      const peek = () => scopes[scopes.length - 1];\n      const track = node => {\n        if (isNonHtmlElementRoot(node)) {\n          scopes.push(node);\n        }\n        let currentScope = peek();\n        if (currentScope && !currentScope.contains(node)) {\n          scopes.pop();\n          currentScope = peek();\n        }\n        return toScopeType(currentScope);\n      };\n      const current = () => toScopeType(peek());\n      const reset = () => {\n        scopes = [];\n      };\n      return {\n        track,\n        current,\n        reset\n      };\n    };\n\n    const transparentBlockAttr = 'data-mce-block';\n    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n    const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n      return `${ name }:` + map$3(namespaceElements, ns => `not(${ ns } ${ name })`).join(':');\n    }).join(',');\n    const updateTransparent = (blocksSelector, transparent) => {\n      if (isNonNullable(transparent.querySelector(blocksSelector))) {\n        transparent.setAttribute(transparentBlockAttr, 'true');\n        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n          transparent.removeAttribute('data-mce-selected');\n        }\n        return true;\n      } else {\n        transparent.removeAttribute(transparentBlockAttr);\n        return false;\n      }\n    };\n    const updateBlockStateOnChildren = (schema, scope) => {\n      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n    };\n    const trimEdge = (el, leftSide) => {\n      var _a;\n      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n        if (isEmpty$2(SugarElement.fromDom(child))) {\n          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n          return;\n        }\n      }\n    };\n    const split$2 = (parentElm, splitElm) => {\n      const range = document.createRange();\n      const parentNode = parentElm.parentNode;\n      if (parentNode) {\n        range.setStartBefore(parentElm);\n        range.setEndBefore(splitElm);\n        const beforeFragment = range.extractContents();\n        trimEdge(beforeFragment, true);\n        range.setStartAfter(splitElm);\n        range.setEndAfter(parentElm);\n        const afterFragment = range.extractContents();\n        trimEdge(afterFragment, false);\n        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {\n          parentNode.insertBefore(beforeFragment, parentElm);\n        }\n        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {\n          parentNode.insertBefore(afterFragment, parentElm);\n        }\n        parentNode.removeChild(parentElm);\n      }\n    };\n    const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n      const blocksElements = schema.getBlockElements();\n      const rootNode = SugarElement.fromDom(scope);\n      const isBlock = el => name(el) in blocksElements;\n      const isRoot = el => eq(el, rootNode);\n      each$e(fromDom$1(transparentBlocks), transparentBlock => {\n        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n          if (invalidChildren.length > 0) {\n            const stateScope = parentElement(parentBlock);\n            each$e(invalidChildren, child => {\n              ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n                split$2(parentBlock.dom, child.dom);\n              });\n            });\n            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n          }\n        });\n      });\n    };\n    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n      each$e([\n        ...transparentBlocks,\n        ...isTransparentBlock(schema, scope) ? [scope] : []\n      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n        if (isTransparentInline(schema, elm.dom)) {\n          unwrap(elm);\n        }\n      }));\n    };\n    const updateChildren = (schema, scope) => {\n      const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n      splitInvalidChildren(schema, scope, transparentBlocks);\n      unwrapInvalidChildren(schema, scope, transparentBlocks);\n    };\n    const updateElement = (schema, target) => {\n      if (isTransparentElement(schema, target)) {\n        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n        updateTransparent(blocksSelector, target);\n      }\n    };\n    const updateCaret = (schema, root, caretParent) => {\n      const isRoot = el => eq(el, SugarElement.fromDom(root));\n      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n    };\n    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n\n    const browser$2 = detect$2().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser$2.isFirefox() && name(elm) === 'table') {\n        return firstElement(children$1(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const _setContentCssCors = contentCssCors => {\n        settings.contentCssCors = contentCssCors;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant$1(styleContainer, '#' + id).each(remove$5);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$e(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        if (settings.contentCssCors) {\n          set$3(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = passed;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$3(linkElem, 'href', urlWithSuffix);\n      });\n      const loadRawCss = (key, css) => {\n        const state = getOrCreateState(key);\n        loadedStates[key] = state;\n        state.count++;\n        const styleElem = SugarElement.fromTag('style', doc.dom);\n        setAll$1(styleElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        styleElem.dom.innerHTML = css;\n        addStyle(styleElem);\n      };\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadRawCss = key => {\n        get$a(loadedStates, key).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[key];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$e(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadRawCss,\n        loadAll,\n        unload,\n        unloadRawCss,\n        unloadAll,\n        _setReferrerPolicy,\n        _setContentCssCors\n      };\n    };\n\n    const create$d = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$d();\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, root, schema) => isNonNullable(node) && (isContent$1(node, root) || schema.isInline(node.nodeName.toLowerCase()));\n    const surroundedByInlineContent = (node, root, schema) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root, schema);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, root, schema);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root, schema) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, schema, root) => {\n      var _a;\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], schema, rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      const lookup = {};\n      if (items) {\n        const itemList = items.split(',');\n        radix = radix || 10;\n        for (let i = 0; i < itemList.length; i += 2) {\n          const chr = String.fromCharCode(parseInt(itemList[i], radix));\n          if (!baseEntities[chr]) {\n            const entity = '&' + itemList[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      } else {\n        return undefined;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      const resolveEntities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || resolveEntities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n\n    const parseCustomElementsRules = value => {\n      const customElementRegExp = /^(~)?(.+)$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = customElementRegExp.exec(rule);\n        if (matches) {\n          const inline = matches[1] === '~';\n          const cloneName = inline ? 'span' : 'div';\n          const name = matches[2];\n          return [{\n              inline,\n              cloneName,\n              name\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const getElementSetsAsStrings = type => {\n      let globalAttributes, blockContent;\n      let phrasingContent;\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        const transparentContent = 'a ins del canvas map';\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n      }\n      if (type !== 'html5-strict') {\n        globalAttributes += ' xml:lang';\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        const html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n      }\n      const flowContent = [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      return {\n        globalAttributes,\n        blockContent,\n        phrasingContent,\n        flowContent\n      };\n    };\n\n    const makeSchema = type => {\n      const {globalAttributes, phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const schema = {};\n      const addElement = (name, attributes, children) => {\n        schema[name] = {\n          attributes: mapToObject(attributes, constant({})),\n          attributesOrder: attributes,\n          children: mapToObject(children, constant({}))\n        };\n      };\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        const allAttributes = split$1([\n          globalAttributes,\n          attributes\n        ].join(' '));\n        while (ni--) {\n          addElement(names[ni], allAttributes.slice(), childNames);\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        each$e(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        const html4BlockContent = 'center dir isindex noframes';\n        each$e(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('dd div', '', flowContent);\n      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp bdi', '', phrasingContent);\n        add('summary', '', [\n          phrasingContent,\n          'h1 h2 h3 h4 h5 h6'\n        ].join(' '));\n        add('canvas', 'width height', flowContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n        addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');\n      }\n      if (type !== 'html4') {\n        each$e([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$e(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      return schema;\n    };\n\n    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n    const parseValidChildrenRules = value => {\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = childRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const operation = prefix ? prefixToOperation(prefix) : 'replace';\n          const name = matches[2];\n          const validChildren = split$1(matches[3], '|');\n          return [{\n              operation,\n              name,\n              validChildren\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n      const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n      const hasPatternsRegExp = /[*?+]/;\n      const {attributes, attributesOrder} = targetElement;\n      return each$e(split$1(attrData, '|'), rule => {\n        const matches = attrRuleRegExp.exec(rule);\n        if (matches) {\n          const attr = {};\n          const attrType = matches[1];\n          const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n          const attrPrefix = matches[3];\n          const value = matches[4];\n          if (attrType === '!') {\n            targetElement.attributesRequired = targetElement.attributesRequired || [];\n            targetElement.attributesRequired.push(attrName);\n            attr.required = true;\n          }\n          if (attrType === '-') {\n            delete attributes[attrName];\n            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n            return;\n          }\n          if (attrPrefix) {\n            if (attrPrefix === '=') {\n              targetElement.attributesDefault = targetElement.attributesDefault || [];\n              targetElement.attributesDefault.push({\n                name: attrName,\n                value\n              });\n              attr.defaultValue = value;\n            } else if (attrPrefix === '~') {\n              targetElement.attributesForced = targetElement.attributesForced || [];\n              targetElement.attributesForced.push({\n                name: attrName,\n                value\n              });\n              attr.forcedValue = value;\n            } else if (attrPrefix === '<') {\n              attr.validValues = Tools.makeMap(value, '?');\n            }\n          }\n          if (hasPatternsRegExp.test(attrName)) {\n            const attrPattern = attr;\n            targetElement.attributePatterns = targetElement.attributePatterns || [];\n            attrPattern.pattern = patternToRegExp(attrName);\n            targetElement.attributePatterns.push(attrPattern);\n          } else {\n            if (!attributes[attrName]) {\n              attributesOrder.push(attrName);\n            }\n            attributes[attrName] = attr;\n          }\n        }\n      });\n    };\n    const cloneAttributesInto = (from, to) => {\n      each$d(from.attributes, (value, key) => {\n        to.attributes[key] = value;\n      });\n      to.attributesOrder.push(...from.attributesOrder);\n    };\n    const parseValidElementsRules = (globalElement, validElements) => {\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n      return bind$3(split$1(validElements, ','), rule => {\n        const matches = elementRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const elementName = matches[2];\n          const outputName = matches[3];\n          const attrsPrefix = matches[4];\n          const attrData = matches[5];\n          const element = {\n            attributes: {},\n            attributesOrder: []\n          };\n          globalElement.each(el => cloneAttributesInto(el, element));\n          if (prefix === '#') {\n            element.paddEmpty = true;\n          } else if (prefix === '-') {\n            element.removeEmpty = true;\n          }\n          if (attrsPrefix === '!') {\n            element.removeEmptyAttrs = true;\n          }\n          if (attrData) {\n            parseValidElementsAttrDataIntoElement(attrData, element);\n          }\n          if (outputName) {\n            element.outputName = elementName;\n          }\n          if (elementName === '@') {\n            if (globalElement.isNone()) {\n              globalElement = Optional.some(element);\n            } else {\n              return [];\n            }\n          }\n          return [outputName ? {\n              name: elementName,\n              element,\n              aliasName: outputName\n            } : {\n              name: elementName,\n              element\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const mapCache = {};\n    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;\n    const createMap = (defaultValue, extendWith = {}) => {\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n      return extend$2(value, extendWith);\n    };\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n    const compileElementMap = (value, mode) => {\n      if (value) {\n        const styles = {};\n        if (isString(value)) {\n          value = { '*': value };\n        }\n        each$b(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n        return styles;\n      } else {\n        return undefined;\n      }\n    };\n    const Schema = (settings = {}) => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {};\n      const specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        const value = settings[option];\n        if (!value) {\n          let newValue = mapCache[option];\n          if (!newValue) {\n            newValue = createMap(defaultValue, extendWith);\n            mapCache[option] = newValue;\n          }\n          return newValue;\n        } else {\n          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n      };\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = makeSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const headings = 'h1 h2 h3 h4 h5 h6';\n      const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n      const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const addValidElements = validElements => {\n        const globalElement = Optional.from(elements['@']);\n        const hasPatternsRegExp = /[*?+]/;\n        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {\n          if (aliasName) {\n            elements[aliasName] = element;\n          }\n          if (hasPatternsRegExp.test(name)) {\n            const patternElement = element;\n            patternElement.pattern = patternToRegExp(name);\n            patternElements.push(patternElement);\n          } else {\n            elements[name] = element;\n          }\n        });\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$e(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n      };\n      const addCustomElements = customElements => {\n        delete mapCache.text_block_elements;\n        delete mapCache.block_elements;\n        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({inline, name, cloneName}) => {\n          children[name] = children[cloneName];\n          customElementsMap[name] = cloneName;\n          nonEmptyElementsMap[name.toUpperCase()] = {};\n          nonEmptyElementsMap[name] = {};\n          if (!inline) {\n            blockElementsMap[name.toUpperCase()] = {};\n            blockElementsMap[name] = {};\n          }\n          if (!elements[name]) {\n            let customRule = elements[cloneName];\n            customRule = extend$2({}, customRule);\n            delete customRule.removeEmptyAttrs;\n            delete customRule.removeEmpty;\n            elements[name] = customRule;\n          }\n          each$d(children, (element, elmName) => {\n            if (element[cloneName]) {\n              children[elmName] = element = extend$2({}, children[elmName]);\n              element[name] = element[cloneName];\n            }\n          });\n        });\n      };\n      const addValidChildren = validChildren => {\n        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {\n          const parent = operation === 'replace' ? { '#comment': {} } : children[name];\n          each$e(validChildren, child => {\n            if (operation === 'remove') {\n              delete parent[child];\n            } else {\n              parent[child] = {};\n            }\n          });\n          children[name] = parent;\n        });\n      };\n      const getElementRule = name => {\n        const element = elements[name];\n        if (element) {\n          return element;\n        }\n        let i = patternElements.length;\n        while (i--) {\n          const patternElement = patternElements[i];\n          if (patternElement.pattern.test(name)) {\n            return patternElement;\n          }\n        }\n        return undefined;\n      };\n      if (!settings.valid_elements) {\n        each$b(schemaItems, (element, name) => {\n          elements[name] = {\n            attributes: element.attributes,\n            attributesOrder: element.attributesOrder\n          };\n          children[name] = element.children;\n        });\n        each$b(split$1('strong/b em/i'), item => {\n          const items = split$1(item, '/');\n          elements[items[1]].outputName = items[0];\n        });\n        each$b(textInlineElementsMap, (_val, name) => {\n          if (elements[name]) {\n            if (settings.padd_empty_block_inline_children) {\n              elements[name].paddInEmptyBlock = true;\n            }\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('ol ul blockquote a table tbody'), name => {\n          if (elements[name]) {\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n          if (elements[name]) {\n            elements[name].paddEmpty = true;\n          }\n        });\n        each$b(split$1('span'), name => {\n          elements[name].removeEmptyAttrs = true;\n        });\n      } else {\n        setValidElements(settings.valid_elements);\n        each$b(schemaItems, (element, name) => {\n          children[name] = element.children;\n        });\n      }\n      delete elements.svg;\n      addCustomElements(settings.custom_elements);\n      addValidChildren(settings.valid_children);\n      addValidElements(settings.extended_valid_elements);\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n      each$b({\n        dd: 'dl',\n        dt: 'dl',\n        li: 'ul ol',\n        td: 'tr',\n        th: 'tr',\n        tr: 'tbody thead tfoot',\n        tbody: 'table',\n        thead: 'table',\n        tfoot: 'table',\n        legend: 'fieldset',\n        area: 'map',\n        param: 'video audio object'\n      }, (parents, item) => {\n        if (elements[item]) {\n          elements[item].parentsRequired = split$1(parents);\n        }\n      });\n      if (settings.invalid_elements) {\n        each$b(explode$2(settings.invalid_elements), item => {\n          if (elements[item]) {\n            delete elements[item];\n          }\n        });\n      }\n      if (!getElementRule('span')) {\n        addValidElements('span[!data-mce-type|*]');\n      }\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getTransparentElements = constant(transparentElementsMap);\n      const getWrapBlockElements = constant(wrapBlockElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            const attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              let i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isBlock = name => has$2(getBlockElements(), name);\n      const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n      const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n      const getCustomElements = constant(customElementsMap);\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getTransparentElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        isBlock,\n        isInline,\n        isWrapper,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const hexColour = value => ({ value: normalizeHex(value) });\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const fromString = rgbaString => {\n      if (rgbaString === 'transparent') {\n        return Optional.some(rgbaColour(0, 0, 0, 0));\n      }\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const Styles = (settings = {}, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (let i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let isEncoded = false;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            let i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            const value = styles[key];\n            if (!value) {\n              return;\n            }\n            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n            let i = values.length;\n            while (i--) {\n              if (values[i] !== values[0]) {\n                return false;\n              }\n            }\n            styles[key] = values[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3 || '');\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            let matches;\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              let value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                if (isString(settings.force_hex_color) && settings.force_hex_color !== 'off') {\n                  fromString(value).each(rgba => {\n                    if (settings.force_hex_color === 'always' || rgba.alpha === 1) {\n                      value = rgbaToHexString(toString(rgba));\n                    }\n                  });\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = (elemName, validStyleList) => {\n            const styleList = validStyleList[elemName];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                const name = styleList[i];\n                const value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elemName) => {\n            if (!invalidStyles || !elemName) {\n              return true;\n            }\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elemName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*', validStyles);\n            serializeStyles(elementName, validStyles);\n          } else {\n            each$d(styles, (value, name) => {\n              if (value && isValid(name, elementName)) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(originalEvent.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      if (isNonNullable(originalEvent.getModifierState)) {\n        event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n      }\n      if (isNonNullable(originalEvent.getTargetRanges)) {\n        event.getTargetRanges = () => originalEvent.getTargetRanges();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      target.addEventListener(name, callback, capture || false);\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      target.removeEventListener(name, callback, capture || false);\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let callbackList;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || isText$a(target) || isComment(target)) {\n          return callback;\n        }\n        let id;\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        let i = namesList.length;\n        while (i--) {\n          let name = namesList[i];\n          let nativeHandler = defaultNativeHandler;\n          let capture = false;\n          let fakeName = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              const event = fix(evt || win.event);\n              event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(event, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          let eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            let i = namesList.length;\n            while (i--) {\n              const name = namesList[i];\n              const callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  let ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      newCallbackList.nativeHandler = nativeHandler;\n                      newCallbackList.fakeName = fakeName;\n                      newCallbackList.capture = capture;\n                      eventMap[name] = newCallbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$d(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (const name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          const id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          const children = target.getElementsByTagName('*');\n          let i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$a = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$a(elm, name);\n      } else {\n        set$3(elm, name, value);\n      }\n    };\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0;\n      if (node) {\n        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n          const nodeType = tempNode.nodeType;\n          if (normalized && isText$a(tempNode)) {\n            if (nodeType === lastNodeType || !tempNode.data.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const convertStyleToString = (cssValue, cssName) => {\n      if (isNumber(cssValue)) {\n        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n      } else {\n        return cssValue;\n      }\n    };\n    const applyStyle$1 = ($elm, cssName, cssValue) => {\n      const normalizedName = camelCaseToHyphens(cssName);\n      if (isNullable(cssValue) || cssValue === '') {\n        remove$6($elm, normalizedName);\n      } else {\n        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$a(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope,\n        force_hex_color: settings.force_hex_color\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal = '') => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal;\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const val = value === '' ? null : value;\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, val, name);\n            } else {\n              legacySetAttribute($elm, name, val);\n            }\n            if (originalValue !== val && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm.dom,\n                attrName: name,\n                attrValue: val\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          applyStyle$1($elm, name, value);\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          each$d(stylesArg, (v, n) => {\n            applyStyle$1($elm, n, v);\n          });\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        const $elm = get(elm);\n        if (!$elm) {\n          return {\n            w: 0,\n            h: 0\n          };\n        }\n        let w = getStyle($elm, 'width');\n        let h = getStyle($elm, 'height');\n        if (!w || w.indexOf('px') === -1) {\n          w = '0';\n        }\n        if (!h || h.indexOf('px') === -1) {\n          h = '0';\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let node = get(elm);\n        collect = collect === undefined;\n        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            const selectorVal = selector;\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n            if (isFunction(func) && func(tempNode)) {\n              return tempNode;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const isParentNode = node => isFunction(node.querySelectorAll);\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        if (isArray$1(elm)) {\n          const result = [];\n          each$a(elm, (e, i) => {\n            const node = get(e);\n            if (node) {\n              result.push(func.call(context, node, i));\n            }\n          });\n          return result;\n        } else {\n          const node = get(elm);\n          return !node ? false : func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$d(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set$1($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '<' + name;\n        for (const key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        let node;\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$e(children$1($node), child => {\n              if (isText$b(child) && child.dom.length === 0) {\n                remove$5(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$5($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        let styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          const head = doc.head;\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$e(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$e(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$7;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return isNonNullable($elm) && forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        if (isNonNullable($elm)) {\n          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n        } else {\n          return '';\n        }\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n          if (parent) {\n            if (nextSibling) {\n              parent.insertBefore(node, nextSibling);\n            } else {\n              parent.appendChild(node);\n            }\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n        var _a;\n        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n        if (keepChildren) {\n          each$a(grep(elm.childNodes), node => {\n            replacee.appendChild(node);\n          });\n        }\n        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n        return elm;\n      });\n      const rename = (elm, name) => {\n        if (elm.nodeName !== name.toUpperCase()) {\n          const newElm = create(name);\n          each$a(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n          return newElm;\n        } else {\n          return elm;\n        }\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a;\n        while (ps) {\n          let pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        } else {\n          return ps;\n        }\n      };\n      const isNonEmptyElement = node => {\n        if (isElement$6(node)) {\n          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isEmpty = (node, elements, options) => {\n        let brCount = 0;\n        if (isNonEmptyElement(node)) {\n          return false;\n        }\n        const firstChild = node.firstChild;\n        if (firstChild) {\n          const walker = new DomTreeWalker(firstChild, node);\n          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};\n          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);\n          let tempNode = firstChild;\n          do {\n            if (isElement$6(tempNode)) {\n              const bogusVal = tempNode.getAttribute('data-mce-bogus');\n              if (bogusVal) {\n                tempNode = walker.next(bogusVal === 'all');\n                continue;\n              }\n              const name = tempNode.nodeName.toLowerCase();\n              if (nonEmptyElements && nonEmptyElements[name]) {\n                if (name === 'br') {\n                  brCount++;\n                  tempNode = walker.next();\n                  continue;\n                }\n                return false;\n              }\n              if (isNonEmptyElement(tempNode)) {\n                return false;\n              }\n            }\n            if (isComment(tempNode)) {\n              return false;\n            }\n            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {\n              return false;\n            }\n            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {\n              return false;\n            }\n            tempNode = walker.next();\n          } while (tempNode);\n        }\n        return brCount <= 1;\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n          const parentNode = parentElm.parentNode;\n          range.setStart(parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        } else {\n          return undefined;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const [boundTarget, boundName, boundFunc] = boundEvents[i];\n              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n                events.unbind(boundTarget, boundName, boundFunc);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isHTMLElement(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n          state = getContentEditable(tempNode);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const isEditable = node => {\n        if (isNonNullable(node)) {\n          const scope = isElement$6(node) ? node : node.parentElement;\n          return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n        } else {\n          return false;\n        }\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n            events.unbind(boundTarget, boundName, boundFunc);\n          }\n        }\n        each$d(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock: isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents: getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle: getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        isEditable,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$e(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$5(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              } else {\n                return Promise.resolve();\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => {\n              processQueue(uniqueScripts).then(resolve, reject);\n            });\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const isDuplicated = (items, item) => {\n      const firstIndex = items.indexOf(item);\n      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n    };\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      const lcNames = map$3(keys(items), name => name.toLowerCase());\n      each$d(items, (translation, name) => {\n        const lcName = name.toLowerCase();\n        if (lcName !== name && isDuplicated(lcNames, lcName)) {\n          if (!has$2(items, lcName)) {\n            langData[lcName] = translation;\n          }\n          langData[name] = translation;\n        } else {\n          langData[lcName] = translation;\n        }\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textStr = toString(text);\n        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n        each$e(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const repeatable = delay => {\n      const intervalId = Cell(Optional.none());\n      const revoke = () => intervalId.get().each(id => clearInterval(id));\n      const clear = () => {\n        revoke();\n        intervalId.set(Optional.none());\n      };\n      const isSet = () => intervalId.get().isSome();\n      const get = () => intervalId.get();\n      const set = functionToRepeat => {\n        revoke();\n        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n    const dataAnnotationClasses = constant('data-mce-annotation-classes');\n    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n\n    const isRoot$1 = root => node => eq(node, root);\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, isRoot$1(root));\n      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const descendants$1 = descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$e(markers, m => {\n        if (!isBogusElement(m, body)) {\n          const uid = get$9(m, dataAnnotationId());\n          const nodesAlready = get$a(directory, uid).getOr([]);\n          directory[uid] = nodesAlready.concat([m]);\n        }\n      });\n      return directory;\n    };\n\n    const setup$y = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$e(findMarkers(editor, uid), elem => {\n          if (state) {\n            set$3(elem, dataAnnotationActive(), 'true');\n          } else {\n            remove$a(elem, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last$1(() => {\n        const annotations = sort(registry.getNames());\n        each$e(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$x = (editor, registry) => {\n      const dataAnnotation$1 = dataAnnotation();\n      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n      const removeDirectAnnotation = node => {\n        var _a, _b;\n        node.attr(dataAnnotationId(), null);\n        node.attr(dataAnnotation(), null);\n        node.attr(dataAnnotationActive(), null);\n        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n        each$e(customAttrNames, name => node.attr(name, null));\n        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n        const newClassList = difference(classList, [annotation()].concat(customClasses));\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n        node.attr(dataAnnotationClasses(), null);\n        node.attr(dataAnnotationAttributes(), null);\n      };\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n        for (const node of nodes) {\n          identifyParserNode(node).each(settings => {\n            if (settings.persistent === false) {\n              if (node.name === 'span') {\n                node.unwrap();\n              } else {\n                removeDirectAnnotation(node);\n              }\n            }\n          });\n        }\n      });\n    };\n\n    const create$c = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$e(classes, x => {\n        add$2(element, x);\n      });\n    };\n    const remove$4 = (element, classes) => {\n      each$e(classes, x => {\n        remove$7(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children = children$1(original);\n      append(nu, children);\n      remove$5(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$a(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$a);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$a),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$a(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const round$2 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$2(rect.left),\n        top: round$2(rect.top),\n        bottom: round$2(rect.bottom),\n        right: round$2(rect.right),\n        width: round$2(rect.width),\n        height: round$2(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$2 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$7 = isText$a;\n    const isBr$3 = isBr$6;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      var _a;\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$7(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n            if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$7(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$7(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$a(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$6 = isText$a;\n    const isBogus = isBogus$2;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      let tempNode = node;\n      while (tempNode = tempNode.previousSibling) {\n        if (!isText$6(tempNode)) {\n          break;\n        }\n        offset += tempNode.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$6(node) && isText$6(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (predicate && predicate(tempNode)) {\n          break;\n        }\n        parents.push(tempNode);\n      }\n      return parents;\n    };\n    const create$b = (root, caretPosition) => {\n      let path = [];\n      let container = caretPosition.container();\n      let offset = caretPosition.offset();\n      let outputOffset;\n      if (isText$6(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      let parents = parentsUntil$1(root, container);\n      parents = filter$3(parents, not(isBogus$2));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$3(nodes, (node, index) => {\n        return !isText$6(node) || !isText$6(nodes[index - 1]);\n      });\n      nodes = filter$3(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container;\n      let targetOffset = 0;\n      while (isText$6(node)) {\n        const dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$6(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$6(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      const offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$6(container) && container.parentNode) {\n        let nodeOffset;\n        if (offset === 'after') {\n          nodeOffset = nodeIndex(container) + 1;\n        } else {\n          nodeOffset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, nodeOffset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$9 = isContentEditableFalse$b;\n    const getNormalizedTextOffset$1 = (trim, container, offset) => {\n      let trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const point = [];\n      const root = dom.getRoot();\n      if (isText$a(container)) {\n        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n      } else {\n        let after = 0;\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (let node = container; node && node !== root; node = node.parentNode) {\n        point.push(dom.nodeIndex(node, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom;\n      const start = getPoint(dom, trim, normalized, rng, true);\n      const forward = selection.isForward();\n      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};\n      if (!selection.isCollapsed()) {\n        const end = getPoint(dom, trim, normalized, rng, false);\n        return {\n          start,\n          end,\n          forward,\n          ...fakeCaret\n        };\n      } else {\n        return {\n          start,\n          forward,\n          ...fakeCaret\n        };\n      }\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        } else if (node === element) {\n          return false;\n        } else {\n          count++;\n          return;\n        }\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        const childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          if (start) {\n            rng.setStart(container, offset);\n          } else {\n            rng.setEnd(container, offset);\n          }\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$9(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$a(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        let sibling = node.previousSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n      }\n      return undefined;\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      const rng = selection.getRng();\n      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n        const name = element.nodeName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        const name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n        forward: selection.isForward()\n      };\n    };\n    const getRangeBookmark = selection => {\n      return {\n        rng: selection.getRng(),\n        forward: selection.isForward()\n      };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      const forward = selection.isForward();\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true,\n        forward\n      });\n      return {\n        id,\n        forward\n      };\n    };\n    const getBookmark$2 = (selection, type, normalized = false) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$2, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$e(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$e(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const normalizePattern = pattern => {\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0]\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n    const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns),\n      dynamicPatternsLookup\n    });\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$e(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n    const fromRawPatternsLookup = lookupFn => {\n      return ctx => {\n        const rawPatterns = lookupFn(ctx);\n        return fromRawPatterns(rawPatterns);\n      };\n    };\n\n    const deviceDetection$1 = detect$2().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$4(key)] = trim$4(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('newline_behavior', {\n        processor: value => {\n          const valid = contains$2([\n            'block',\n            'linebreak',\n            'invert',\n            'default'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: block, linebreak, invert or default.'\n          };\n        },\n        default: 'default'\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: value => {\n          if (isBoolean(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else if (isString(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: 'blockquote'\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$4),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline$1(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,span.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'object' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('format_noneditable_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('editable_root', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('pad_empty_with_br', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: 'string' });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1'\n          },\n          {\n            start: '##',\n            format: 'h2'\n          },\n          {\n            start: '###',\n            format: 'h3'\n          },\n          {\n            start: '####',\n            format: 'h4'\n          },\n          {\n            start: '#####',\n            format: 'h5'\n          },\n          {\n            start: '######',\n            format: 'h6'\n          },\n          {\n            start: '1. ',\n            cmd: 'InsertOrderedList'\n          },\n          {\n            start: '* ',\n            cmd: 'InsertUnorderedList'\n          },\n          {\n            start: '- ',\n            cmd: 'InsertUnorderedList'\n          }\n        ]\n      });\n      registerOption('text_patterns_lookup', {\n        processor: value => {\n          if (isFunction(value)) {\n            return {\n              value: fromRawPatternsLookup(value),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a single function'\n            };\n          }\n        },\n        default: _ctx => []\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('highlight_on_focus', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('xss_sanitization', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('details_initial_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('details_serialized_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('init_content_sync', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('newdocument_content', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('force_hex_color', {\n        processor: value => {\n          const options = [\n            'always',\n            'rgb_only',\n            'off'\n          ];\n          const valid = contains$2(options, value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: `Must be one of: ${ options.join(', ') }.`\n          };\n        },\n        default: 'off'\n      });\n      registerOption('sandbox_iframes', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_unsafe_embeds', {\n        processor: 'boolean',\n        default: false\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getNewlineBehavior = option('newline_behavior');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getFormatNoneditableSelector = option('format_noneditable_selector');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline$1 = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasEditableRoot$1 = option('editable_root');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getNewDocumentContent = option('newdocument_content');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getTextPatternsLookup = option('text_patterns_lookup');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const shouldPreserveCData = option('preserve_cdata');\n    const shouldHighlightOnFocus = option('highlight_on_focus');\n    const shouldSanitizeXss = option('xss_sanitization');\n    const shouldUseDocumentWrite = option('init_content_sync');\n    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n    const getDetailsInitialState = option('details_initial_state');\n    const getDetailsSerializedState = option('details_serialized_state');\n    const shouldForceHexColor = option('force_hex_color');\n    const shouldSandboxIframes = option('sandbox_iframes');\n\n    const isElement$3 = isElement$6;\n    const isText$5 = isText$a;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$2(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$3(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$3(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$3 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$5(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$b;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$1 = isTableCell$3;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      var _a, _b;\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$1(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          const caretContainer = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainer, 'top', clientRect.top);\n          caretContainerNode = caretContainer;\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainer, 0);\n          rng.setEnd(caretContainer, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$3(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => {\n      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n    };\n\n    const isContentEditableTrue$1 = isContentEditableTrue$3;\n    const isContentEditableFalse$7 = isContentEditableFalse$b;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isText$4 = isText$a;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n      let tempNode;\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$1(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return Optional.none();\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return Optional.none();\n      }\n      return Optional.from(container.childNodes[offset + relativeOffset]);\n    };\n    const beforeAfter = (before, node) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const range = doc.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        let sibling = tempNode[siblingName];\n        if (sibling && isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, tempNode)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        const block = isText$4(container) ? container.parentNode : container;\n        const location = block.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = block.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = block.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$a(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      let pos = caretPosition;\n      while (pos = walkFn(pos)) {\n        if (pos.isVisible()) {\n          return pos;\n        }\n      }\n      return pos;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$6(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$6 = isContentEditableFalse$b;\n    const isText$3 = isText$a;\n    const isElement$1 = isElement$6;\n    const isBr$2 = isBr$6;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        parents.push(tempNode);\n        tempNode = tempNode.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$2(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$3(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$3(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$2(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$a(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n    const getParentCaretContainer = (body, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== body) {\n        if (isCaretNode(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n      return lift2(startPos, endPos, (start, end) => {\n        const range = dom.createRng();\n        range.setStart(start.container(), start.offset());\n        range.setEnd(end.container(), end.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const insertZwsp = (node, rng) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => !node.hasChildNodes();\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      const root = dom.getRoot();\n      if (point) {\n        let node = root;\n        let offset = point[0];\n        for (let i = point.length - 1; node && i >= 1; i--) {\n          const children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (isText$a(node)) {\n          offset = Math.min(point[0], node.data.length);\n        }\n        if (isElement$6(node)) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$a(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      const marker = dom.get(bookmark.id + '_' + suffix);\n      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n      const keep = bookmark.keep;\n      if (marker && markerParent) {\n        let container;\n        let offset;\n        if (suffix === 'start') {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              container = marker.nextSibling;\n              offset = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker) + 1;\n            }\n          }\n        } else {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker);\n            }\n          }\n        }\n        if (!keep) {\n          const prev = marker.previousSibling;\n          const next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$a(node)) {\n              node.data = node.data.replace(/\\uFEFF/g, '');\n            }\n          });\n          let otherMarker;\n          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(otherMarker, true);\n          }\n          if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {\n            const idx = prev.data.length;\n            prev.appendData(next.data);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const range = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n        return Optional.some({\n          range,\n          forward: isForwardBookmark(bookmark)\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const range = dom.createRng();\n        range.setStart(addBogus(dom, spos.container()), spos.offset());\n        range.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const range = dom.createRng();\n      range.selectNode(elm);\n      return {\n        range,\n        forward: true\n      };\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return resolveCaretPositionBookmark(dom, bookmark);\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some({\n            range: bookmark.rng,\n            forward: isForwardBookmark(bookmark)\n          });\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$1 = (selection, type, normalized) => {\n      return getBookmark$2(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(({range, forward}) => {\n        selection.setRng(range, forward);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$a(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$a(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node;\n      const walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      let currentNode = node;\n      do {\n        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n          if (start) {\n            rng.setStart(currentNode, 0);\n          } else {\n            rng.setEnd(currentNode, currentNode.data.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n          if (start) {\n            rng.setStartBefore(currentNode);\n          } else {\n            if (currentNode.nodeName === 'BR') {\n              rng.setEndBefore(currentNode);\n            } else {\n              rng.setEndAfter(currentNode);\n            }\n          }\n          return;\n        }\n      } while (currentNode = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return isNonNullable(sel) && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$e(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const isElementDirectlySelected = (dom, node) => {\n      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n        const value = parseInt(selectedAttr, 10);\n        return !isNaN(value) && value > 0;\n      } else {\n        return false;\n      }\n    };\n    const preserveSelection = (editor, action, shouldMoveStart) => {\n      const {selection, dom} = editor;\n      const selectedNodeBeforeAction = selection.getNode();\n      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n      preserve(selection, true, () => {\n        action();\n      });\n      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n        editor.selection.select(selectedNodeBeforeAction);\n      } else if (shouldMoveStart(selection.getStart())) {\n        moveStartToNearestText(dom, selection);\n      }\n    };\n    const moveStartToNearestText = (dom, selection) => {\n      var _a, _b;\n      const rng = selection.getRng();\n      const {startContainer, startOffset} = rng;\n      const selectedNode = selection.getNode();\n      if (isElementDirectlySelected(dom, selectedNode)) {\n        return;\n      }\n      if (isElement$6(startContainer)) {\n        const nodes = startContainer.childNodes;\n        const root = dom.getRoot();\n        let walker;\n        if (startOffset < nodes.length) {\n          const startNode = nodes[startOffset];\n          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n        } else {\n          const startNode = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (dom.getContentEditable(node) === 'false') {\n            return;\n          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$a(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$a(node) && node.length === 0;\n    };\n    const isWrapNoneditableTarget = (editor, node) => {\n      const baseDataSelector = '[data-mce-cef-wrappable]';\n      const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;\n      return is$1(SugarElement.fromDom(node), selector);\n    };\n    const isWrappableNoneditable = (editor, node) => {\n      const dom = editor.dom;\n      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        return value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (isNullable(value)) {\n        return null;\n      } else {\n        let strValue = String(value);\n        if (name === 'color' || name === 'backgroundColor') {\n          strValue = rgbaToHexString(strValue);\n        }\n        if (name === 'fontWeight' && value === 700) {\n          strValue = 'bold';\n        }\n        if (name === 'fontFamily') {\n          strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n        }\n        return strValue;\n      }\n    };\n    const getStyle = (dom, node, name) => {\n      const style = dom.getStyle(node, name);\n      return normalizeStyleValue(style, name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        if (isElement$6(n)) {\n          decoration = dom.getStyle(n, 'text-decoration');\n          return !!decoration && decoration !== 'none';\n        } else {\n          return false;\n        }\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isFormatPredicate = (editor, formatName, predicate) => {\n      const formats = editor.formatter.get(formatName);\n      return isNonNullable(formats) && exists(formats, predicate);\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return isFormatPredicate(editor, formatName, hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return isFormatPredicate(editor, formatName, fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return isFormatPredicate(editor, otherFormatName, fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      let tempNode = node;\n      while (tempNode) {\n        if (isText$a(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n          return [];\n        }\n        if (isElement$6(tempNode)) {\n          nodes.push(tempNode);\n        }\n        tempNode = tempNode.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      if (start) {\n        for (let i = offset; i > 0; i--) {\n          if (predicate(str.charAt(i - 1))) {\n            return i;\n          }\n        }\n      } else {\n        for (let i = offset; i < str.length; i++) {\n          if (predicate(str.charAt(i))) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      const sibling = container[siblingName];\n      if (isText$a(container) && isEmpty$3(container.data) && sibling) {\n        container = sibling;\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n      var _a;\n      let node = container;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n        node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$a(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (parent) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$a(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$a(endContainer)) {\n          endOffset = endContainer.data.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$a(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$a(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n          }\n        }\n      }\n      if (isElement$6(startContainer) && startContainer.parentNode) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer) && endContainer.parentNode) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      var _a;\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const validBlocks = [\n      'pre[class*=language-][contenteditable=\"false\"]',\n      'figure.image',\n      'div[data-ephox-embed-iri]',\n      'div.tiny-pageembed',\n      'div.mce-toc',\n      'div[data-mce-toc]'\n    ];\n    const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n        return 'valid-block';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n      const {uid = masterUId, ...otherData} = data;\n      add$2(elem, annotation());\n      set$3(elem, `${ dataAnnotationId() }`, uid);\n      set$3(elem, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, otherData);\n      setAll$1(elem, attributes);\n      add(elem, classes);\n      if (directAnnotation) {\n        if (classes.length > 0) {\n          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));\n        }\n        const attributeNames = keys(attributes);\n        if (attributeNames.length > 0) {\n          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));\n        }\n      }\n    };\n    const removeDirectAnnotation = elem => {\n      remove$7(elem, annotation());\n      remove$a(elem, `${ dataAnnotationId() }`);\n      remove$a(elem, `${ dataAnnotation() }`);\n      remove$a(elem, `${ dataAnnotationActive() }`);\n      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);\n      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => remove$a(elem, name));\n      remove$4(elem, customClasses);\n      remove$a(elem, `${ dataAnnotationClasses() }`);\n      remove$a(elem, `${ dataAnnotationAttributes() }`);\n    };\n    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      applyAnnotation(master, uid, data, annotationName, decorate, false);\n      return master;\n    };\n    const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$e(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n        case 'valid-block': {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        const masterUid = generate$1('mce-annotation');\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n          set$1(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$c();\n      setup$x(editor, registry);\n      const changes = setup$y(editor, registry);\n      const isSpan = isTag('span');\n      const removeAnnotations = elements => {\n        each$e(elements, element => {\n          if (isSpan(element)) {\n            unwrap(element);\n          } else {\n            removeDirectAnnotation(element);\n          }\n        });\n      };\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            const bookmark = editor.selection.getBookmark();\n            removeAnnotations(elements);\n            editor.selection.moveToBookmark(bookmark);\n          });\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$d(findAll(editor, name), (elements, _) => {\n            removeAnnotations(elements);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$1, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => {\n      editor.dispatch('remove');\n    };\n    const fireDetach = editor => {\n      editor.dispatch('detach');\n    };\n    const fireSwitchMode = (editor, mode) => {\n      editor.dispatch('SwitchMode', { mode });\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => {\n      editor.dispatch('PreInit');\n    };\n    const firePostRender = editor => {\n      editor.dispatch('PostRender');\n    };\n    const fireInit = editor => {\n      editor.dispatch('Init');\n    };\n    const firePlaceholderToggle = (editor, state) => {\n      editor.dispatch('PlaceholderToggle', { state });\n    };\n    const fireError = (editor, errorType, error) => {\n      editor.dispatch(errorType, error);\n    };\n    const fireFormatApply = (editor, format, node, vars) => {\n      editor.dispatch('FormatApply', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireFormatRemove = (editor, format, node, vars) => {\n      editor.dispatch('FormatRemove', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => {\n      editor.dispatch('AutocompleterStart', args);\n    };\n    const fireAutocompleterUpdate = (editor, args) => {\n      editor.dispatch('AutocompleterUpdate', args);\n    };\n    const fireAutocompleterEnd = editor => {\n      editor.dispatch('AutocompleterEnd');\n    };\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const elementSelectionAttr = 'data-mce-selected';\n    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n    const abs = Math.abs;\n    const round$1 = Math.round;\n    const resizeHandles = {\n      nw: [\n        0,\n        0,\n        -1,\n        -1\n      ],\n      ne: [\n        1,\n        0,\n        1,\n        -1\n      ],\n      se: [\n        1,\n        1,\n        1,\n        1\n      ],\n      sw: [\n        0,\n        1,\n        -1,\n        1\n      ]\n    };\n    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n    const ControlSelection = (selection, editor) => {\n      const dom = editor.dom;\n      const editableDoc = editor.getDoc();\n      const rootDocument = document;\n      const rootElement = editor.getBody();\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width;\n      let height;\n      let startScrollWidth;\n      let startScrollHeight;\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (isTouchEvent(evt)) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = elm => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$e(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round$1(width * ratio);\n            width = round$1(height / ratio);\n          } else {\n            width = round$1(height / ratio);\n            height = round$1(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each$d(resizeHandles, (handle, name) => {\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            let handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect(false);\n        }\n      };\n      const throttledShowResizeRect = first$1(showResizeRect, 0);\n      const hideResizeRect = (removeSelected = true) => {\n        throttledShowResizeRect.cancel();\n        unbindResizeHandleEvents();\n        if (selectedElm && removeSelected) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$d(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n      const updateResizeRect = e => {\n        if (resizeStarted || editor.removed || editor.composing) {\n          return;\n        }\n        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n          disableGeckoResize();\n          const startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n            throttledShowResizeRect.throttle(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$d(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            updateResizeRect(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        throttledShowResizeRect.cancel();\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$a = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$a };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint$1 = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$e(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => {\n      const win = defaultView(SugarElement.fromDom(doc));\n      return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n        const rng = doc.createRange();\n        rng.setStart(simRange.start.dom, simRange.soffset);\n        rng.setEnd(simRange.finish.dom, simRange.foffset);\n        return rng;\n      }).getOrUndefined();\n    };\n\n    const isEq$4 = (rng1, rng2) => {\n      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== rootNode) {\n        if (predicate(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n        let currentNode;\n        while (currentNode = walker[left ? 'prev' : 'next']()) {\n          if (isBr$6(currentNode)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const isPrevNode = (node, name) => {\n      var _a;\n      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n    };\n    const hasContentEditableFalseParent = (root, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== root) {\n        if (isContentEditableFalse$b(currentNode)) {\n          return true;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      const body = dom.getRoot();\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentNode = startNode.parentNode;\n      let lastInlineElement;\n      let node;\n      if (!parentNode) {\n        return Optional.none();\n      }\n      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$a(node) && node.data.length > 0) {\n          if (!hasParentWithName(node, body, 'A')) {\n            return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (isComment(lastInlineElement)) {\n        return Optional.none();\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      const body = dom.getRoot();\n      let node;\n      let normalized = false;\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      let directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$a(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable$2(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (isDetails(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && !isTable$2(container)) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$a(node) && node.data.length > 0) {\n                offset = directionLeft ? 0 : node.data.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$a(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$a(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.data.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            const newContainer = splitText(endContainer, endOffset).previousSibling;\n            startContainer = endContainer = newContainer;\n            endOffset = newContainer.data.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          endContainer = newContainer;\n          endOffset = newContainer.data.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      const expand = (rng, options = { type: 'word' }) => {\n        if (options.type === 'word') {\n          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);\n          const newRange = dom.createRng();\n          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n          return newRange;\n        }\n        return rng;\n      };\n      return {\n        walk,\n        split: split$1,\n        expand,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children = children$1(element);\n      if (children.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n        return {\n          element: children[offset],\n          offset: 0\n        };\n      } else {\n        const last = children[children.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$b(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children$1(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$5(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(editor, doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(-editor.getBody().getBoundingClientRect().left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(editor, marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      const toggleContentAreaOnFocus = (editor, fn) => {\n        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n          const contentArea = SugarElement.fromDom(editor.getContainer());\n          fn(contentArea, 'tox-edit-focus');\n        }\n      };\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (isEditorContentAreaElement(getActiveElement(editor))) {\n          toggleContentAreaOnFocus(editor, add$2);\n        }\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n            toggleContentAreaOnFocus(editor, remove$7);\n          }\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              const elem = target;\n              if (elem.ownerDocument === document) {\n                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor && documentFocusInHandler) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$w = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (!contains(root, node)) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n        focusBody(contentEditableHost);\n        normalizeSelection(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const isEditableRange = (dom, rng) => {\n      if (rng.collapsed) {\n        return dom.isEditable(rng.startContainer);\n      } else {\n        return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$a(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      if (!rng) {\n        return root;\n      }\n      let startContainer = rng.startContainer;\n      let endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      let node = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              node = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (isText$a(startContainer) && isText$a(endContainer)) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            node = startContainer;\n          }\n        }\n      }\n      const elm = isText$a(node) ? node.parentNode : node;\n      return isHTMLElement(elm) ? elm : root;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n      if (start && start !== root) {\n        selectedBlocks.push(start);\n      }\n      if (start && end && start !== end) {\n        let node;\n        const walker = new DomTreeWalker(start, root);\n        while ((node = walker.next()) && node !== end) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (end && start !== end && end !== root) {\n        selectedBlocks.push(end);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(parent, idx);\n      rng.setEnd(parent, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    }));\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse$5 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);\n    };\n\n    const first = element => descendant$2(element, isCursorPosition);\n    const last = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children = children$1(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const autocompleteSelector = '[data-mce-autocompleter]';\n    const create$9 = (editor, range) => {\n      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n        append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n        range.insertNode(wrapper.dom);\n        parent(wrapper).each(elm => elm.dom.normalize());\n        last(wrapper).map(last => {\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\n        });\n      }\n    };\n    const detect$1 = elm => closest$3(elm, autocompleteSelector);\n    const findIn = elm => descendant$1(elm, autocompleteSelector);\n    const remove$2 = (editor, elm) => findIn(elm).each(wrapper => {\n      const bookmark = editor.selection.getBookmark();\n      unwrap(wrapper);\n      editor.selection.moveToBookmark(bookmark);\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isEmptyTextNode = node => {\n      var _a;\n      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n      if (!isWhitespaceText(text)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$d(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        if (!isString(name)) {\n          if (isNonNullable(name)) {\n            each$d(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        const attrs = self.attributes;\n        if (attrs) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n        return undefined;\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        const selfAttrs = self.attributes;\n        if (selfAttrs) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        if (self.parent) {\n          self.parent.insert(wrapper, self);\n          wrapper.append(self);\n        }\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else if (prev) {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else if (next) {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else if (refNode.prev) {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else if (refNode.next) {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        var _a;\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n    const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n    const getTemporaryNodeSelector = tempAttrs => `${ tempAttrs.length === 0 ? '' : `${ map$3(tempAttrs, attr => `[${ attr }]`).join(',') },` }[data-mce-bogus=\"all\"]`;\n    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n    const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n    const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n      if (containsZwsp(node)) {\n        const parent = node.parentNode;\n        return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      } else {\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n    const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n    const trimTemporaryNodes = (tempAttrs, body) => {\n      each$e(getTemporaryNodes(tempAttrs, body), elm => {\n        const element = SugarElement.fromDom(elm);\n        if (get$9(element, 'data-mce-bogus') === 'all') {\n          remove$5(element);\n        } else {\n          each$e(tempAttrs, attr => {\n            if (has$1(element, attr)) {\n              remove$a(element, attr);\n            }\n          });\n        }\n      });\n    };\n    const emptyAllNodeValuesInWalker = walker => {\n      let curr = walker.nextNode();\n      while (curr !== null) {\n        curr.nodeValue = null;\n        curr = walker.nextNode();\n      }\n    };\n    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n    const trim$1 = (body, tempAttrs) => {\n      const conditionalTrims = [\n        {\n          condition: curry(hasTemporaryNode, tempAttrs),\n          action: curry(trimTemporaryNodes, tempAttrs)\n        },\n        {\n          condition: hasZwspComment,\n          action: emptyZwspComments\n        },\n        {\n          condition: hasUnescapedZwspText,\n          action: emptyUnescapedZwspTexts\n        }\n      ];\n      let trimmed = body;\n      let cloned = false;\n      each$e(conditionalTrims, ({condition, action}) => {\n        if (condition(trimmed)) {\n          if (!cloned) {\n            trimmed = body.cloneNode(true);\n            cloned = true;\n          }\n          action(trimmed);\n        }\n      });\n      return trimmed;\n    };\n\n    const cleanupBogusElements = parent => {\n      const bogusElements = descendants(parent, '[data-mce-bogus]');\n      each$e(bogusElements, elem => {\n        const bogusValue = get$9(elem, 'data-mce-bogus');\n        if (bogusValue === 'all') {\n          remove$5(elem);\n        } else if (isBr$5(elem)) {\n          before$3(elem, SugarElement.fromText(zeroWidth));\n          remove$5(elem);\n        } else {\n          unwrap(elem);\n        }\n      });\n    };\n    const cleanupInputNames = parent => {\n      const inputs = descendants(parent, 'input');\n      each$e(inputs, input => {\n        remove$a(input, 'name');\n      });\n    };\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getPlainTextContent = (editor, body) => {\n      const doc = editor.getDoc();\n      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n      const offscreenDiv = SugarElement.fromTag('div', doc);\n      set$3(offscreenDiv, 'data-mce-bogus', 'all');\n      setAll(offscreenDiv, {\n        position: 'fixed',\n        left: '-9999999px',\n        top: '0'\n      });\n      set$1(offscreenDiv, body.innerHTML);\n      cleanupBogusElements(offscreenDiv);\n      cleanupInputNames(offscreenDiv);\n      const root = getContentContainer(dos);\n      append$1(root, offscreenDiv);\n      const content = trim$2(offscreenDiv.dom.innerText);\n      remove$5(offscreenDiv);\n      return content;\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n      } else if (args.format === 'text') {\n        content = getPlainTextContent(editor, body);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          if (indent && indentBefore[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (let i = 0, l = attrs.length; i < l; i++) {\n              const attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings = {}, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            var _a;\n            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n          },\n          8: node => {\n            var _a;\n            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            var _a;\n            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          4: node => {\n            var _a;\n            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          11: node => {\n            let tempNode = node;\n            if (tempNode = tempNode.firstChild) {\n              do {\n                walk(tempNode);\n              } while (tempNode = tempNode.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          var _a;\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (isNonHtmlElementRootName(name)) {\n              if (isString(node.value)) {\n                writer.text(node.value, true);\n              }\n              writer.end(name);\n            } else {\n              if (!isEmpty) {\n                let child = node.firstChild;\n                if (child) {\n                  if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                    writer.text('\\n', true);\n                  }\n                  do {\n                    walk(child);\n                  } while (child = child.next);\n                }\n                writer.end(name);\n              }\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-color',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$e(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$2);\n    const isAfterTable = matchesElementPosition(false, isTable$2);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const isBlock$1 = schema => el => schema.isBlock(name(el));\n    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n    const findBr = (forward, root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n    };\n    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n    const isSiblingCefBlock = (root, direction) => container => {\n      return isCefBlock(new DomTreeWalker(container, root)[direction]());\n    };\n    const isBeforeCefBlock = (root, pos) => {\n      const nextPos = nextPosition(root.dom, pos).getOr(pos);\n      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n    };\n    const isAfterCefBlock = (root, pos) => {\n      const prevPos = prevPosition(root.dom, pos).getOr(pos);\n      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n    };\n    const needsToHaveNbsp = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$a(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$a(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n        node.data = nbsp + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + nbsp;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps = (root, pos, schema) => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return Optional.none();\n      }\n      if (hasNbsp(pos)) {\n        const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n        return someIf(normalized, pos);\n      } else if (needsToBeNbsp(root, pos, schema)) {\n        const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n        return someIf(normalized, pos);\n      } else {\n        return Optional.none();\n      }\n    };\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count, schema) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset, schema) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount, schema);\n    };\n    const normalizeWhitespaceBefore = (node, offset, schema) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n    };\n    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$5(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = (elm, preserveEmptyCaret) => {\n      if (isEmpty$2(elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        if (preserveEmptyCaret) {\n          each$e(children$1(elm), node => {\n            if (!isEmptyCaretFormatElement(node)) {\n              remove$5(node);\n            }\n          });\n        } else {\n          empty(elm);\n        }\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$b);\n      const nextTextOpt = nextSibling(elm).filter(isText$b);\n      remove$5(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(elm => paddEmptyBlock(elm, preserveEmptyCaret)).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n    const isRtl = element => {\n      var _a;\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n    };\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return isNonNullable(block1) && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$a(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$a(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execEditorDeleteCommand = editor => {\n      editor.execCommand('delete');\n    };\n    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const paddEmptyBody = (editor, moveSelection = true) => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('', { no_selection: !moveSelection });\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n      var _a;\n      rng.deleteContents();\n      const lastNode = freefallRtl(root).getOr(root);\n      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n      if (lastBlock.dom === editor.getBody()) {\n        paddEmptyBody(editor, moveSelection);\n      } else if (isEmpty$2(lastBlock)) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(root, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n        each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n            remove$5(node);\n          }\n        });\n      }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n    const selectionInTableWithNestedTable = details => {\n      return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n        const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n        const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\n          ...details,\n          startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n          endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n          isSameTable: false,\n          isMultiTable: false\n        };\n      }).getOr(details);\n    };\n    const adjustQuirksInDetails = details => {\n      return selectionInTableWithNestedTable(details);\n    };\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const startTable = getTable$1(rng.startContainer, isRoot);\n      const endTable = getTable$1(rng.endContainer, isRoot);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return adjustQuirksInDetails({\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      });\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const cleanCells = cells => each$e(cells, cell => {\n      remove$a(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$5(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$3(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      deleteRangeContents(editor, rng, cell, moveSelection);\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$3 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$a = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n          return tempNode;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n\n    const internalAttributesPrefixes = [\n      'data-ephox-',\n      'data-mce-',\n      'data-alloy-',\n      'data-snooker-',\n      '_'\n    ];\n    const each$9 = Tools.each;\n    const ElementUtils = editor => {\n      const dom = editor.dom;\n      const internalAttributes = new Set(editor.serializer.getTempAttrs());\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$9(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name !== 'style' && !isAttributeInternal(name)) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          for (const name in obj1) {\n            if (has$2(obj1, name)) {\n              const value = obj2[name];\n              if (isUndefined(value)) {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (const name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (isElement$6(node1) && isElement$6(node2)) {\n          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n            return false;\n          }\n          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n            return false;\n          }\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n      return {\n        compare,\n        isAttributeInternal\n      };\n    };\n\n    const isHeading = node => [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ].includes(node.name);\n    const isSummary = node => node.name === 'summary';\n\n    const traverse = (root, fn) => {\n      let node = root;\n      while (node = node.walk()) {\n        fn(node);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node, childNode => {\n          matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = (matchRecord, filteringAttributes) => {\n        each$d(matchRecord, match => {\n          const nodes = from(match.nodes);\n          each$e(match.filter.callbacks, callback => {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n              const node = nodes[i];\n              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n              if (!valueMatches || isNullable(node.parent)) {\n                nodes.splice(i, 1);\n              }\n            }\n            if (nodes.length > 0) {\n              callback(nodes, match.filter.name, args);\n            }\n          });\n        });\n      };\n      run(matches.nodes, false);\n      run(matches.attributes, true);\n    };\n    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, isBlock, node) => {\n      const brPreferred = settings.pad_empty_with_br || args.insert;\n      if (brPreferred && isBlock(node)) {\n        const astNode = new AstNode('br', 1);\n        if (args.insert) {\n          astNode.attr('data-mce-bogus', '1');\n        }\n        node.empty().append(astNode);\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => {\n      var _a;\n      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n    };\n    const hasOnlyChild = (node, name) => {\n      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n    };\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n    const findClosestEditingHost = scope => {\n      let editableNode;\n      for (let node = scope; node; node = node.parent) {\n        const contentEditable = node.attr('contenteditable');\n        if (contentEditable === 'false') {\n          break;\n        } else if (contentEditable === 'true') {\n          editableNode = node;\n        }\n      }\n      return Optional.from(editableNode);\n    };\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n      const fixed = new Set();\n      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (!isInvalid(schema, node, parent)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n    const hasClosest = (node, parentName) => {\n      let tempNode = node;\n      while (tempNode) {\n        if (tempNode.name === parentName) {\n          return true;\n        }\n        tempNode = tempNode.parent;\n      }\n      return false;\n    };\n    const isInvalid = (schema, node, parent = node.parent) => {\n      if (!parent) {\n        return false;\n      }\n      if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n        return true;\n      }\n      if (node.name === 'a' && hasClosest(parent, 'a')) {\n        return true;\n      }\n      if (isSummary(parent) && isHeading(node)) {\n        return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n      }\n      return false;\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      var _a, _b;\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      var _a;\n      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$6(node);\n    };\n    const isListItemPadded = node => {\n      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        parentElm.insertBefore(parts[0], target);\n        Tools.each(elms, li => {\n          parentElm.insertBefore(li, target);\n        });\n        parentElm.insertBefore(parts[1], target);\n        parentElm.removeChild(target);\n      }\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$2 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        Tools.each(elms, elm => {\n          parentElm.insertBefore(elm, target);\n        });\n      }\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$2 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n      };\n      if (!liTarget) {\n        return null;\n      } else if (isAt(BEGINNING)) {\n        return insertBefore$2(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$2(liTarget, liElms, rootNode, dom);\n      } else {\n        return insertMiddle(liTarget, liElms, rootNode, rng);\n      }\n    };\n\n    const mergeableWrappedElements = ['pre'];\n    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n      var _a;\n      const firstNode = fragment.firstChild;\n      const lastNode = fragment.lastChild;\n      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n      const isPastingSingleElement = firstNode === last;\n      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n      if (isPastingSingleElement && isWrappedElement) {\n        const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n      } else {\n        return false;\n      }\n    };\n    const isTableCell = isTableCell$3;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (isNonNullable(cell)) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      var _a;\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm, schema) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(editor);\n        Tools.each(dom.select('*[data-mce-fragment]'), node => {\n          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n          if (isInline && hasInheritableStyles(dom, node)) {\n            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {\n              const styleConflict = hasStyleConflict(dom, node, parentNode);\n              if (styleConflict) {\n                break;\n              }\n              if (elementUtils.compare(parentNode, node)) {\n                dom.remove(node, true);\n                break;\n              }\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      var _a, _b, _c;\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$a(node)) {\n        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        const node2 = marker.nextSibling;\n        if (isText$a(node2)) {\n          node.appendData(node2.data);\n          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        const isCell = isTableCell(parentBlock);\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {\n        rng.deleteContents();\n      } else {\n        editor.getDoc().execCommand('Delete', false);\n      }\n    };\n    const findMarkerNode = scope => {\n      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n        if (markerNode.attr('id') === 'mce_marker') {\n          return Optional.some(markerNode);\n        }\n      }\n      return Optional.none();\n    };\n    const notHeadingsInSummary = (dom, node, fragment) => {\n      var _a;\n      return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      var _a, _b;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (!details.preserve_zwsp) {\n        value = trim$2(value);\n      }\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      let rng = selection.getRng();\n      const caretElement = rng.startContainer;\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      const parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        if (rng) {\n          selection.setRng(rng);\n        }\n        return value;\n      }\n      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n      }\n      markFragmentElements(fragment);\n      let node = fragment.lastChild;\n      if (node && node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        let parentNode = selection.getNode();\n        let tempNode;\n        const rootNode = editor.getBody();\n        if (isDocument$1(parentNode)) {\n          parentNode = tempNode = rootNode;\n        } else {\n          tempNode = parentNode;\n        }\n        while (tempNode && tempNode !== rootNode) {\n          parentNode = tempNode;\n          tempNode = tempNode.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        const markerNode = findMarkerNode(root);\n        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n        markerNode.each(marker => marker.replace(fragment));\n        const toExtract = fragment.children();\n        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n        fragment.unwrap();\n        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n      updateCaret(editor.schema, editor.getBody(), selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      content = trim$2(content);\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$1 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      const matchedNode = editor.dom.getParent(node, elm => {\n        if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n          return true;\n        }\n        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n      });\n      return !!matchNode(editor, matchedNode, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      const matchAttributes = itemName === 'attributes';\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (!isArrayLike(items)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && isElement$6(node)) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n      return undefined;\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList && editor.selection.isEditable()) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1;\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n          if (isText$a(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.data.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, moveCaret);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n      if (block && dom.isEmpty(block)) {\n        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      var _a;\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer;\n      const selection = editor.selection;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor.dom, selectionRng, formatList);\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter = false;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      let node = container;\n      if (isText$a(container)) {\n        if (offset !== container.data.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      const parents = [];\n      let formatNode;\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(dom, rng, formatList, true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer([\n          ...parents,\n          ...cleanedFormatNode.toArray(),\n          ...parentsAfter\n        ], newCaretContainer);\n        if (caretContainer) {\n          removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n        }\n        selection.setCursorLocation(caretTextNode, 1);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode, moveCaret) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, moveCaret);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n    };\n    const endsWithNbsp = element => isText$a(element) && endsWith(element.data, nbsp);\n    const setup$v = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n      });\n    };\n    const createCaretFormat = formatNodes => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      return {\n        caretContainer,\n        caretPosition: CaretPosition(innerMost, 0)\n      };\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$5(SugarElement.fromDom(targetNode));\n      return caretPosition;\n    };\n    const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      rng.insertNode(caretContainer.dom);\n      return caretPosition;\n    };\n    const isFormatElement = (editor, element) => {\n      if (isCaretNode(element.dom)) {\n        return false;\n      }\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const isPre = matchNodeNames(['pre']);\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      if (has$2(postProcessHooks, name)) {\n        each$e(postProcessHooks[name], hook => {\n          hook(editor);\n        });\n      }\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      const hasPreSibling = blocks => pre => {\n        const prev = pre.previousSibling;\n        return isPre(prev) && contains$2(blocks, prev);\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$5(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children$1(sPre2)\n        ]);\n      };\n      if (!rng.collapsed) {\n        const blocks = editor.selection.getSelectedBlocks();\n        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n        each$e(preBlocks, pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const listItemStyles = [\n      'fontWeight',\n      'fontStyle',\n      'color',\n      'fontSize',\n      'fontFamily'\n    ];\n    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n    const getExpandedListItemFormat = (formatter, format) => {\n      const formatList = formatter.get(format);\n      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n    };\n    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n    const isRngEndAtEndOfElement = (rng, elm) => {\n      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n    };\n    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n    const getFullySelectedBlocks = selection => {\n      const blocks = selection.getSelectedBlocks();\n      const rng = selection.getRng();\n      if (selection.isCollapsed()) {\n        return [];\n      }\n      if (blocks.length === 1) {\n        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n      } else {\n        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n        const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n        const middle = blocks.slice(1, -1);\n        return first.concat(middle).concat(last);\n      }\n    };\n    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n\n    const each$8 = Tools.each;\n    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$a(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (editor, prev, next) => {\n      const elementUtils = ElementUtils(editor);\n      const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n      const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n      if (isPrevEditable && isNextEditable) {\n        const prevSibling = findElementSibling(prev, 'previousSibling');\n        const nextSibling = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prevSibling, nextSibling)) {\n          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prevSibling.appendChild(tmpSibling);\n          }\n          editor.dom.remove(nextSibling);\n          Tools.each(Tools.grep(nextSibling.childNodes), node => {\n            prevSibling.appendChild(node);\n          });\n          return prevSibling;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (editor, format, vars, node) => {\n      var _a;\n      if (node && format.merge_siblings !== false) {\n        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$8(dom.select(selector, node), childNode => {\n          if (isElementNode(childNode) && dom.isEditable(childNode)) {\n            each$8(format.styles, (_value, name) => {\n              dom.setStyle(childNode, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$8(node.childNodes, node => {\n        if (isElementNode(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$7 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$a(container) && start && offset >= container.data.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$a(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      const childNode = node[prop];\n      if (isTableCellOrRow(node) && childNode) {\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      var _a;\n      const wrapper = dom.create(name, attrs);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$e(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const processFormatAttrOrStyle = (name, value, vars) => {\n      if (isNumber(name)) {\n        return {\n          name: value,\n          value: null\n        };\n      } else {\n        return {\n          name,\n          value: replaceVars(value, vars)\n        };\n      }\n    };\n    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n      if (dom.getAttrib(elm, 'style') === '') {\n        elm.removeAttribute('style');\n        elm.removeAttribute('data-mce-style');\n      }\n    };\n    const removeStyles = (dom, elm, format, vars, compareNode) => {\n      let stylesModified = false;\n      each$7(format.styles, (value, name) => {\n        const {\n          name: styleName,\n          value: styleValue\n        } = processFormatAttrOrStyle(name, value, vars);\n        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n          dom.setStyle(elm, styleName, '');\n        }\n        stylesModified = true;\n      });\n      if (stylesModified) {\n        removeEmptyStyleAttributeIfNeeded(dom, elm);\n      }\n    };\n    const removeListStyleFormats = (editor, name, vars) => {\n      if (name === 'removeformat') {\n        each$e(getPartiallySelectedListItems(editor.selection), li => {\n          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n          removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n        });\n      } else {\n        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n        });\n      }\n    };\n    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n      const dom = ed.dom;\n      const elementUtils = ElementUtils(ed);\n      const schema = ed.schema;\n      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n        removeNode(ed, node, format);\n        return removeResult.removed();\n      }\n      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n        return removeResult.keep();\n      }\n      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      const preserveAttributes = format.preserve_attributes;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        removeStyles(dom, elm, format, vars, compareNode);\n        each$7(format.attributes, (value, name) => {\n          const {\n            name: attrName,\n            value: attrValue\n          } = processFormatAttrOrStyle(name, value, vars);\n          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n            if (attrName === 'class') {\n              const currentValue = dom.getAttrib(elm, attrName);\n              if (currentValue) {\n                let valueOut = '';\n                each$e(currentValue.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, attrName, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(attrName)) {\n              elm.removeAttribute('data-mce-' + attrName);\n            }\n            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(attrName);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (attrName === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(attrName);\n          }\n        });\n        each$7(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (!elementUtils.isAttributeInternal(attrName)) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      if (container.parentNode) {\n        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n            const format = matchNode(editor, parent, name, vars, similar);\n            if (format && format.split !== false) {\n              formatRoot = parent;\n            }\n          }\n        });\n      }\n      return formatRoot;\n    };\n    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      var _a, _b;\n      let lastClone;\n      let firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          let clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n        }\n        if (lastClone && firstClone) {\n          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(editor, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const removeFormatInternal = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n      const process = node => {\n        const children = from(node.childNodes);\n        const removed = removeFormatOnNode(node);\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n        const parentNode = node.parentNode;\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n          removeFormatOnNode(parentNode);\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$e(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeNodeFormat(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, undefined, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        if (node) {\n          let out = node[start ? 'firstChild' : 'lastChild'];\n          if (isRemoveBookmarkNode(out)) {\n            out = out[start ? 'firstChild' : 'lastChild'];\n          }\n          if (isText$a(out) && out.data.length === 0) {\n            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n          }\n          dom.remove(node, true);\n          return out;\n        } else {\n          return null;\n        }\n      };\n      const removeRngStyle = rng => {\n        let startContainer;\n        let endContainer;\n        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$e(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$e(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      removeListStyleFormats(ed, name, vars);\n      fireFormatRemove(ed, name, node, vars);\n    };\n    const removeFormat$1 = (ed, name, vars, node, similar) => {\n      if (node || ed.selection.isEditable()) {\n        removeFormatInternal(ed, name, vars, node, similar);\n      }\n    };\n    const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n        editor.dom.rename(node, newName);\n        return true;\n      }, always);\n    };\n\n    const each$6 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n          const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', parentTextDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n        dom.remove(inverseTagDescendants, true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$6(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$6(editor.dom.select(format.inline, node), child => {\n            if (isElementNode(child)) {\n              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n            }\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      const parentNode = node.parentNode;\n      if (matchNode(editor, parentNode, name, vars)) {\n        if (removeNodeFormat(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents && parentNode) {\n        editor.dom.getParent(parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeNodeFormat(editor, format, vars, node);\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    };\n\n    const each$5 = Tools.each;\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyStyles = (dom, elm, format, vars) => {\n      each$5(format.styles, (value, name) => {\n        dom.setStyle(elm, name, replaceVars(value, vars));\n      });\n      if (format.styles) {\n        const styleVal = dom.getAttrib(elm, 'style');\n        if (styleVal) {\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\n        }\n      }\n    };\n    const applyFormatAction = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        applyStyles(dom, elm, fmt, vars);\n        each$5(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$5(fmt.classes, value => {\n          const newValue = replaceVars(value, vars);\n          if (!dom.hasClass(elm, newValue)) {\n            dom.addClass(elm, newValue);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$5(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n            return true;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return true;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n          return true;\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n        const canRenameBlock = (node, parentName, isEditableDescendant) => {\n          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n          return isEditableDescendant && isValidBlockFormatForNode;\n        };\n        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n          const nodeName = node.nodeName.toLowerCase();\n          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n          const isZwsp = !nodeSpecific && isText$a(node) && isZwsp$1(node.data);\n          const isCaret = isCaretNode(node);\n          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp && !isCaret && isCorrectFormatForNode;\n        };\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            let isWrappableNoneditableElm = false;\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            const contentEditableValue = dom.getContentEditable(node);\n            if (isNonNullable(contentEditableValue)) {\n              lastContentEditable = contentEditable;\n              contentEditable = contentEditableValue === 'true';\n              hasContentEditableState = true;\n              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n            }\n            const isEditableDescendant = contentEditable && !hasContentEditableState;\n            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isMatchingWrappingBlock(node)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (canRenameBlock(node, parentName, isEditableDescendant)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              if (isWrappableNoneditableElm && hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$e(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$e(nodes, process);\n        });\n        if (format.links === true) {\n          each$e(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$e(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$e(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$e(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(ed, format, vars, node);\n          }\n        });\n      };\n      const targetNode = isNode(node) ? node : selection.getNode();\n      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n        node = targetNode;\n        applyNodeStyle(formatList, node);\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserveSelection(ed, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            }, always);\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n          });\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n    const applyFormat$1 = (editor, name, vars, node) => {\n      if (node || editor.selection.isEditable()) {\n        applyFormatAction(editor, name, vars, node);\n      }\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$u = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$d(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$e(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$e([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$e(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$5(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (fmt) {\n        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n          removeFormat$1(editor, name, vars, node);\n        } else {\n          applyFormat$1(editor, name, vars, node);\n        }\n      }\n    };\n\n    const explode$1 = Tools.explode;\n    const create$8 = () => {\n      const filters = {};\n      const addFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (!has$2(filters, name)) {\n            filters[name] = {\n              name,\n              callbacks: []\n            };\n          }\n          filters[name].callbacks.push(callback);\n        });\n      };\n      const getFilters = () => values(filters);\n      const removeFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (has$2(filters, name)) {\n            if (isNonNullable(callback)) {\n              const filter = filters[name];\n              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n              if (newCallbacks.length > 0) {\n                filter.callbacks = newCallbacks;\n              } else {\n                delete filters[name];\n              }\n            } else {\n              delete filters[name];\n            }\n          }\n        });\n      };\n      return {\n        addFilter,\n        getFilters,\n        removeFilter\n      };\n    };\n\n    const removeAttrs = (node, names) => {\n      each$e(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$e(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            toInt(size).each(num => {\n              props['font-size'] = fontSizes[num - 1];\n            });\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$e(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      var _a;\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const addNodeFilter = (settings, htmlParser, schema) => {\n      htmlParser.addNodeFilter('br', (nodes, _, args) => {\n        const blockElements = Tools.extend({}, schema.getBlockElements());\n        const nonEmptyElements = schema.getNonEmptyElements();\n        const whitespaceElements = schema.getWhitespaceElements();\n        blockElements.body = 1;\n        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          let parent = node.parent;\n          if (parent && isBlock(parent) && node === parent.lastChild) {\n            let prev = node.prev;\n            while (prev) {\n              const prevName = prev.name;\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                if (prevName === 'br') {\n                  node = null;\n                }\n                break;\n              }\n              prev = prev.prev;\n            }\n            if (node) {\n              node.remove();\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                const elementRule = schema.getElementRule(parent.name);\n                if (elementRule) {\n                  if (elementRule.removeEmpty) {\n                    parent.remove();\n                  } else if (elementRule.paddEmpty) {\n                    paddEmptyNode(settings, args, isBlock, parent);\n                  }\n                }\n              }\n            }\n          } else {\n            let lastParent = node;\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n              lastParent = parent;\n              if (blockElements[parent.name]) {\n                break;\n              }\n              parent = parent.parent;\n            }\n            if (lastParent === parent) {\n              const textNode = new AstNode('#text', 3);\n              textNode.value = nbsp;\n              node.replace(textNode);\n            }\n          }\n        }\n      });\n    };\n\n    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,\n      uriType: 'blob'\n    }));\n    const extractBase64Data = data => {\n      const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n      return matches ? matches[1] : '';\n    };\n    const parseDataUri = uri => {\n      const [type, ...rest] = uri.split(',');\n      const data = rest.join(',');\n      const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n      if (matches) {\n        const base64Encoded = matches[2] === ';base64';\n        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n        return Optional.some({\n          type: matches[1],\n          data: extractedData,\n          base64Encoded\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const buildBlob = (type, data, base64Encoded = true) => {\n      let str = data;\n      if (base64Encoded) {\n        try {\n          str = atob(data);\n        } catch (e) {\n          return Optional.none();\n        }\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise((resolve, reject) => {\n        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (startsWith(url, 'blob:')) {\n        return blobUriToBlob(url);\n      } else if (startsWith(url, 'data:')) {\n        return dataUriToBlob(url);\n      } else {\n        return Promise.reject('Unknown URI format');\n      }\n    };\n    const blobToDataUri = blob => {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.onerror = () => {\n          var _a;\n          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {\n        if (base64Only && !base64Encoded) {\n          return Optional.none();\n        } else {\n          const base64 = base64Encoded ? data : btoa(data);\n          return generateBlobInfo(base64, type);\n        }\n      });\n    };\n    const createBlobInfo$1 = (blobCache, blob, base64) => {\n      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n    };\n    const imageToBlobInfo = (blobCache, imageSrc) => {\n      const invalidDataUri = () => Promise.reject('Invalid data URI');\n      if (startsWith(imageSrc, 'blob:')) {\n        const blobInfo = blobCache.getByUri(imageSrc);\n        if (isNonNullable(blobInfo)) {\n          return Promise.resolve(blobInfo);\n        } else {\n          return uriToBlob(imageSrc).then(blob => {\n            return blobToDataUri(blob).then(dataUri => {\n              return processDataUri(dataUri, false, base64 => {\n                return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n              }).getOrThunk(invalidDataUri);\n            });\n          });\n        }\n      } else if (startsWith(imageSrc, 'data:')) {\n        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n      } else {\n        return Promise.reject('Unknown image data format');\n      }\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      if (blobCache) {\n        const processImage = img => {\n          const inputSrc = img.attr('src');\n          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n            return;\n          }\n          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n            img.attr('src', blobInfo.blobUri());\n          });\n        };\n        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n      }\n    };\n    const isMimeType = (mime, type) => startsWith(mime, `${ type }/`);\n    const createSafeEmbed = (mime, src, width, height, sandboxIframes) => {\n      let name;\n      if (isUndefined(mime)) {\n        name = 'iframe';\n      } else if (isMimeType(mime, 'image')) {\n        name = 'img';\n      } else if (isMimeType(mime, 'video')) {\n        name = 'video';\n      } else if (isMimeType(mime, 'audio')) {\n        name = 'audio';\n      } else {\n        name = 'iframe';\n      }\n      const embed = new AstNode(name, 1);\n      embed.attr(name === 'audio' ? { src } : {\n        src,\n        width,\n        height\n      });\n      if (name === 'audio' || name === 'video') {\n        embed.attr('controls', '');\n      }\n      if (name === 'iframe' && sandboxIframes) {\n        embed.attr('sandbox', '');\n      }\n      return embed;\n    };\n    const register$4 = (parser, settings) => {\n      const schema = parser.schema;\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, parser, schema);\n      }\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              while (sibling && parent) {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              }\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      const validClasses = schema.getValidClasses();\n      if (settings.validate && validClasses) {\n        parser.addAttributeFilter('class', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n            const classList = Tools.explode(clazz, ' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n      if (settings.convert_unsafe_embeds) {\n        parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n          node.replace(createSafeEmbed(node.attr('type'), node.name === 'object' ? node.attr('data') : node.attr('src'), node.attr('width'), node.attr('height'), settings.sandbox_iframes));\n        }));\n      }\n      if (settings.sandbox_iframes) {\n        parser.addNodeFilter('iframe', nodes => each$e(nodes, node => node.attr('sandbox', '')));\n      }\n    };\n\n    const {entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor} = Object;\n    let {freeze, seal, create: create$7} = Object;\n    let {apply, construct} = typeof Reflect !== 'undefined' && Reflect;\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new Func(...args);\n      };\n    }\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n    function addToSet(set, array, transformCaseFunc) {\n      var _transformCaseFunc;\n      transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n      if (setPrototypeOf) {\n        setPrototypeOf(set, null);\n      }\n      let l = array.length;\n      while (l--) {\n        let element = array[l];\n        if (typeof element === 'string') {\n          const lcElement = transformCaseFunc(element);\n          if (lcElement !== element) {\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n    function clone(object) {\n      const newObject = create$7(null);\n      for (const [property, value] of entries(object)) {\n        newObject[property] = value;\n      }\n      return newObject;\n    }\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue(element) {\n        console.warn('fallback value for', element);\n        return null;\n      }\n      return fallbackValue;\n    }\n    const html$1 = freeze([\n      'a',\n      'abbr',\n      'acronym',\n      'address',\n      'area',\n      'article',\n      'aside',\n      'audio',\n      'b',\n      'bdi',\n      'bdo',\n      'big',\n      'blink',\n      'blockquote',\n      'body',\n      'br',\n      'button',\n      'canvas',\n      'caption',\n      'center',\n      'cite',\n      'code',\n      'col',\n      'colgroup',\n      'content',\n      'data',\n      'datalist',\n      'dd',\n      'decorator',\n      'del',\n      'details',\n      'dfn',\n      'dialog',\n      'dir',\n      'div',\n      'dl',\n      'dt',\n      'element',\n      'em',\n      'fieldset',\n      'figcaption',\n      'figure',\n      'font',\n      'footer',\n      'form',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'head',\n      'header',\n      'hgroup',\n      'hr',\n      'html',\n      'i',\n      'img',\n      'input',\n      'ins',\n      'kbd',\n      'label',\n      'legend',\n      'li',\n      'main',\n      'map',\n      'mark',\n      'marquee',\n      'menu',\n      'menuitem',\n      'meter',\n      'nav',\n      'nobr',\n      'ol',\n      'optgroup',\n      'option',\n      'output',\n      'p',\n      'picture',\n      'pre',\n      'progress',\n      'q',\n      'rp',\n      'rt',\n      'ruby',\n      's',\n      'samp',\n      'section',\n      'select',\n      'shadow',\n      'small',\n      'source',\n      'spacer',\n      'span',\n      'strike',\n      'strong',\n      'style',\n      'sub',\n      'summary',\n      'sup',\n      'table',\n      'tbody',\n      'td',\n      'template',\n      'textarea',\n      'tfoot',\n      'th',\n      'thead',\n      'time',\n      'tr',\n      'track',\n      'tt',\n      'u',\n      'ul',\n      'var',\n      'video',\n      'wbr'\n    ]);\n    const svg$1 = freeze([\n      'svg',\n      'a',\n      'altglyph',\n      'altglyphdef',\n      'altglyphitem',\n      'animatecolor',\n      'animatemotion',\n      'animatetransform',\n      'circle',\n      'clippath',\n      'defs',\n      'desc',\n      'ellipse',\n      'filter',\n      'font',\n      'g',\n      'glyph',\n      'glyphref',\n      'hkern',\n      'image',\n      'line',\n      'lineargradient',\n      'marker',\n      'mask',\n      'metadata',\n      'mpath',\n      'path',\n      'pattern',\n      'polygon',\n      'polyline',\n      'radialgradient',\n      'rect',\n      'stop',\n      'style',\n      'switch',\n      'symbol',\n      'text',\n      'textpath',\n      'title',\n      'tref',\n      'tspan',\n      'view',\n      'vkern'\n    ]);\n    const svgFilters = freeze([\n      'feBlend',\n      'feColorMatrix',\n      'feComponentTransfer',\n      'feComposite',\n      'feConvolveMatrix',\n      'feDiffuseLighting',\n      'feDisplacementMap',\n      'feDistantLight',\n      'feDropShadow',\n      'feFlood',\n      'feFuncA',\n      'feFuncB',\n      'feFuncG',\n      'feFuncR',\n      'feGaussianBlur',\n      'feImage',\n      'feMerge',\n      'feMergeNode',\n      'feMorphology',\n      'feOffset',\n      'fePointLight',\n      'feSpecularLighting',\n      'feSpotLight',\n      'feTile',\n      'feTurbulence'\n    ]);\n    const svgDisallowed = freeze([\n      'animate',\n      'color-profile',\n      'cursor',\n      'discard',\n      'font-face',\n      'font-face-format',\n      'font-face-name',\n      'font-face-src',\n      'font-face-uri',\n      'foreignobject',\n      'hatch',\n      'hatchpath',\n      'mesh',\n      'meshgradient',\n      'meshpatch',\n      'meshrow',\n      'missing-glyph',\n      'script',\n      'set',\n      'solidcolor',\n      'unknown',\n      'use'\n    ]);\n    const mathMl$1 = freeze([\n      'math',\n      'menclose',\n      'merror',\n      'mfenced',\n      'mfrac',\n      'mglyph',\n      'mi',\n      'mlabeledtr',\n      'mmultiscripts',\n      'mn',\n      'mo',\n      'mover',\n      'mpadded',\n      'mphantom',\n      'mroot',\n      'mrow',\n      'ms',\n      'mspace',\n      'msqrt',\n      'mstyle',\n      'msub',\n      'msup',\n      'msubsup',\n      'mtable',\n      'mtd',\n      'mtext',\n      'mtr',\n      'munder',\n      'munderover',\n      'mprescripts'\n    ]);\n    const mathMlDisallowed = freeze([\n      'maction',\n      'maligngroup',\n      'malignmark',\n      'mlongdiv',\n      'mscarries',\n      'mscarry',\n      'msgroup',\n      'mstack',\n      'msline',\n      'msrow',\n      'semantics',\n      'annotation',\n      'annotation-xml',\n      'mprescripts',\n      'none'\n    ]);\n    const text = freeze(['#text']);\n    const html = freeze([\n      'accept',\n      'action',\n      'align',\n      'alt',\n      'autocapitalize',\n      'autocomplete',\n      'autopictureinpicture',\n      'autoplay',\n      'background',\n      'bgcolor',\n      'border',\n      'capture',\n      'cellpadding',\n      'cellspacing',\n      'checked',\n      'cite',\n      'class',\n      'clear',\n      'color',\n      'cols',\n      'colspan',\n      'controls',\n      'controlslist',\n      'coords',\n      'crossorigin',\n      'datetime',\n      'decoding',\n      'default',\n      'dir',\n      'disabled',\n      'disablepictureinpicture',\n      'disableremoteplayback',\n      'download',\n      'draggable',\n      'enctype',\n      'enterkeyhint',\n      'face',\n      'for',\n      'headers',\n      'height',\n      'hidden',\n      'high',\n      'href',\n      'hreflang',\n      'id',\n      'inputmode',\n      'integrity',\n      'ismap',\n      'kind',\n      'label',\n      'lang',\n      'list',\n      'loading',\n      'loop',\n      'low',\n      'max',\n      'maxlength',\n      'media',\n      'method',\n      'min',\n      'minlength',\n      'multiple',\n      'muted',\n      'name',\n      'nonce',\n      'noshade',\n      'novalidate',\n      'nowrap',\n      'open',\n      'optimum',\n      'pattern',\n      'placeholder',\n      'playsinline',\n      'poster',\n      'preload',\n      'pubdate',\n      'radiogroup',\n      'readonly',\n      'rel',\n      'required',\n      'rev',\n      'reversed',\n      'role',\n      'rows',\n      'rowspan',\n      'spellcheck',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'sizes',\n      'span',\n      'srclang',\n      'start',\n      'src',\n      'srcset',\n      'step',\n      'style',\n      'summary',\n      'tabindex',\n      'title',\n      'translate',\n      'type',\n      'usemap',\n      'valign',\n      'value',\n      'width',\n      'xmlns',\n      'slot'\n    ]);\n    const svg = freeze([\n      'accent-height',\n      'accumulate',\n      'additive',\n      'alignment-baseline',\n      'ascent',\n      'attributename',\n      'attributetype',\n      'azimuth',\n      'basefrequency',\n      'baseline-shift',\n      'begin',\n      'bias',\n      'by',\n      'class',\n      'clip',\n      'clippathunits',\n      'clip-path',\n      'clip-rule',\n      'color',\n      'color-interpolation',\n      'color-interpolation-filters',\n      'color-profile',\n      'color-rendering',\n      'cx',\n      'cy',\n      'd',\n      'dx',\n      'dy',\n      'diffuseconstant',\n      'direction',\n      'display',\n      'divisor',\n      'dur',\n      'edgemode',\n      'elevation',\n      'end',\n      'fill',\n      'fill-opacity',\n      'fill-rule',\n      'filter',\n      'filterunits',\n      'flood-color',\n      'flood-opacity',\n      'font-family',\n      'font-size',\n      'font-size-adjust',\n      'font-stretch',\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'fx',\n      'fy',\n      'g1',\n      'g2',\n      'glyph-name',\n      'glyphref',\n      'gradientunits',\n      'gradienttransform',\n      'height',\n      'href',\n      'id',\n      'image-rendering',\n      'in',\n      'in2',\n      'k',\n      'k1',\n      'k2',\n      'k3',\n      'k4',\n      'kerning',\n      'keypoints',\n      'keysplines',\n      'keytimes',\n      'lang',\n      'lengthadjust',\n      'letter-spacing',\n      'kernelmatrix',\n      'kernelunitlength',\n      'lighting-color',\n      'local',\n      'marker-end',\n      'marker-mid',\n      'marker-start',\n      'markerheight',\n      'markerunits',\n      'markerwidth',\n      'maskcontentunits',\n      'maskunits',\n      'max',\n      'mask',\n      'media',\n      'method',\n      'mode',\n      'min',\n      'name',\n      'numoctaves',\n      'offset',\n      'operator',\n      'opacity',\n      'order',\n      'orient',\n      'orientation',\n      'origin',\n      'overflow',\n      'paint-order',\n      'path',\n      'pathlength',\n      'patterncontentunits',\n      'patterntransform',\n      'patternunits',\n      'points',\n      'preservealpha',\n      'preserveaspectratio',\n      'primitiveunits',\n      'r',\n      'rx',\n      'ry',\n      'radius',\n      'refx',\n      'refy',\n      'repeatcount',\n      'repeatdur',\n      'restart',\n      'result',\n      'rotate',\n      'scale',\n      'seed',\n      'shape-rendering',\n      'specularconstant',\n      'specularexponent',\n      'spreadmethod',\n      'startoffset',\n      'stddeviation',\n      'stitchtiles',\n      'stop-color',\n      'stop-opacity',\n      'stroke-dasharray',\n      'stroke-dashoffset',\n      'stroke-linecap',\n      'stroke-linejoin',\n      'stroke-miterlimit',\n      'stroke-opacity',\n      'stroke',\n      'stroke-width',\n      'style',\n      'surfacescale',\n      'systemlanguage',\n      'tabindex',\n      'targetx',\n      'targety',\n      'transform',\n      'transform-origin',\n      'text-anchor',\n      'text-decoration',\n      'text-rendering',\n      'textlength',\n      'type',\n      'u1',\n      'u2',\n      'unicode',\n      'values',\n      'viewbox',\n      'visibility',\n      'version',\n      'vert-adv-y',\n      'vert-origin-x',\n      'vert-origin-y',\n      'width',\n      'word-spacing',\n      'wrap',\n      'writing-mode',\n      'xchannelselector',\n      'ychannelselector',\n      'x',\n      'x1',\n      'x2',\n      'xmlns',\n      'y',\n      'y1',\n      'y2',\n      'z',\n      'zoomandpan'\n    ]);\n    const mathMl = freeze([\n      'accent',\n      'accentunder',\n      'align',\n      'bevelled',\n      'close',\n      'columnsalign',\n      'columnlines',\n      'columnspan',\n      'denomalign',\n      'depth',\n      'dir',\n      'display',\n      'displaystyle',\n      'encoding',\n      'fence',\n      'frame',\n      'height',\n      'href',\n      'id',\n      'largeop',\n      'length',\n      'linethickness',\n      'lspace',\n      'lquote',\n      'mathbackground',\n      'mathcolor',\n      'mathsize',\n      'mathvariant',\n      'maxsize',\n      'minsize',\n      'movablelimits',\n      'notation',\n      'numalign',\n      'open',\n      'rowalign',\n      'rowlines',\n      'rowspacing',\n      'rowspan',\n      'rspace',\n      'rquote',\n      'scriptlevel',\n      'scriptminsize',\n      'scriptsizemultiplier',\n      'selection',\n      'separator',\n      'separators',\n      'stretchy',\n      'subscriptshift',\n      'supscriptshift',\n      'symmetric',\n      'voffset',\n      'width',\n      'xmlns'\n    ]);\n    const xml = freeze([\n      'xlink:href',\n      'xml:id',\n      'xlink:title',\n      'xml:space',\n      'xmlns:xlink'\n    ]);\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n    const DOCTYPE_NAME = seal(/^html$/i);\n    var EXPRESSIONS = Object.freeze({\n      __proto__: null,\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\n      ERB_EXPR: ERB_EXPR,\n      TMPLIT_EXPR: TMPLIT_EXPR,\n      DATA_ATTR: DATA_ATTR,\n      ARIA_ATTR: ARIA_ATTR,\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\n      DOCTYPE_NAME: DOCTYPE_NAME\n    });\n    const getGlobal = () => typeof window === 'undefined' ? null : window;\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n      let suffix = null;\n      const ATTR_NAME = 'data-tt-policy-suffix';\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n      }\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML(html) {\n            return html;\n          },\n          createScriptURL(scriptUrl) {\n            return scriptUrl;\n          }\n        });\n      } catch (_) {\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      const DOMPurify = root => createDOMPurify(root);\n      DOMPurify.version = '3.0.5';\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== 9) {\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      const originalDocument = window.document;\n      const currentScript = originalDocument.currentScript;\n      let {document} = window;\n      const {DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes} = window;\n      const ElementPrototype = Element.prototype;\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n      if (typeof HTMLTemplateElement === 'function') {\n        const template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      let trustedTypesPolicy;\n      let emptyHTML = '';\n      const {implementation, createNodeIterator, createDocumentFragment, getElementsByTagName} = document;\n      const {importNode} = originalDocument;\n      let hooks = {};\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n      const {MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE} = EXPRESSIONS;\n      let {IS_ALLOWED_URI: IS_ALLOWED_URI$1} = EXPRESSIONS;\n      let ALLOWED_TAGS = null;\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n      ]);\n      let ALLOWED_ATTR = null;\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n      ]);\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n      let FORBID_TAGS = null;\n      let FORBID_ATTR = null;\n      let ALLOW_ARIA_ATTR = true;\n      let ALLOW_DATA_ATTR = true;\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\n      let SAFE_FOR_TEMPLATES = false;\n      let WHOLE_DOCUMENT = false;\n      let SET_CONFIG = false;\n      let FORCE_BODY = false;\n      let RETURN_DOM = false;\n      let RETURN_DOM_FRAGMENT = false;\n      let RETURN_TRUSTED_TYPE = false;\n      let SANITIZE_DOM = true;\n      let SANITIZE_NAMED_PROPS = false;\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n      let KEEP_CONTENT = true;\n      let IN_PLACE = false;\n      let USE_PROFILES = {};\n      let FORBID_CONTENTS = null;\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        'annotation-xml',\n        'audio',\n        'colgroup',\n        'desc',\n        'foreignobject',\n        'head',\n        'iframe',\n        'math',\n        'mi',\n        'mn',\n        'mo',\n        'ms',\n        'mtext',\n        'noembed',\n        'noframes',\n        'noscript',\n        'plaintext',\n        'script',\n        'style',\n        'svg',\n        'template',\n        'thead',\n        'title',\n        'video',\n        'xmp'\n      ]);\n      let DATA_URI_TAGS = null;\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        'audio',\n        'video',\n        'img',\n        'source',\n        'image',\n        'track'\n      ]);\n      let URI_SAFE_ATTRIBUTES = null;\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        'alt',\n        'class',\n        'for',\n        'id',\n        'label',\n        'name',\n        'pattern',\n        'placeholder',\n        'role',\n        'summary',\n        'title',\n        'value',\n        'style',\n        'xmlns'\n      ]);\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      let NAMESPACE = HTML_NAMESPACE;\n      let IS_EMPTY_INPUT = false;\n      let ALLOWED_NAMESPACES = null;\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n      ], stringToString);\n      let PARSER_MEDIA_TYPE;\n      const SUPPORTED_PARSER_MEDIA_TYPES = [\n        'application/xhtml+xml',\n        'text/html'\n      ];\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      let transformCaseFunc;\n      let CONFIG = null;\n      const formElement = document.createElement('form');\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n      const _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n        if (!cfg || typeof cfg !== 'object') {\n          cfg = {};\n        }\n        cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n        RETURN_DOM = cfg.RETURN_DOM || false;\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n        FORCE_BODY = cfg.FORCE_BODY || false;\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n        IN_PLACE = cfg.IN_PLACE || false;\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, [...text]);\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html$1);\n            addToSet(ALLOWED_ATTR, html);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg$1);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl$1);\n            addToSet(ALLOWED_ATTR, mathMl);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, [\n            'html',\n            'head',\n            'body'\n          ]);\n        }\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n          }\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n          }\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        } else {\n          if (trustedTypesPolicy === undefined) {\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n          }\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n            emptyHTML = trustedTypesPolicy.createHTML('');\n          }\n        }\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        'mi',\n        'mo',\n        'mn',\n        'ms',\n        'mtext'\n      ]);\n      const HTML_INTEGRATION_POINTS = addToSet({}, [\n        'foreignobject',\n        'desc',\n        'title',\n        'annotation-xml'\n      ]);\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        'title',\n        'style',\n        'font',\n        'a',\n        'script'\n      ]);\n      const ALL_SVG_TAGS = addToSet({}, svg$1);\n      addToSet(ALL_SVG_TAGS, svgFilters);\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\n      const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n      const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return true;\n        }\n        return false;\n      };\n      const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, { element: node });\n        try {\n          node.parentNode.removeChild(node);\n        } catch (_) {\n          node.remove();\n        }\n      };\n      const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {\n            }\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {\n            }\n          }\n        }\n      };\n      const _initDocument = function _initDocument(dirty) {\n        let doc;\n        let leadingWhitespace;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {\n          }\n        }\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n          } catch (_) {\n          }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n      const _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n      };\n      const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n      };\n      const _isNode = function _isNode(object) {\n        return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n      };\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], hook => {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content;\n        _executeHook('beforeSanitizeElements', currentNode, null);\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        const tagName = transformCaseFunc(currentNode.nodeName);\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n              return false;\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n              return false;\n          }\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              const childCount = childNodes.length;\n              for (let i = childCount - 1; i >= 0; --i) {\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n          content = currentNode.textContent;\n          content = stringReplace(content, MUSTACHE_EXPR, ' ');\n          content = stringReplace(content, ERB_EXPR, ' ');\n          content = stringReplace(content, TMPLIT_EXPR, ' ');\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n            currentNode.textContent = content;\n          }\n        }\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName));\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName));\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\n          else {\n            return false;\n          }\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if (value) {\n          return false;\n        } else ;\n        return true;\n      };\n      const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf('-') > 0;\n      };\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        let attr;\n        let value;\n        let lcName;\n        let l;\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        const {attributes} = currentNode;\n        if (!attributes) {\n          return;\n        }\n        const hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        while (l--) {\n          attr = attributes[l];\n          const {name, namespaceURI} = attr;\n          value = name === 'value' ? attr.value : stringTrim(attr.value);\n          const initValue = value;\n          lcName = transformCaseFunc(name);\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined;\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n            value = stringReplace(value, MUSTACHE_EXPR, ' ');\n            value = stringReplace(value, ERB_EXPR, ' ');\n            value = stringReplace(value, TMPLIT_EXPR, ' ');\n          }\n          const lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n            _removeAttribute(name, currentNode);\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\n          }\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n            if (namespaceURI);\n            else {\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML': {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL': {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n              }\n            }\n          }\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                currentNode.setAttribute(name, value);\n              }\n            } catch (_) {\n              _removeAttribute(name, currentNode);\n            }\n          }\n        }\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode;\n        const shadowIterator = _createIterator(fragment);\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n          _sanitizeAttributes(shadowNode);\n        }\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n      DOMPurify.sanitize = function (dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body;\n        let importedNode;\n        let currentNode;\n        let returnNode;\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString === 'function') {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          } else {\n            throw typeErrorCreate('toString is not a function');\n          }\n        }\n        if (!DOMPurify.isSupported) {\n          return dirty;\n        }\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n        DOMPurify.removed = [];\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          if (dirty.nodeName) {\n            const tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            body.appendChild(importedNode);\n          }\n        } else {\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n          body = _initDocument(dirty);\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n        const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        while (currentNode = nodeIterator.nextNode()) {\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n          _sanitizeAttributes(currentNode);\n        }\n        if (IN_PLACE) {\n          return dirty;\n        }\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n      DOMPurify.setConfig = function (cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          return arrayPop(hooks[entryPoint]);\n        }\n      };\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const each$4 = Tools.each, trim = Tools.trim;\n    const queryParts = [\n      'source',\n      'protocol',\n      'authority',\n      'userInfo',\n      'user',\n      'password',\n      'host',\n      'port',\n      'relative',\n      'path',\n      'directory',\n      'file',\n      'query',\n      'anchor'\n    ];\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        var _a;\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      constructor(url, settings = {}) {\n        this.path = '';\n        this.directory = '';\n        url = trim(url);\n        this.settings = settings;\n        const baseUri = settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            if (match) {\n              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n            }\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        if (urlMatch) {\n          each$4(queryParts, (v, i) => {\n            let part = urlMatch[i];\n            if (part) {\n              part = part.replace(/\\(mce_at\\)/g, '@@');\n            }\n            self[v] = part;\n          });\n        }\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        if (pathMatch) {\n          this.path = pathMatch[0];\n          this.directory = pathMatch[1];\n          this.file = pathMatch[2];\n        }\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        let output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let nb = 0;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        const normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        const baseParts = [];\n        each$4(normalizedBase, k => {\n          if (k) {\n            baseParts.push(k);\n          }\n        });\n        const pathParts = [];\n        for (let i = normalizedPath.length - 1; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          pathParts.push(normalizedPath[i]);\n        }\n        const i = baseParts.length - nb;\n        let outPath;\n        if (i <= 0) {\n          outPath = reverse(pathParts).join('/');\n        } else {\n          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    let uid = 0;\n    const processNode = (node, settings, schema, scope, evt) => {\n      var _a, _b, _c, _d;\n      const validate = settings.validate;\n      const specialElements = schema.getSpecialElements();\n      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n        node.nodeValue = ' ' + node.nodeValue;\n      }\n      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n      if (scope !== 'html' && schema.isValid(scope)) {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n        return;\n      }\n      if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n        return;\n      }\n      const element = SugarElement.fromDom(node);\n      const isInternalElement = has$1(element, internalElementAttr);\n      const bogus = get$9(element, 'data-mce-bogus');\n      if (!isInternalElement && isString(bogus)) {\n        if (bogus === 'all') {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      }\n      const rule = schema.getElementRule(lcTagName);\n      if (validate && !rule) {\n        if (has$2(specialElements, lcTagName)) {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      } else {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n      }\n      if (validate && rule && !isInternalElement) {\n        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n        });\n        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n          if (!has$1(element, attr.name)) {\n            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          }\n        });\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n          unwrap(element);\n          return;\n        }\n        if (rule.removeEmptyAttrs && hasNone(element)) {\n          unwrap(element);\n          return;\n        }\n        if (rule.outputName && rule.outputName !== lcTagName) {\n          mutate(element, rule.outputName);\n        }\n      }\n    };\n    const processAttr = (ele, settings, schema, scope, evt) => {\n      const tagName = ele.tagName.toLowerCase();\n      const {attrName, attrValue} = evt;\n      evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n      if (evt.keepAttr) {\n        evt.allowedAttributes[attrName] = true;\n        if (isBooleanAttribute(attrName, schema)) {\n          evt.attrValue = attrName;\n        }\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n          evt.forceKeepAttr = true;\n        }\n      } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n        evt.forceKeepAttr = true;\n      }\n    };\n    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n      if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n        return true;\n      }\n      return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n    };\n    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n    const filterAttributes = (ele, settings, schema, scope) => {\n      const {attributes} = ele;\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        const attr = attributes[i];\n        const attrName = attr.name;\n        const attrValue = attr.value;\n        if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n          ele.removeAttribute(attrName);\n        } else if (isBooleanAttribute(attrName, schema)) {\n          ele.setAttribute(attrName, attrName);\n        }\n      }\n    };\n    const setupPurify = (settings, schema, namespaceTracker) => {\n      const purify$1 = purify();\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n      });\n      return purify$1;\n    };\n    const getPurifyConfig = (settings, mimeType) => {\n      const basePurifyConfig = {\n        IN_PLACE: true,\n        ALLOW_UNKNOWN_PROTOCOLS: true,\n        ALLOWED_TAGS: [\n          '#comment',\n          '#cdata-section',\n          'body'\n        ],\n        ALLOWED_ATTR: []\n      };\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const sanitizeNamespaceElement = ele => {\n      const xlinkAttrs = [\n        'type',\n        'href',\n        'role',\n        'arcrole',\n        'title',\n        'show',\n        'actuate',\n        'label',\n        'from',\n        'to'\n      ].map(name => `xlink:${ name }`);\n      const config = {\n        IN_PLACE: true,\n        USE_PROFILES: {\n          html: true,\n          svg: true,\n          svgFilters: true\n        },\n        ALLOWED_ATTR: xlinkAttrs\n      };\n      purify().sanitize(ele, config);\n      return ele.innerHTML;\n    };\n    const getSanitizer = (settings, schema) => {\n      const namespaceTracker = createNamespaceTracker();\n      if (settings.sanitize) {\n        const purify = setupPurify(settings, schema, namespaceTracker);\n        const sanitizeHtmlElement = (body, mimeType) => {\n          purify.sanitize(body, getPurifyConfig(settings, mimeType));\n          purify.removed = [];\n          namespaceTracker.reset();\n        };\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      } else {\n        const sanitizeHtmlElement = (body, _mimeType) => {\n          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n          let node;\n          while (node = nodeIterator.nextNode()) {\n            const currentScope = namespaceTracker.track(node);\n            processNode(node, settings, schema, currentScope);\n            if (isElement$6(node)) {\n              filterAttributes(node, settings, schema, currentScope);\n            }\n          }\n          namespaceTracker.reset();\n        };\n        const sanitizeNamespaceElement = noop;\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      }\n    };\n\n    const makeMap = Tools.makeMap, extend$1 = Tools.extend;\n    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n          if (isNonHtmlElementRootName(child.name)) {\n            nsSanitizer(nativeChild);\n            child.value = nativeChild.innerHTML;\n          }\n        } else if (isText$a(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        if (!isNonHtmlElementRootName(child.name)) {\n          transferChildren(child, nativeChild, specialElements, nsSanitizer);\n        }\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n        const tempNode = node;\n        each$e(preprocessors, preprocess => preprocess(tempNode));\n        if (isNullable(tempNode.parent) && tempNode !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(tempNode);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$e(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const textRootBlockElements = getTextRootBlockElements(schema);\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        let tempNode = node.parent;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in whitespaceElements) {\n            return true;\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isTextRootBlockEmpty = node => {\n        let tempNode = node;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in textRootBlockElements) {\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour) || isNullable(node.parent)) {\n          return false;\n        }\n        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n      };\n      const preprocess = node => {\n        var _a;\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n              paddEmptyNode(settings, args, isBlock, node);\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\n              if (isBlock(node)) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, isBlock, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilterRegistry = create$8();\n      const attributeFilterRegistry = create$8();\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        sanitize: true,\n        ...settings\n      };\n      const parser = new DOMParser();\n      const sanitizer = getSanitizer(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\n        sanitizer.sanitizeHtmlElement(body, mimeType);\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = nodeFilterRegistry.addFilter;\n      const getNodeFilters = nodeFilterRegistry.getFilters;\n      const removeNodeFilter = nodeFilterRegistry.removeFilter;\n      const addAttributeFilter = attributeFilterRegistry.addFilter;\n      const getAttributeFilters = attributeFilterRegistry.getFilters;\n      const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n      const findInvalidChildren = (node, invalidChildren) => {\n        if (isInvalid(schema, node)) {\n          invalidChildren.push(node);\n        }\n      };\n      const isWrappableNode = (blockElements, node) => {\n        const isInternalElement = isString(node.attr(internalElementAttr));\n        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);\n        return node.type === 3 || isInlineElement && !isInternalElement;\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          var _a, _b;\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (isWrappableNode(blockElements, node)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        updateChildren(schema, element);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n        element.innerHTML = '';\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        removeAttributeFilter,\n        addNodeFilter,\n        getNodeFilters,\n        removeNodeFilter,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent, parserSettings) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false,\n            ...parserSettings\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\n          ...args,\n          content\n        }), {\n          sanitize: shouldSanitizeXss(editor),\n          sandbox_iframes: shouldSandboxIframes(editor)\n        });\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }), {\n          sanitize: shouldSanitizeXss(editor),\n          sandbox_iframes: shouldSandboxIframes(editor)\n        });\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      return getOpt(td, key).bind(toInt).getOr(1);\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$a(td, 'colspan');\n          remove$a(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$e(descendants(tableElm, 'tr'), (tr, y) => {\n        each$e(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem$1(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng, schema) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n    const read$3 = (rootNode, ranges, schema) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$2(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      var _a;\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n      cleanupBogusElements(rangeContentClone);\n      cleanupInputNames(rangeContentClone);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rangeContentClone.dom);\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n        return null;\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$a(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$e(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n      return item.length > 0;\n    });\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = body => body.querySelector('iframe') !== null;\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const tempAttrs = editor.serializer.getTempAttrs();\n      const body = trim$1(editor.getBody(), tempAttrs);\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      if (bookmark) {\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.scrollIntoView();\n      }\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set$1(elm, getLevelContent(level));\n      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      const newLevel = Tools.extend(level || {}, currentLevel);\n      if (!isUnlocked(locks) || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level: newLevel,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, newLevel)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      newLevel.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(newLevel);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level: newLevel,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return newLevel;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      each$e(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: range => create$9(editor, range),\n        removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$t = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$5(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start, schema) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, schema, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, schema, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start, schema) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n          normalizeWhitespaceAfter(text, 0, schema);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n          normalizeWhitespaceBefore(text, text.length, schema);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n        return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start, schema));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n      });\n    };\n    const rngSetContent = (rng, fragment, schema) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n      mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (has$2(callbackMap, selector)) {\n        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n      const setup = () => {\n        selectorChangedData = {};\n        currentSelectors = {};\n        editor.on('NodeChange', e => {\n          const node = e.element;\n          const parents = getParents(node);\n          const matchedSelectors = {};\n          each$d(selectorChangedData, (callbacks, selector) => {\n            findMatchingNode(selector, parents).each(node => {\n              if (!currentSelectors[selector]) {\n                each$e(callbacks, callback => {\n                  callback(true, {\n                    node,\n                    selector,\n                    parents\n                  });\n                });\n                currentSelectors[selector] = callbacks;\n              }\n              matchedSelectors[selector] = callbacks;\n            });\n          });\n          each$d(currentSelectors, (callbacks, selector) => {\n            if (!matchedSelectors[selector]) {\n              delete currentSelectors[selector];\n              each$e(callbacks, callback => {\n                callback(false, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n            }\n          });\n        });\n      };\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            setup();\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const isEditable = () => {\n        const rng = getRng$1();\n        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n        if (fakeSelectedElements.length > 0) {\n          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n        } else {\n          return isEditableRange(dom, rng);\n        }\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let rng;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          const selection = getSel();\n          if (selection && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (isDocument$1(rng.startContainer) && rng.collapsed) {\n          const elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              const node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.nodeName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        const focusRange = dom.createRng();\n        try {\n          anchorRange.setStart(anchorNode, sel.anchorOffset);\n          anchorRange.collapse(true);\n          focusRange.setStart(focusNode, sel.focusOffset);\n          focusRange.collapse(true);\n        } catch (e) {\n          return true;\n        }\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n      const exports = {\n        dom,\n        win,\n        serializer,\n        editor,\n        expand,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isEditable,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n              var _a;\n              return !isZwsp$1((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n            });\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('noscript', nodes => {\n        var _a;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i].firstChild;\n          if (node) {\n            node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        var _a;\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const firstChild = node.firstChild;\n          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.value;\n          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$e(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, htmlParser, htmlParser.schema);\n      }\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const defaultedSettings = {\n        entity_encoding: 'named',\n        remove_trailing_brs: true,\n        pad_empty_with_br: false,\n        ...settings\n      };\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n      const htmlParser = DomParser(defaultedSettings, schema);\n      register$3(htmlParser, defaultedSettings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters,\n        removeNodeFilter: htmlParser.removeNodeFilter,\n        removeAttributeFilter: htmlParser.removeAttributeFilter\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters,\n        removeNodeFilter: domSerializer.removeNodeFilter,\n        removeAttributeFilter: domSerializer.removeAttributeFilter\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n    const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n    const deprecatedPlugins = [\n      {\n        name: 'template',\n        replacedWith: 'Advanced Template'\n      },\n      { name: 'rtc' }\n    ];\n    const getMatchingOptions = (options, searchingFor) => {\n      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n      return sort(settingNames);\n    };\n    const getRemovedOptions = options => {\n      const settingNames = getMatchingOptions(options, removedOptions);\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n    const getMatchingPlugins = (options, searchingFor) => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$5(searchingFor, hasPlugin);\n      return sort(pluginNames);\n    };\n    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n      if (entry.replacedWith) {\n        return `${ name }, replaced by ${ entry.replacedWith }`;\n      } else {\n        return name;\n      }\n    });\n    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n      const deprecatedOptions = getDeprecatedOptions(rawOptions);\n      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n      const hasDeprecatedOptions = deprecatedOptions.length > 0;\n      if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n        const listJoiner = '\\n- ';\n        const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';\n        const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n      logDeprecatedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      const ed = editor;\n      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n      ed.iframeElement = ed.targetElm = null;\n      const selection = editor.selection;\n      if (selection) {\n        const dom = selection.dom;\n        ed.selection = selection.win = selection.dom = dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          delete form._mceOldSubmit;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        } else {\n          return { icons: {} };\n        }\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    var NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        each$e(notifications, notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return {};\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n            reposition();\n            if (hasEditorOrUiFocus(editor)) {\n              getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n            }\n          });\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$e(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$5(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$e(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n    const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      return map$3(cssLinks, url => {\n        if (isBundledCssSkinName(url)) {\n          return url;\n        } else if (isContentCssSkinName(url) && !editor.inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate = always) => {\n        const images = filter$5(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (startsWith(src, 'blob:')) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (startsWith(src, 'data:')) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          const imageSrc = img.src;\n          if (has$2(cachedPromises, imageSrc)) {\n            return cachedPromises[imageSrc].then(imageInfo => {\n              if (isString(imageInfo)) {\n                return imageInfo;\n              } else {\n                return {\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                };\n              }\n            });\n          } else {\n            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n              delete cachedPromises[imageSrc];\n              return {\n                image: img,\n                blobInfo\n              };\n            }).catch(error => {\n              delete cachedPromises[imageSrc];\n              return error;\n            });\n            cachedPromises[imageSrc] = newPromise;\n            return newPromise;\n          }\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(Math.random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob: blob,\n            base64: base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$5(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$e(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n    const addPaddingToEmpty = editor => element => {\n      if (isEmptyForPadding(editor, element)) {\n        append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n      }\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$e(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            let shouldDispatchChange = false;\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const {blobInfo, image} = imageInfos[index];\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                  shouldDispatchChange = true;\n                }\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$e(fromDom$1(imagesToRemove), sugarElement => {\n                  const parentOpt = parent(sugarElement);\n                  remove$5(sugarElement);\n                  parentOpt.each(addPaddingToEmpty(editor));\n                  blobCache.removeByUri(sugarElement.dom.src);\n                });\n              });\n            } else if (shouldDispatchChange) {\n              editor.undoManager.dispatchChange();\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          const filteredResult = filter$5(result, resultItem => {\n            if (isString(resultItem)) {\n              displayError(editor, resultItem);\n              return false;\n            } else if (resultItem.uriType === 'blob') {\n              return false;\n            } else {\n              return true;\n            }\n          });\n          if (isRtc(editor)) ; else {\n            each$e(filteredResult, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return filteredResult;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, undefined);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$e(images, img => {\n            const src = img.attr('src');\n            if (!src || blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'left' }\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object',\n            ceFalseOverride: true,\n            styles: {\n              display: 'table',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: '[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'right' },\n            preview: false\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$d(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$e(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const isPreviewItem = item => isNonNullable(item) && isObject(item);\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length > 0) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        const item = isString(sItem) ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestors, siblings) => {\n        let parentCandidate;\n        const ancestor = ancestors[0];\n        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestor;\n            ancestors = ancestors.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n        parent.appendChild(elm);\n        if (siblings) {\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n        return wrapInHtml(parent, ancestors, parentSiblings);\n      };\n      const fragment = dom.create('div');\n      if (ancestry.length > 0) {\n        const item = ancestry[0];\n        const elm = createElement(item);\n        const siblings = isPreviewItem(item) ? item.siblings : undefined;\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n      }\n      return fragment;\n    };\n    const parseSelectorItem = item => {\n      item = Tools.trim(item);\n      let tagName = 'div';\n      const obj = {\n        name: tagName,\n        classes: [],\n        attrs: {},\n        selector: item\n      };\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!isString(selector)) {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let previewCss = '';\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n      };\n      const getComputedStyle = (name, elm) => {\n        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n      };\n      if (isString(format)) {\n        const formats = editor.formatter.get(format);\n        if (!formats) {\n          return '';\n        }\n        format = formats[0];\n      }\n      if ('preview' in format) {\n        const preview = format.preview;\n        if (preview === false) {\n          return '';\n        } else {\n          previewStyles = preview || previewStyles;\n        }\n      }\n      let name = format.block || format.inline || 'span';\n      let previewFrag;\n      const items = parseSelector(format.selector);\n      if (items.length > 0) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      const rawParentFontSize = getComputedStyle('fontSize');\n      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = getComputedStyle(name, previewElm);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = getComputedStyle(name);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$s = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell({});\n      setup$s(editor);\n      setup$v(editor);\n      if (!isRtc(editor)) {\n        setup$u(formatChangeState, editor);\n      }\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n          if (!editor.isDirty()) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n          return;\n        }\n        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n        if (hasOnlyMetaOrCtrlModifier) {\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        dispatchChange: () => {\n          editor.setDirty(true);\n          const level = createFromEditor(editor);\n          level.bookmark = getUndoBookmark(editor.selection);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n          });\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$r = editor => {\n      var _a;\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (isNotEmpty(placeholder)) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n    const getClosestHost = (root, scope) => {\n      const isRoot = node => eq(node, root);\n      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n    };\n    const hasSameHost = (rootNode, blockBoundary) => {\n      const root = SugarElement.fromDom(rootNode);\n      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n    };\n    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n    const hasValidBlocks = blockBoundary => {\n      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);\n      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n    };\n    const skipLastBr = (rootNode, forward, blockPosition) => {\n      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));\n    };\n    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n    const getChildrenUntilBlockBoundary = (block, schema) => {\n      const children = children$1(block);\n      return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n    };\n    const extractChildren = (block, schema) => {\n      const children = getChildrenUntilBlockBoundary(block, schema);\n      each$e(children, remove$5);\n      return children;\n    };\n    const removeEmptyRoot = (rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n    };\n    const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\n      if (isEmpty$2(toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$e(extractChildren(fromBlock, schema), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const isInline = (schema, node) => schema.isInline(name(node));\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\n      if (isEmpty$2(toBlock)) {\n        if (isEmpty$2(fromBlock)) {\n          const getInlineToBlockDescendants = el => {\n            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n            return helper(el, []);\n          };\n          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n            wrap$2(element, descendant);\n            return descendant;\n          }, createPaddingBr());\n          empty(fromBlock);\n          append$1(fromBlock, newFromBlockDescendants);\n        }\n        remove$5(toBlock);\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$e(extractChildren(fromBlock, schema), child => {\n        append$1(toBlock, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\n\n    const backspaceDelete$9 = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (!eq(block1, block2)) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$4(node, isTableCell$2, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$2 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n    };\n    const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$a(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$a(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = getNextPosFn(caretPosition);\n      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(normalizedNextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const getEdgeCefPosition = (editor, atStart) => {\n      const root = editor.getBody();\n      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n    };\n    const isCefAtEdgeSelected = editor => {\n      const rng = editor.selection.getRng();\n      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n    };\n\n    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(!forward);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n      const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n      const toCefElm = to.getNode(!forward);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (!forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (isNullable(elm)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from, schema) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n      } else {\n        return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng, schema) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (!forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n        return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n        return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from, schema);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        return Optional.some(() => {\n          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n        });\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$6 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$2 = isText$a;\n    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return doc.createTextNode(ZWSP$1);\n    };\n    const insertBefore$1 = node => {\n      var _a;\n      if (isText$2(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$2(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter$1 = node => {\n      var _a, _b;\n      if (isText$2(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$2(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n        } else {\n          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$a(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$3(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$3(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$3(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, node.length - 1);\n      }\n    }), element => {\n      remove$3(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => !isRtl(getElement(location));\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$6(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n\n    const isContentEditableFalse$4 = isContentEditableFalse$b;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$a(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      let currentNode = node;\n      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(currentNode)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n        return false;\n      };\n      const targetClientRect = last$2(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      if (node) {\n        add(node);\n        findUntil(direction, root, add, node);\n      }\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const getLastClientRect = caretPosition => {\n      return last$2(caretPosition.getClientRects());\n    };\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getLastClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getLastClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        } else if (isCefAtEdgeSelected(editor)) {\n          const newRange = range.cloneRange();\n          newRange.collapse(direction === HDirection.Backwards);\n          return Optional.from(newRange);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      let nextCaretPosition = getNextPosFn(caretPosition);\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      } else {\n        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$2(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      const root = editor.getBody();\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$5(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$3(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const getPositionFromRange = (range, root, forward) => {\n      const start = CaretPosition.fromRangeStart(range);\n      if (range.collapsed) {\n        return start;\n      } else {\n        const end = CaretPosition.fromRangeEnd(range);\n        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n      }\n    };\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$5(elms, isInlineTarget);\n      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      const caretValue = caret.get();\n      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n          setCaretPosition(editor, removeAndReposition(caretValue, pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$5(elms, isInlineTarget);\n        each$e(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execNativeDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$4 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n    const getParentsUntil = (editor, pred) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n    const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n    const getFormatNodes = (editor, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n    };\n    const getFormatNodesAtStart = editor => {\n      const parentInlines = getParentInlines(editor);\n      return getFormatNodes(editor, parentInlines);\n    };\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const formatNodes = getFormatNodes(editor, parentInlines);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n      return last$3(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const isBrInEmptyElement = (editor, elm) => {\n      const parentElm = elm.parentElement;\n      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n    };\n    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n    const createCaretFormatAtStart = (editor, formatNodes) => {\n      const startElm = editor.selection.getStart();\n      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n      editor.selection.setRng(pos.toRange());\n    };\n    const updateCaretFormat = (editor, updateFormats) => {\n      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n      if (missingFormats.length > 0) {\n        createCaretFormatAtStart(editor, missingFormats);\n      }\n    };\n    const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);\n    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n    const rangeStartParentIsFormatElement = (editor, rng) => {\n      const startParent = rng.startContainer.parentElement;\n      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n    };\n    const rangeStartAndEndHaveSameParent = rng => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n    };\n    const rangeEndsAtEndOfEndContainer = rng => {\n      const endContainer = rng.endContainer;\n      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);\n    };\n    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n    const requiresDeleteRangeOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n    };\n    const deleteRange$1 = editor => {\n      if (requiresDeleteRangeOverride(editor)) {\n        const formatNodes = getFormatNodesAtStart(editor);\n        return Optional.some(() => {\n          execNativeDeleteCommand(editor);\n          updateCaretFormat(editor, formatNodes);\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n    const hasAncestorInlineCaret = (elm, schema) => ancestor$1(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n    const requiresRefreshCaretOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n    };\n    const refreshCaret = editor => {\n      if (requiresRefreshCaretOverride(editor)) {\n        createCaretFormatAtStart(editor, []);\n      }\n      return true;\n    };\n\n    const deleteElement = (editor, forward, element) => {\n      if (isNonNullable(element)) {\n        return Optional.some(() => {\n          editor._selectionOverrides.hideFakeCaret();\n          deleteElement$2(editor, forward, SugarElement.fromDom(element));\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parsedValue - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parsedValue + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem$1(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n    const handle = (editor, command) => {\n      var _a, _b;\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n      const indentValue = parseIndentValue(indentation);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$e(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete$1 = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete$1,\n      backspaceDelete$6,\n      backspaceDelete$7,\n      (editor, forward) => backspaceDelete$4(editor, caret, forward),\n      backspaceDelete$9,\n      backspaceDelete$a,\n      backspaceDelete$5,\n      backspaceDelete$2,\n      backspaceDelete$8,\n      backspaceDelete$3\n    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeDeleteCommand(editor);\n          paddEmptyBody(editor);\n        }\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeForwardDeleteCommand(editor);\n        }\n      }, call);\n    };\n    const setup$q = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$p = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last$1(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (schema, node) => {\n      if (isText$a(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$a(node)) {\n        if (node.data.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.data)) {\n          return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n        }\n      }\n      return false;\n    };\n    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema;\n      const blockElements = schema.getBlockElements();\n      const startNode = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode;\n      let tempNode;\n      let wrapped = false;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!startNode || !isElement$6(startNode)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n        return;\n      }\n      const rng = selection.getRng();\n      const {startContainer, startOffset, endContainer, endOffset} = rng;\n      const restoreSelection = hasFocus(editor);\n      let node = rootNode.firstChild;\n      while (node) {\n        if (isElement$6(node)) {\n          updateElement(schema, node);\n        }\n        if (isValidTarget(schema, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            rootBlockNode = createRootBlock(editor);\n            rootNode.insertBefore(rootBlockNode, node);\n            wrapped = true;\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (wrapped && restoreSelection) {\n        rng.setStart(startContainer, startOffset);\n        rng.setEnd(endContainer, endOffset);\n        selection.setRng(rng);\n        editor.nodeChanged();\n      }\n    };\n    const insertEmptyLine = (editor, root, insertBlock) => {\n      const block = SugarElement.fromDom(createRootBlock(editor));\n      const br = createPaddingBr();\n      append$1(block, br);\n      insertBlock(root, block);\n      const rng = document.createRange();\n      rng.setStartBefore(br.dom);\n      rng.setEndBefore(br.dom);\n      return rng;\n    };\n    const setup$o = editor => {\n      editor.on('NodeChange', curry(addRootBlocks, editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const setup$n = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = node.attr('data-mce-content');\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$m = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$3 = isContentEditableFalse$b;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const flipDirection = (selection, forward) => {\n      const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n      return isRtl(elm) ? !forward : forward;\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n      const rng = pos.toRange();\n      const curRng = editor.selection.getRng();\n      if (forward) {\n        rng.setStart(curRng.startContainer, curRng.startOffset);\n      } else {\n        rng.setEnd(curRng.endContainer, curRng.endOffset);\n      }\n      return rng;\n    }).exists(rng => {\n      moveToRange(editor, rng);\n      return true;\n    });\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const getClosestTargetBlock = (pos, root, schema) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const insertFn = forward ? append$1 : prepend;\n          const rng = insertEmptyLine(editor, root, insertFn);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$3 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const moveUp = (editor, details, summary) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n        editor.execCommand('InsertNewBlockBefore');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const moveDown = (editor, details) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.lastChild === details && isAtLastLine(details, pos)) {\n        editor.execCommand('InsertNewBlockAfter');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$2 = (editor, forward) => {\n      if (forward) {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n      } else {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n      }\n    };\n    const moveV$2 = (editor, forward) => move$2(editor, forward);\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children$1(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isTable$2(node) ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      editor.undoManager.transact(() => {\n        const insertFn = down ? after$4 : before$3;\n        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$4, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$4, editor, true)\n        },\n        ...isMac ? [\n          {\n            keyCode: VK.UP,\n            action: action(selectToEndPoint, editor, false),\n            metaKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.DOWN,\n            action: action(selectToEndPoint, editor, true),\n            metaKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$l = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$a(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$a(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$a(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$a(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);\n    const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTrigger = (text, trigger) => text.substring(trigger.length);\n    const findTrigger = (text, index, trigger) => {\n      let i;\n      const firstChar = trigger.charAt(0);\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (firstChar === char && contains$1(text, trigger, i, index)) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const findStart = (dom, initRange, trigger, minChars = 0) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const buffer = {\n        text: '',\n        offset: 0\n      };\n      const findTriggerIndex = (element, offset, text) => {\n        buffer.text = text + buffer.text;\n        buffer.offset += offset;\n        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);\n      };\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerIndex = text.lastIndexOf(trigger);\n        if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTrigger(text, trigger),\n            range,\n            trigger\n          });\n        }\n      });\n    };\n    const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {\n      const range = dom.createRng();\n      range.selectNode(elm.dom);\n      const text = getText(range);\n      return Optional.some({\n        range,\n        text: stripTrigger(text, trigger),\n        trigger\n      });\n    });\n\n    const isText$1 = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText$1(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => {\n      var _a;\n      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n        const char = spot.container.data.charAt(spot.offset - 1);\n        return !isWhitespace(char);\n      }).isSome();\n    };\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      var _a;\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$e(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind$1 = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind: bind$1,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch$1 = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('trigger'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch$1,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {\n      trigger: spec.ch,\n      ...spec\n    });\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n      const datasetValues = values(dataset);\n      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n      return {\n        dataset,\n        triggers,\n        lookupByTrigger\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last$1(api.load, 50);\n      editor.on('keypress compositionend', e => {\n        if (e.which === 27) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          api.cancelIfNecessary();\n        }\n      });\n      editor.on('remove', update.cancel);\n    };\n    const setup$k = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          removeAutocompleterDecoration(editor);\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          addAutocompleterDecoration(editor, context.range);\n          activeAutocompleter.set({\n            trigger: context.trigger,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.trigger === context.trigger) {\n                if (context.text.length - ac.matchLength >= 10) {\n                  cancelIfNecessary();\n                } else {\n                  activeAutocompleter.set({\n                    ...ac,\n                    matchLength: context.text.length\n                  });\n                  if (uiActive.get()) {\n                    fireAutocompleterUpdate(editor, { lookupData });\n                  } else {\n                    uiActive.set(true);\n                    fireAutocompleterStart(editor, { lookupData });\n                  }\n                }\n              }\n            });\n          });\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const browser$1 = detect$2().browser;\n    const isSafari = browser$1.isSafari();\n    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n    const isEntireNodeSelected = (rng, node) => {\n      var _a;\n      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n    };\n    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n    const getDetailsElements = (dom, rng) => {\n      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n      if (startDetails.isSome() || endDetails.isSome()) {\n        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n        return Optional.some({\n          startSummary,\n          startDetails,\n          endDetails\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n    const isCaretInTheEndOf = (caretPos, element) => {\n      return lastPositionIn(element).exists(pos => {\n        if (isBr$6(pos.getNode())) {\n          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n        } else {\n          return pos.isEqual(caretPos);\n        }\n      });\n    };\n    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n    const setCaretToPosition = (editor, position) => {\n      const node = position.getNode();\n      if (!isUndefined(node)) {\n        editor.selection.setCursorLocation(node, position.offset());\n      }\n    };\n    const moveCaretToDetailsPos = (editor, pos, forward) => {\n      const details = editor.dom.getParent(pos.container(), 'details');\n      if (details && !details.open) {\n        const summary = editor.dom.select('summary', details)[0];\n        if (summary) {\n          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n          newPos.each(pos => setCaretToPosition(editor, pos));\n        }\n      } else {\n        setCaretToPosition(editor, pos);\n      }\n    };\n    const isPartialDelete = (rng, detailsElements) => {\n      const containsStart = element => element.contains(rng.startContainer);\n      const containsEnd = element => element.contains(rng.endContainer);\n      const startInSummary = detailsElements.startSummary.exists(containsStart);\n      const endInSummary = detailsElements.startSummary.exists(containsEnd);\n      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n    };\n    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n      const {dom, selection} = editor;\n      const root = editor.getBody();\n      if (granularity === 'character') {\n        const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n        if (inEmptyParentBlock) {\n          const firstOrLast = forward ? isLastBlock : isFirstBlock;\n          if (firstOrLast) {\n            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n            });\n            if (isBeforeAfterDetails) {\n              return true;\n            }\n          }\n        }\n        return navigate(forward, root, caretPos).fold(never, pos => {\n          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n            if (!forward) {\n              moveCaretToDetailsPos(editor, pos, false);\n            }\n            if (parentBlock && inEmptyParentBlock) {\n              if (forward && isFirstBlock) {\n                return true;\n              } else if (!forward && isLastBlock) {\n                return true;\n              }\n              moveCaretToDetailsPos(editor, pos, forward);\n              editor.dom.remove(parentBlock);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        });\n      } else {\n        return false;\n      }\n    };\n    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n      const selection = editor.selection;\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (granularity === 'selection') {\n        return isPartialDelete(rng, detailElements);\n      } else if (forward) {\n        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n      } else {\n        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n      }\n    };\n    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n    const handleDeleteActionSafari = (editor, forward, granularity) => {\n      const selection = editor.selection;\n      const node = selection.getNode();\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      if (isSummary$1(node)) {\n        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n          emptyNodeContents(node);\n        } else {\n          editor.undoManager.transact(() => {\n            const sel = selection.getSel();\n            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};\n            const applySelection = () => {\n              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n              }\n            };\n            const updateSelection = () => {\n              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n            };\n            const appendAllChildNodes = (from, to) => {\n              each$e(from.childNodes, child => {\n                if (isNode(child)) {\n                  to.appendChild(child);\n                }\n              });\n            };\n            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });\n            appendAllChildNodes(node, container);\n            node.appendChild(container);\n            applySelection();\n            if (granularity === 'word' || granularity === 'line') {\n              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n            }\n            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n              emptyNodeContents(node);\n            } else {\n              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n              updateSelection();\n              appendAllChildNodes(container, node);\n              applySelection();\n            }\n            editor.dom.remove(container);\n          });\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireInputEvent = createAndFireInputEvent('input');\n    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const platform$2 = detect$2();\n    const os = platform$2.os;\n    const isMacOSOriOS = os.isMacOS() || os.isiOS();\n    const browser = platform$2.browser;\n    const isFirefox = browser.isFirefox();\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      const isCollapsed = editor.selection.isCollapsed();\n      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n      const getModifiedGranularity = isWord => {\n        if (isCollapsed) {\n          return isWord ? 'word' : 'line';\n        } else {\n          return 'selection';\n        }\n      };\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$a, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$a, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n        },\n        ...isMacOSOriOS ? [\n          {\n            keyCode: VK.BACKSPACE,\n            altKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            altKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.BACKSPACE,\n            metaKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n          }\n        ] : [\n          {\n            keyCode: VK.BACKSPACE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          }\n        ],\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, true)\n        }\n      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([\n      {\n        keyCode: VK.BACKSPACE,\n        action: action(paddEmptyElement, editor)\n      },\n      {\n        keyCode: VK.DELETE,\n        action: action(paddEmptyElement, editor)\n      },\n      ...isMacOSOriOS ? [\n        {\n          keyCode: VK.BACKSPACE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        ...isBackspaceKeydown ? [{\n            keyCode: isFirefox ? 224 : 91,\n            action: action(refreshCaret, editor)\n          }] : []\n      ] : [\n        {\n          keyCode: VK.BACKSPACE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        }\n      ]\n    ], evt);\n    const setup$j = (editor, caret) => {\n      let isBackspaceKeydown = false;\n      editor.on('keydown', evt => {\n        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupOverride(editor, evt, isBackspaceKeydown);\n        }\n        isBackspaceKeydown = false;\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (isElement$6(node) || isText$a(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n      return null;\n    };\n    const moveToCaretPosition = (editor, root) => {\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        let lastNode = root;\n        let node;\n        while (node = walker.current()) {\n          if (isText$a(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$6(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let editableRoot;\n      let parent = node;\n      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem$1(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n      const dom = editor.dom;\n      const schema = editor.schema;\n      const newBlockName = getForcedRootBlock(editor);\n      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      let node = container;\n      const textInlineElements = schema.getTextInlineElements();\n      let block;\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n        block = dom.create(name || newBlockName, styles || {});\n      } else {\n        block = parentBlock.cloneNode(false);\n      }\n      let caretNode = block;\n      if (!keepStyles) {\n        dom.setAttrib(block, 'style', null);\n        dom.setAttrib(block, 'class', null);\n      } else {\n        do {\n          if (textInlineElements[node.nodeName]) {\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\n              continue;\n            }\n            const clonedNode = node.cloneNode(false);\n            dom.setAttrib(clonedNode, 'id', '');\n            if (block.hasChildNodes()) {\n              clonedNode.appendChild(block.firstChild);\n              block.appendChild(clonedNode);\n            } else {\n              caretNode = clonedNode;\n              block.appendChild(clonedNode);\n            }\n          }\n        } while ((node = node.parentNode) && node !== editableRoot);\n      }\n      setForcedBlockAttrs(editor, block);\n      emptyBlock(caretNode);\n      return block;\n    };\n\n    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n    const isAtDetailsEdge = (root, element, isTextBlock) => {\n      let node = element;\n      while (node && node !== root && isNull(node.nextSibling)) {\n        const parent = node.parentElement;\n        if (!parent || !isTextBlock(parent)) {\n          return isDetails(parent);\n        }\n        node = parent;\n      }\n      return false;\n    };\n    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n    const insertNewLine = (editor, createNewBlock, parentBlock) => {\n      var _a, _b, _c;\n      const newBlock = createNewBlock(getForcedRootBlock(editor));\n      const root = getDetailsRoot(editor, parentBlock);\n      if (!root) {\n        return;\n      }\n      editor.dom.insertAfter(newBlock, root);\n      moveToCaretPosition(editor, newBlock);\n      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n        editor.dom.remove(parentBlock);\n      }\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n      return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isListItem = elm => {\n      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${ styleName }: ${ style };`), (acc, s) => acc + s, '');\n    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const containerParent = containerBlock.parentNode;\n      if (containerBlock === editor.getBody() || !containerParent) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n      let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, { style: getStyles(parentBlock) }) : createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerParent.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n          each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n          if (parentBlockStyles) {\n            newBlock.setAttribute('style', parentBlockStyles);\n          }\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$2(rawNode.data);\n      });\n    };\n    const isWithinNonEditableList = (editor, node) => {\n      const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const containerAndSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      var _a;\n      const firstChilds = [];\n      if (!block) {\n        return;\n      }\n      let currentNode = block;\n      while (currentNode = currentNode.firstChild) {\n        if (dom.isBlock(currentNode)) {\n          return;\n        }\n        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n          firstChilds.push(currentNode);\n        }\n      }\n      let i = firstChilds.length;\n      while (i--) {\n        currentNode = firstChilds[i];\n        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n          dom.remove(currentNode);\n        } else {\n          if (isEmptyAnchor(dom, currentNode)) {\n            dom.remove(currentNode);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (!isText$a(container)) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      let currentNode = node;\n      do {\n        if (isText$a(currentNode)) {\n          currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n        }\n        currentNode = currentNode.firstChild;\n      } while (currentNode);\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (!parentBlock.hasChildNodes()) {\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        let node = container;\n        while (node && node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        let startNode;\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n          const startNodeParent = startNode.parentNode;\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNodeParent.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            const next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const shouldEndContainer = (editor, container) => {\n      const optionValue = shouldEndContainerOnEmptyBlock(editor);\n      if (isNullable(container)) {\n        return false;\n      } else if (isString(optionValue)) {\n        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n      } else {\n        return optionValue;\n      }\n    };\n    const insert$3 = (editor, evt) => {\n      let container;\n      let offset;\n      let parentBlockName;\n      let containerBlock;\n      let isAfterLastNodeInContainer = false;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n      const collapsedAndCef = rng.collapsed && isCef;\n      const createNewBlock$1 = (name, styles) => {\n        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n          return false;\n        }\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$a(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.data.length) {\n            walker.next();\n          }\n        }\n        let node;\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              const name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$a(node) && !isWhitespaceText(node.data)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        let block;\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          block = createNewBlock$1(newBlockName);\n        } else {\n          block = createNewBlock$1();\n        }\n        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {\n          block = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(block, parentBlock);\n        }\n        moveToCaretPosition(editor, block);\n        return block;\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$a(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot || isWithinNonEditableList(editor, container)) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        const liBlock = containerBlock;\n        parentBlock = liBlock;\n        containerBlock = liBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n        return insertNewLine(editor, createNewBlock$1, parentBlock);\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n        return;\n      }\n      const parentBlockParent = parentBlock.parentNode;\n      let newBlock;\n      if (collapsedAndCef) {\n        newBlock = createNewBlock$1(newBlockName);\n        child.fold(() => {\n          append$1(start, SugarElement.fromDom(newBlock));\n        }, child => {\n          before$3(child, SugarElement.fromDom(newBlock));\n        });\n        editor.selection.setCursorLocation(newBlock, 0);\n      } else if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock(false)) {\n        newBlock = insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n        const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') || isNearChildren ? newBlock : parentBlock);\n      } else {\n        const tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        const fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n    const fakeEventName$1 = 'insertParagraph';\n    const blockbreak = {\n      insert: insert$3,\n      fakeEventName: fakeEventName$1\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr = false;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$a(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (isText$a(container) && offset >= container.data.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$6(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$6(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$2 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n    const fakeEventName = 'insertLineBreak';\n    const linebreak = {\n      insert: insert$2,\n      fakeEventName\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inCefBlock = editor => {\n      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNullable(editableRoot);\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const isInRootWithEmptyOrCEF = editor => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n      return rng.collapsed && isCefOpt.getOr(true);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([\n          inPreBlock(true),\n          inCefBlock\n        ], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block()),\n        match([isInRootWithEmptyOrCEF], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insertBreak = (breakType, editor, evt) => {\n      if (!editor.selection.isCollapsed()) {\n        execEditorDeleteCommand(editor);\n      }\n      if (isNonNullable(evt)) {\n        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n      breakType.insert(editor, evt);\n      if (isNonNullable(evt)) {\n        fireInputEvent(editor, breakType.fakeEventName);\n      }\n    };\n    const insert$1 = (editor, evt) => {\n      const br = () => insertBreak(linebreak, editor, evt);\n      const block = () => insertBreak(blockbreak, editor, evt);\n      const logicalAction = getAction(editor, evt);\n      switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n      }\n    };\n\n    const platform$1 = detect$2();\n    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        insert$1(editor, event);\n      });\n    };\n    const isCaretAfterKoreanCharacter = rng => {\n      if (!rng.collapsed) {\n        return false;\n      }\n      const startContainer = rng.startContainer;\n      if (isText$a(startContainer)) {\n        const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n        const char = startContainer.data.charAt(rng.startOffset - 1);\n        return koreanCharRegex.test(char);\n      } else {\n        return false;\n      }\n    };\n    const setup$i = editor => {\n      let iOSSafariKeydownBookmark = Optional.none();\n      const iOSSafariKeydownOverride = editor => {\n        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n        editor.undoManager.add();\n      };\n      const iOSSafariKeyupOverride = (editor, event) => {\n        editor.undoManager.undo();\n        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n        handleEnterKeyEvent(editor, event);\n        iOSSafariKeydownBookmark = Optional.none();\n      };\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n            iOSSafariKeydownOverride(editor);\n          } else {\n            handleEnterKeyEvent(editor, event);\n          }\n        }\n      });\n      editor.on('keyup', event => {\n        if (event.keyCode === VK.ENTER) {\n          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        ...!isMac ? [\n          {\n            keyCode: VK.HOME,\n            action: action(selectToEndPoint, editor, false),\n            ctrlKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.END,\n            action: action(selectToEndPoint, editor, true),\n            ctrlKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$h = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$g = editor => {\n      editor.on('input', e => {\n        if (!e.isComposing) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$2();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$f = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const setup$e = editor => {\n      editor.on('beforeinput', e => {\n        if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$a(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n    };\n    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n      const insertSpaceThunk = () => {\n        const root = SugarElement.fromDom(editor.getBody());\n        if (!editor.selection.isCollapsed()) {\n          editor.getDoc().execCommand('Delete');\n        }\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n      };\n      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        },\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$k(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$e(editor);\n        setup$m(editor);\n        setup$l(editor, caret);\n        setup$j(editor, caret);\n        setup$i(editor);\n        setup$d(editor);\n        setup$g(editor);\n        setup$c(editor);\n        setup$h(editor, caret);\n        setup$f(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args = {}) {\n        const selection = this.editor.selection;\n        let node;\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n          const root = this.editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          const parents = [];\n          this.editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            } else {\n              parents.push(node);\n              return false;\n            }\n          });\n          this.editor.dispatch('NodeChange', {\n            ...args,\n            element: node,\n            parents\n          });\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const imageId = generate$1('image');\n    const getDragImage = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[imageId]);\n    };\n    const setDragImage = (transfer, imageData) => {\n      const dt = transfer;\n      dt[imageId] = imageData;\n    };\n\n    const eventId = generate$1('event');\n    const getEvent = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]);\n    };\n    const mkSetEventFn = type => transfer => {\n      const dt = transfer;\n      dt[eventId] = type;\n    };\n    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n    const setDragstartEvent = mkSetEventFn(0);\n    const setDropEvent = mkSetEventFn(2);\n    const setDragendEvent = mkSetEventFn(1);\n    const checkEvent = expectedType => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]).exists(type => type === expectedType);\n    };\n    const isInDragStartEvent = checkEvent(0);\n\n    const createEmptyFileList = () => Object.freeze({\n      length: 0,\n      item: _ => null\n    });\n\n    const modeId = generate$1('mode');\n    const getMode = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]);\n    };\n    const mkSetModeFn = mode => transfer => {\n      const dt = transfer;\n      dt[modeId] = mode;\n    };\n    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n    const setReadWriteMode = mkSetModeFn(0);\n    const setReadOnlyMode = mkSetModeFn(2);\n    const setProtectedMode = mkSetModeFn(1);\n    const checkMode = expectedMode => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n    };\n    const isInReadWriteMode = checkMode(0);\n    const isInProtectedMode = checkMode(1);\n\n    const normalizeItems = (dataTransfer, itemsImpl) => ({\n      ...itemsImpl,\n      get length() {\n        return itemsImpl.length;\n      },\n      add: (data, type) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          if (isString(data)) {\n            if (!isUndefined(type)) {\n              return itemsImpl.add(data, type);\n            }\n          } else {\n            return itemsImpl.add(data);\n          }\n        }\n        return null;\n      },\n      remove: idx => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.remove(idx);\n        }\n      },\n      clear: () => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.clear();\n        }\n      }\n    });\n\n    const validDropEffects = [\n      'none',\n      'copy',\n      'link',\n      'move'\n    ];\n    const validEffectAlloweds = [\n      'none',\n      'copy',\n      'copyLink',\n      'copyMove',\n      'link',\n      'linkMove',\n      'move',\n      'all',\n      'uninitialized'\n    ];\n    const createDataTransfer = () => {\n      const dataTransferImpl = new window.DataTransfer();\n      let dropEffect = 'move';\n      let effectAllowed = 'all';\n      const dataTransfer = {\n        get dropEffect() {\n          return dropEffect;\n        },\n        set dropEffect(effect) {\n          if (contains$2(validDropEffects, effect)) {\n            dropEffect = effect;\n          }\n        },\n        get effectAllowed() {\n          return effectAllowed;\n        },\n        set effectAllowed(allowed) {\n          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n            effectAllowed = allowed;\n          }\n        },\n        get items() {\n          return normalizeItems(dataTransfer, dataTransferImpl.items);\n        },\n        get files() {\n          if (isInProtectedMode(dataTransfer)) {\n            return createEmptyFileList();\n          } else {\n            return dataTransferImpl.files;\n          }\n        },\n        get types() {\n          return dataTransferImpl.types;\n        },\n        setDragImage: (image, x, y) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            setDragImage(dataTransfer, {\n              image,\n              x,\n              y\n            });\n            dataTransferImpl.setDragImage(image, x, y);\n          }\n        },\n        getData: format => {\n          if (isInProtectedMode(dataTransfer)) {\n            return '';\n          } else {\n            return dataTransferImpl.getData(format);\n          }\n        },\n        setData: (format, data) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.setData(format, data);\n          }\n        },\n        clearData: format => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.clearData(format);\n          }\n        }\n      };\n      setReadWriteMode(dataTransfer);\n      return dataTransfer;\n    };\n    const cloneDataTransfer = original => {\n      const clone = createDataTransfer();\n      const originalMode = getMode(original);\n      setReadOnlyMode(original);\n      setDragstartEvent(clone);\n      clone.dropEffect = original.dropEffect;\n      clone.effectAllowed = original.effectAllowed;\n      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n      each$e(original.types, type => {\n        if (type !== 'Files') {\n          clone.setData(type, original.getData(type));\n        }\n      });\n      each$e(original.files, file => clone.items.add(file));\n      getEvent(original).each(type => {\n        setEvent(clone, type);\n      });\n      originalMode.each(mode => {\n        setMode$1(original, mode);\n        setMode$1(clone, mode);\n      });\n      return clone;\n    };\n\n    const getHtmlData = dataTransfer => {\n      const html = dataTransfer.getData('text/html');\n      return html === '' ? Optional.none() : Optional.some(html);\n    };\n    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n      each$e(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter$1 = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          let currentNode = node.firstChild;\n          if (currentNode) {\n            do {\n              walk(currentNode);\n            } while (currentNode = currentNode.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter$1(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor)\n      }, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return !action(editor, html, pasteHtml$1);\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const createPasteDataTransfer = html => {\n      const dataTransfer = createDataTransfer();\n      setHtmlData(dataTransfer, html);\n      setReadOnlyMode(dataTransfer);\n      return dataTransfer;\n    };\n    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n      const res = process(editor, content, internal);\n      if (!res.cancelled) {\n        const content = res.content;\n        const doPasteAction = () => insertContent(editor, content, pasteAsText);\n        if (shouldSimulateInputEvent) {\n          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });\n          if (!args.isDefaultPrevented()) {\n            doPasteAction();\n            fireInputEvent(editor, 'insertFromPaste');\n          }\n        } else {\n          doPasteAction();\n        }\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n    };\n    const pasteText = (editor, text, shouldSimulateInputEvent) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true, shouldSimulateInputEvent);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {\n        const base64 = base64Encoded ? data : btoa(data);\n        const file = imageItem.file;\n        const blobCache = editor.editorUpload.blobCache;\n        const existingBlobInfo = blobCache.getByData(base64, type);\n        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n        pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false, true);\n      });\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$5(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$e(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content, shouldSimulateInputEvent);\n      } else {\n        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal, false);\n        }\n        if (value.text) {\n          pasteText(editor, value.text, false);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      if (clipboardData) {\n        try {\n          clipboardData.clearData();\n          clipboardData.setData('text/html', html);\n          clipboardData.setData('text/plain', text);\n          clipboardData.setData(internalHtmlMime(), html);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n      const inSummary = !isNull(dom.getParent(target, 'summary'));\n      if (inSummary) {\n        return true;\n      } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n      } else {\n        return false;\n      }\n    };\n    const setupSummaryDeleteByDragFix = editor => {\n      editor.on('input', e => {\n        const hasNoSummary = el => isNull(el.querySelector('summary'));\n        if (e.inputType === 'deleteByDrag') {\n          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n          each$e(brokenDetailElements, details => {\n            if (isBr$6(details.firstChild)) {\n              details.firstChild.remove();\n            }\n            const summary = editor.dom.create('summary');\n            summary.appendChild(createPaddingBr().dom);\n            details.prepend(summary);\n          });\n        }\n      });\n    };\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n        const isInternalDrop = draggingInternallyState.get();\n        if (isInternalDrop && !needsInternalDrop) {\n          return;\n        }\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent || isInternalDrop && needsInternalDrop) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal, true);\n              } else {\n                pasteText(editor, trimmedContent, true);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n      setupSummaryDeleteByDragFix(editor);\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        const initialStateOption = getDetailsInitialState(editor);\n        each$e(elms, details => {\n          if (initialStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (initialStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        const serializedStateOption = getDetailsSerializedState(editor);\n        each$e(elms, details => {\n          if (serializedStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (serializedStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isBr = isBr$6;\n    const isText = isText$a;\n    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n    const findEdgeCaretCandidate = (startNode, scope, forward) => {\n      const walker = new DomTreeWalker(startNode, scope);\n      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n      let result = startNode;\n      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n        if (isCaretCandidate$3(current)) {\n          result = current;\n        }\n      }\n      return result;\n    };\n    const findClosestBlockRange = (startRng, rootNode, schema) => {\n      const startPos = CaretPosition.fromRangeStart(startRng);\n      const clickNode = startPos.getNode();\n      const scope = getClosestScope(clickNode, rootNode, schema);\n      const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n      const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n      const rng = document.createRange();\n      getClosestCef(startNode, scope).fold(() => {\n        if (isText(startNode)) {\n          rng.setStart(startNode, 0);\n        } else {\n          rng.setStartBefore(startNode);\n        }\n      }, cef => rng.setStartBefore(cef.dom));\n      getClosestCef(endNode, scope).fold(() => {\n        if (isText(endNode)) {\n          rng.setEnd(endNode, endNode.data.length);\n        } else {\n          rng.setEndAfter(endNode);\n        }\n      }, cef => rng.setEndAfter(cef.dom));\n      return rng;\n    };\n    const onTripleClickSelect = editor => {\n      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('mousedown', e => {\n        if (e.detail >= 3) {\n          e.preventDefault();\n          onTripleClickSelect(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n        } else {\n          return Optional.none();\n        }\n      };\n      const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n        return caretCandidateRect(sndClosest).filter(rect => {\n          const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n          return deltaDistance < 2 && isText$a(rect.node);\n        });\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return findMap(sortedRects, caretCandidateRect).map(closest => {\n          if (findCloserTextNode && !isText$a(closest.node) && sortedRects.length > 1) {\n            return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n          } else {\n            return closest;\n          }\n        });\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      var _a, _b;\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const getTargetProps = target => ({\n      target,\n      srcElement: target\n    });\n    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\n      ...mouseEvent,\n      dataTransfer,\n      type,\n      ...getTargetProps(target)\n    });\n    const makeDndEvent = (type, target, dataTransfer) => {\n      const fail = die('Function not supported on simulated event.');\n      const event = {\n        bubbles: true,\n        cancelBubble: false,\n        cancelable: true,\n        composed: false,\n        currentTarget: null,\n        defaultPrevented: false,\n        eventPhase: 0,\n        isTrusted: true,\n        returnValue: false,\n        timeStamp: 0,\n        type,\n        composedPath: fail,\n        initEvent: fail,\n        preventDefault: noop,\n        stopImmediatePropagation: noop,\n        stopPropagation: noop,\n        AT_TARGET: window.Event.AT_TARGET,\n        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n        NONE: window.Event.NONE,\n        altKey: false,\n        button: 0,\n        buttons: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        metaKey: false,\n        movementX: 0,\n        movementY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        pageX: 0,\n        pageY: 0,\n        relatedTarget: null,\n        screenX: 0,\n        screenY: 0,\n        shiftKey: false,\n        x: 0,\n        y: 0,\n        detail: 0,\n        view: null,\n        which: 0,\n        initUIEvent: fail,\n        initMouseEvent: fail,\n        getModifierState: fail,\n        dataTransfer,\n        ...getTargetProps(target)\n      };\n      return event;\n    };\n    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n      const copy = cloneDataTransfer(dataTransfer);\n      if (eventType === 'dragstart') {\n        setDragstartEvent(copy);\n        setReadWriteMode(copy);\n      } else if (eventType === 'drop') {\n        setDropEvent(copy);\n        setReadOnlyMode(copy);\n      } else {\n        setDragendEvent(copy);\n        setProtectedMode(copy);\n      }\n      return copy;\n    };\n    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n    };\n\n    const scrollPixelsPerInterval = 32;\n    const scrollIntervalValue = 100;\n    const mouseRangeToTriggerScrollInsideEditor = 8;\n    const mouseRangeToTriggerScrollOutsideEditor = 16;\n    const isContentEditableFalse$1 = isContentEditableFalse$b;\n    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (isNullable(targetElement)) {\n        return false;\n      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      } else {\n        return editor.dom.isEditable(targetElement);\n      }\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const scrollEditor = (direction, amount) => win => () => {\n      const current = direction === 'left' ? win.scrollX : win.scrollY;\n      win.scroll({\n        [direction]: current + amount,\n        behavior: 'smooth'\n      });\n    };\n    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n      const clientHeight = contentAreaContainer.clientHeight;\n      const clientWidth = contentAreaContainer.clientWidth;\n      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n            state.intervalId.set(scrollDown(win));\n          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollUp(win));\n          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n            state.intervalId.set(scrollRight(win));\n          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(win));\n          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n            state.intervalId.set(scrollDown(window));\n          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollUp(window));\n          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n            state.intervalId.set(scrollRight(window));\n          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(window));\n          }\n        }\n      });\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const removeElementWithPadding = (dom, elm) => {\n      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n      removeElement(elm);\n      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n        fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dataTransfer: createDataTransfer(),\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n            intervalId: repeatable(scrollIntervalValue)\n          });\n        }\n      }\n    };\n    const placeCaretAt = (editor, clientX, clientY) => {\n      editor._selectionOverrides.hideFakeCaret();\n      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n        if (range) {\n          editor.selection.setRng(range);\n        } else {\n          editor.selection.placeCaretAt(clientX, clientY);\n        }\n      });\n    };\n    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n      if (type === 'dragstart') {\n        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n      }\n      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n      const args = editor.dispatch(type, event);\n      return args;\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      const state_ = state;\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n          if (isNonNullable(args.dataTransfer)) {\n            state.dataTransfer = args.dataTransfer;\n          }\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const sel = selection.getSel();\n      if (isNonNullable(sel)) {\n        const rng = sel.getRangeAt(0);\n        const startContainer = rng.startContainer;\n        return isText$a(startContainer) ? startContainer.parentNode : startContainer;\n      } else {\n        return null;\n      }\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        var _a;\n        state.intervalId.clear();\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElementWithPadding(editor.dom, state.element);\n                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n        }\n      });\n      removeDragState(state);\n    };\n    const stopDragging = (state, editor, e) => {\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging) {\n          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n    const removeDragState = state => {\n      state.on(state => {\n        state.intervalId.clear();\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          stopDragging(state, editor, Optional.none());\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$e(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$e(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$b;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          if (!dom.isEditable(e.target)) {\n            e.preventDefault();\n            editor.focus();\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isHTMLElement(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parent = rng.startContainer.parentElement;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parent)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$3(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        if (sel) {\n          sel.removeAllRanges();\n          sel.addRange(newRange);\n        }\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$a(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isNonNullable(beforeNode)) {\n              if (isFakeCaretTarget(beforeNode)) {\n                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n              }\n              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(beforeNode, 0);\n                rng.setEnd(beforeNode, 0);\n                return rng;\n              }\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isNonNullable(afterNode)) {\n              if (isFakeCaretTarget(afterNode)) {\n                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n              }\n              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(afterNode, 1);\n                rng.setEnd(afterNode, 1);\n                return rng;\n              }\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (!isElement$6(startContainer)) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const getNormalizedTextOffset = (container, offset) => {\n      let normalizedOffset = offset;\n      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {\n        normalizedOffset += node.data.length;\n      }\n      return normalizedOffset;\n    };\n    const generatePath = (dom, root, node, offset, normalized) => {\n      if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        p.push(dom.nodeIndex(current, normalized));\n        current = current.parentNode;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n      const start = generatePath(dom, root, startNode, startOffset, normalized);\n      const end = generatePath(dom, root, endNode, endOffset, normalized);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      if (!isNumber(offset)) {\n        return Optional.none();\n      } else {\n        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n        return resolvedNode.bind(node => {\n          if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n            return Optional.none();\n          } else {\n            return Optional.some({\n              node,\n              offset\n            });\n          }\n        });\n      }\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n      const dynamicPatterns = patternSet.dynamicPatternsLookup({\n        text: beforeText,\n        block\n      });\n      return {\n        ...patternSet,\n        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n      };\n    };\n    const getBeforeText = (dom, block, node, offset) => {\n      const rng = dom.createRng();\n      rng.setStart(block, 0);\n      rng.setEnd(node, offset);\n      return rng.toString();\n    };\n\n    const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n    const stripPattern = (dom, block, pattern) => {\n      const firstTextNode = textAfter(block, 0, block);\n      firstTextNode.each(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n        const text = SugarElement.fromDom(node);\n        const textContent = get$3(text);\n        if (startsWithSingleSpace(textContent)) {\n          set(text, textContent.slice(1));\n        }\n      });\n    };\n    const applyPattern$1 = (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n    const findPattern$1 = (patterns, text) => {\n      const sortedPatterns = sortPatterns$1(patterns);\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    };\n    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {\n      var _a;\n      const dom = editor.dom;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!dom.is(block, forcedRootBlock)) {\n        return [];\n      }\n      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n      return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {\n        if (Tools.trim(blockText).length === pattern.start.length) {\n          return [];\n        }\n        return [{\n            pattern,\n            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n          }];\n      }).getOr([]);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$e(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      const startParentNode = textStart.parentNode;\n      const endParentNode = textEnd.parentNode;\n      return {\n        prefix: markerPrefix,\n        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        var _a, _b;\n        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n        if (isCompleteMatch) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          var _a;\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern = (editor, block, details, normalizedMatches) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const text = getBeforeText(dom, block, node, offset);\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          }, normalizedMatches);\n          if (result.isNone() && offset > 0) {\n            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n          }\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$e(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n    const getBestMatches = (matches, matchesWithSortedPatterns) => {\n      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n      if (matches.length === matchesWithSortedPatterns.length) {\n        if (hasSameMatches) {\n          return matches;\n        } else {\n          return matchesWithSortedPatterns;\n        }\n      }\n      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n    };\n    const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {\n      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      return getBestMatches(matches, matchesWithSortedPatterns);\n    };\n    const applyMatches = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$e(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const handleEnter = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        var _a;\n        const offset = Math.max(0, rng.startOffset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n        if (blockMatches.length > 0 || inlineMatches.length > 0) {\n          editor.undoManager.add();\n          editor.undoManager.extra(() => {\n            editor.execCommand('mceInsertNewLine');\n          }, () => {\n            insert$5(editor);\n            applyMatches(editor, inlineMatches);\n            applyMatches$1(editor, blockMatches);\n            const range = editor.selection.getRng();\n            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n            editor.execCommand('mceInsertNewLine');\n            spot.each(s => {\n              const node = s.container;\n              if (node.data.charAt(s.offset - 1) === zeroWidth) {\n                node.deleteData(s.offset - 1, 1);\n                cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n              }\n            });\n          });\n          return true;\n        }\n        return false;\n      }).getOr(false);\n    };\n    const handleInlineKey = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset - 1);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches(editor, inlineMatches);\n          });\n        }\n      });\n    };\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && !VK.modifierPressed(event);\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));\n      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {\n          const patternSet = getPatternSet();\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleEnter(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      const handleInlineTrigger = () => {\n        if (editor.selection.isCollapsed()) {\n          const patternSet = getPatternSet();\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns) {\n            handleInlineKey(editor, patternSet);\n          }\n        }\n      };\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineTrigger();\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, handleInlineTrigger);\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, String(state));\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n            const isCollapsed = editor.selection.isCollapsed();\n            const body = editor.getBody();\n            if (isCollapsed && !isEmpty$2(SugarElement.fromDom(body))) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          } else {\n            return true;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            const applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          let rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          let parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.nodeName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', undefined, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a:not([data-mce-block])'), node => {\n            var _a;\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const isAllContentSelected = editor => {\n        const body = editor.getBody();\n        const rng = editor.selection.getRng();\n        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const dropDragEndEvent = () => {\n        editor.on('drop', event => {\n          var _a;\n          const data = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n          if (isString(data) && /^<img[^>]*>$/.test(data)) {\n            editor.dispatch('dragend', new window.DragEvent('dragend', event));\n          }\n        });\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n          dropDragEndEvent();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$3(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$5(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        sandbox_iframes: getOption('sandbox_iframes'),\n        sanitize: getOption('xss_sanitization'),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html'),\n        padd_empty_block_inline_children: getOption('format_empty_lines')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          remove_trailing_brs: getOption('remove_trailing_brs'),\n          pad_empty_with_br: getOption('pad_empty_with_br'),\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (shouldPreserveCData(editor)) {\n        parser.addNodeFilter('#cdata', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (focusEditor && !focusEditor.destroyed) {\n            focusEditor.focus();\n            focusEditor.selection.scrollIntoView();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const {\n        pass: bundledCss,\n        fail: normalCss\n      } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n      const bundledPromises = bundledCss.map(url => {\n        const css = tinymce.Resource.get(toContentSkinResourceName(url));\n        if (isString(css)) {\n          return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n        }\n        return Promise.resolve();\n      });\n      const promises = [\n        ...bundledPromises,\n        getStyleSheetLoader$1(editor).loadAll(normalCss)\n      ];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const startProgress = editor => {\n      let canceled = false;\n      const progressTimeout = setTimeout(() => {\n        if (!canceled) {\n          editor.setProgressState(true);\n        }\n      }, 500);\n      return () => {\n        clearTimeout(progressTimeout);\n        canceled = true;\n        editor.setProgressState(false);\n      };\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      editor._editableRoot = hasEditableRoot$1(editor);\n      if (!editor.readonly && editor.hasEditableRoot()) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        },\n        force_hex_color: shouldForceHexColor(editor)\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$p(editor);\n      setup$6(editor);\n      setup$n(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$q(editor, caret);\n      setup$o(editor);\n      setup$r(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$t(editor);\n      preInit(editor);\n      setupRtcThunk.fold(() => {\n        const cancelProgress = startProgress(editor);\n        loadContentCss(editor).then(() => {\n          initEditorWithInitialContent(editor);\n          cancelProgress();\n        });\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$3(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = editor.translate('Rich Text Area');\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const setupIframeBody = editor => {\n      const iframe = editor.iframeElement;\n      const ready = () => {\n        editor.contentDocument = iframe.contentDocument;\n        contentBodyLoaded(editor);\n      };\n      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n        const doc = editor.getDoc();\n        doc.open();\n        doc.write(editor.iframeHTML);\n        doc.close();\n        ready();\n      } else {\n        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          ready();\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      }\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        boxInfo.editorContainer.style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      editor.getElement().style.visibility = editor.orgVisibility;\n      setupIframeBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$e(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$d(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      const render = editor.theme.renderUI;\n      return render ? render() : renderThemeFalse(editor);\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = (element, iframe) => {\n      return {\n        editorContainer: element,\n        iframeContainer: iframe,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer, iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          if (!editor.mode.isReadOnly()) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = async editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = await renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      editor.editorContainer = renderInfo.editorContainer;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        contentBodyLoaded(editor);\n      } else {\n        init$1(editor, {\n          editorContainer: renderInfo.editorContainer,\n          iframeContainer: renderInfo.iframeContainer\n        });\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$e(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$d(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$e(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline$1(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const setEditableRoot = (editor, state) => {\n      if (editor._editableRoot !== state) {\n        editor._editableRoot = state;\n        if (!editor.readonly) {\n          editor.getBody().contentEditable = String(editor.hasEditableRoot());\n          editor.nodeChanged();\n        }\n        fireEditableRootStateChange(editor, state);\n      }\n    };\n    const hasEditableRoot = editor => editor._editableRoot;\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$2().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$4);\n        return filter$5(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => [\n      ...normalizePlugins(forcedPlugins),\n      ...normalizePlugins(plugins)\n    ];\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$3 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$e('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands$1 = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$b = editor => {\n      registerExecCommands$3(editor);\n      registerQueryStateCommands$1(editor);\n    };\n\n    const registerCommands$a = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html, schema) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      if (editor.selection.isEditable()) {\n        const {content, details} = processValue$1(value);\n        preProcessSetContent(editor, {\n          ...details,\n          content: trimOrPad(editor, content),\n          format: 'html',\n          set: false,\n          selection: true\n        }).each(args => {\n          const insertedContent = insertContent$1(editor, args.content, details);\n          postProcessSetContent(editor, insertedContent, args);\n          editor.addVisual();\n        });\n      }\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent(getNewDocumentContent(editor));\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const isFont = isTag('font');\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n        if (isFont(elm)) {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n      const container = caret.container();\n      return Optional.from(isText$a(container) ? container.parentNode : container);\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses.length > 0) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          var _a;\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$8 = editor => {\n      registerExecCommands$2(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$7 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$5 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isEditable()) {\n            if (editor.selection.isCollapsed()) {\n              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n              if (elm) {\n                editor.dom.remove(elm, true);\n              }\n              return;\n            }\n            editor.formatter.remove('link');\n          }\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const registerExecCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          editor.getDoc().execCommand(command);\n          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n          if (listElm) {\n            const listParent = listElm.parentNode;\n            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n              const bm = editor.selection.getBookmark();\n              editor.dom.split(listParent, listElm);\n              editor.selection.moveToBookmark(bm);\n            }\n          }\n        }\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n        }\n      }, 'state');\n    };\n    const registerCommands$4 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const getTopParentBlock = (editor, node, root, container) => {\n      const dom = editor.dom;\n      const selector = node => dom.isBlock(node) && node.parentElement === root;\n      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n      return Optional.from(topParentBlock).map(SugarElement.fromDom);\n    };\n    const insert = (editor, before) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n      const container = before ? rng.startContainer : rng.endContainer;\n      const root = getEditableRoot(dom, container);\n      if (!root || !root.isContentEditable) {\n        return;\n      }\n      const insertFn = before ? before$3 : after$4;\n      const newBlockName = getForcedRootBlock(editor);\n      getTopParentBlock(editor, node, root, container).each(parentBlock => {\n        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n        insertFn(parentBlock, SugarElement.fromDom(newBlock));\n        editor.selection.setCursorLocation(newBlock, 0);\n        editor.dispatch('NewBlock', { newBlock });\n        fireInputEvent(editor, 'insertParagraph');\n      });\n    };\n    const insertBefore = editor => insert(editor, true);\n    const insertAfter = editor => insert(editor, false);\n\n    const registerCommands$3 = editor => {\n      editor.editorCommands.addCommands({\n        InsertNewBlockBefore: () => {\n          insertBefore(editor);\n        },\n        InsertNewBlockAfter: () => {\n          insertAfter(editor);\n        }\n      });\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insertBreak(blockbreak, editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert$1(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, _value) => {\n          insertBreak(linebreak, editor);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (isElement$6(node) && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            } else {\n              return true;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value === true);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$b(editor);\n      registerCommands$a(editor);\n      registerCommands$7(editor);\n      registerCommands$1(editor);\n      registerCommands$9(editor);\n      registerCommands$5(editor);\n      registerCommands$6(editor);\n      registerCommands$3(editor);\n      registerCommands$2(editor);\n      registerCommands$4(editor);\n      registerCommands$8(editor);\n      registerExecCommands(editor);\n    };\n\n    const selectionSafeCommands = ['toggleview'];\n    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui = false, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$d(commandList, (callback, command) => {\n          each$e(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const internalContentEditableAttr = 'data-mce-contenteditable';\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && !state) {\n        remove$7(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const switchOffContentEditableTrue = elm => {\n      each$e(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n        set$3(elm, internalContentEditableAttr, 'true');\n        setContentEditable(elm, false);\n      });\n    };\n    const switchOnContentEditableTrue = elm => {\n      each$e(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\n        remove$a(elm, internalContentEditableAttr);\n        setContentEditable(elm, true);\n      });\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        editor.selection.controlSelection.hideResizeRect();\n        editor._selectionOverrides.hideFakeCaret();\n        removeFakeSelection(editor);\n        editor.readonly = true;\n        setContentEditable(body, false);\n        switchOffContentEditableTrue(body);\n      } else {\n        editor.readonly = false;\n        if (editor.hasEditableRoot()) {\n          setContentEditable(body, true);\n        }\n        switchOnContentEditableTrue(body);\n        setEditorCommandState(editor, 'StyleWithCSS', false);\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\n        setEditorCommandState(editor, 'enableObjectResizing', false);\n        if (hasEditorOrUiFocus(editor)) {\n          editor.focus();\n        }\n        restoreFakeSelection(editor);\n        editor.nodeChanged();\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const registerFilters = editor => {\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n            node.attr('contenteditable', 'false');\n          });\n        }\n      });\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\n          });\n        }\n      });\n      editor.serializer.addTempAttr(internalContentEditableAttr);\n    };\n    const registerReadOnlyContentFilters = editor => {\n      if (editor.serializer) {\n        registerFilters(editor);\n      } else {\n        editor.on('PreInit', () => {\n          registerFilters(editor);\n        });\n      }\n    };\n    const isClickEvent = e => e.type === 'click';\n    const allowedEvents = ['copy'];\n    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      } else if (isReadOnlyAllowedEvent(e)) {\n        editor.dispatch(e.type, e);\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('ShowCaret', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('ObjectSelected', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$d(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$e(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$d(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        const binding = this.bindings[name];\n        return !(!binding || binding.length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent ? parent.parent() : undefined;\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$d(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        const delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        const delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized && self.delegates) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$d(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        default:\n          return always;\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlyContentFilters(editor);\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const isModifier = key => key in modifierNames;\n    const parseShortcut = pattern => {\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (isModifier(value)) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      let key;\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const sidebars = {};\n      const views = {};\n      const add = (collection, type) => (name, spec) => {\n        collection[name.toLowerCase()] = {\n          ...spec,\n          type\n        };\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addView: add(views, 'views'),\n        addIcon,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars,\n          views\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        addView: bridge.addView,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.composing = false;\n        this.destroyed = false;\n        this.hasHiddenInput = false;\n        this.iframeElement = null;\n        this.initialized = false;\n        this.readonly = false;\n        this.removed = false;\n        this.startContent = '';\n        this._pendingNativeEvents = [];\n        this._skinLoaded = false;\n        this._editableRoot = true;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        const contentCssCors = hasContentCssCors(self);\n        if (isNonNullable(contentCssCors)) {\n          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline$1(self);\n        this.hasVisual = isVisualAidsEnabled(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args = {}) {\n        const self = this;\n        const elm = self.getElement();\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          const loadArgs = {\n            ...args,\n            load: true\n          };\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          const html = self.setContent(value, loadArgs);\n          if (!loadArgs.no_events) {\n            self.dispatch('LoadContent', {\n              ...loadArgs,\n              element: elm\n            });\n          }\n          return html;\n        } else {\n          return '';\n        }\n      }\n      save(args = {}) {\n        const self = this;\n        let elm = self.getElement();\n        if (!elm || !self.initialized || self.removed) {\n          return '';\n        }\n        const getArgs = {\n          ...args,\n          save: true,\n          element: elm\n        };\n        let html = self.getContent(getArgs);\n        const saveArgs = {\n          ...getArgs,\n          content: html\n        };\n        if (!saveArgs.no_events) {\n          self.dispatch('SaveContent', saveArgs);\n        }\n        if (saveArgs.format === 'raw') {\n          self.dispatch('RawSaveContent', saveArgs);\n        }\n        html = saveArgs.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          const form = DOM$1.getParent(self.id, 'form');\n          if (form) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              } else {\n                return true;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        saveArgs.element = getArgs.element = elm = null;\n        if (saveArgs.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        if (!self.contentWindow) {\n          const elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        if (!self.contentDocument) {\n          const win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        var _a, _b;\n        const doc = this.getDoc();\n        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        const urlObject = new URI(url);\n        if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      setEditableRoot(state) {\n        setEditableRoot(this, state);\n      }\n      hasEditableRoot() {\n        return hasEditableRoot(this);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$5(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n      }\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '6',\n      minorVersion: '8.2',\n      releaseDate: '2023-12-11',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL = '';\n        let suffix = '';\n        let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$w(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let editor;\n        if (!selector) {\n          for (let i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      for (let i = 0; i < rels.length; i++) {\n        const pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const resources = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n        resources[id] = data;\n      };\n      const has = id => {\n        return id in resources;\n      };\n      const unload = id => {\n        delete tasks[id];\n      };\n      const get = id => resources[id];\n      return {\n        load,\n        add,\n        has,\n        get,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce$1 = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (typeof module === 'object') {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce$1);\n    exportToModuleLoaders(tinymce$1);\n\n})();\n"]},"metadata":{},"sourceType":"script"}